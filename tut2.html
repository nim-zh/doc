<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nimrod. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>

<!-- Google fonts -->
<link href='http://fonts.googleapis.com/css?family=Raleway:400,600,900' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'>

<!-- CSS -->
<title>Nim 语言教程 (第二部分)</title>
<style type="text/css" >
/*
Stylesheet for use with Docutils/rst2html.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.

Modified from Chad Skeeters' rst2html-style
https://bitbucket.org/cskeeters/rst2html-style/

Modified by Boyd Greenfield
*/
/* SCSS variables */
/* Text weights */
/* Body colors */
/* Text colors */
/* Link colors */
/* Syntax highlighting colors */
/* Pct changes */
/* Mixins */
/* Body/layout */
html {
  font-size: 100%;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%; }

/* Where we want fancier font if available */
h1, h2, h3, h4, h5, h6, p.module-desc, table.docinfo + blockquote p, table.docinfo blockquote p, h1 + blockquote p {
  font-family: "Raleway", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif !important; }

h1.title {
  font-weight: 900; }

body {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: 14px;
  line-height: 20px;
  color: #2d2d2d;
  background-color: rgba(252, 248, 244, 0.75); }

/* Skeleton grid */
.container {
  position: relative;
  width: 100%;
  max-width: 960px;
  margin: 0 auto;
  padding: 0 20px;
  box-sizing: border-box; }

.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box; }

/* For devices larger than 400px */
@media (min-width: 400px) {
  .container {
    width: 100%;
    padding: 0; } }
/* For devices larger than 650px */
@media (min-width: 650px) {
  .container {
    width: 100%; }

  .column,
  .columns {
    margin-left: 4%; }

  .column:first-child,
  .columns:first-child {
    margin-left: 0; }

  .one.column,
  .one.columns {
    width: 4.66666666667%; }

  .two.columns {
    width: 13.3333333333%; }

  .three.columns {
    width: 22%; }

  .four.columns {
    width: 30.6666666667%; }

  .five.columns {
    width: 39.3333333333%; }

  .six.columns {
    width: 48%; }

  .seven.columns {
    width: 56.6666666667%; }

  .eight.columns {
    width: 65.3333333333%; }

  .nine.columns {
    width: 74.0%; }

  .ten.columns {
    width: 82.6666666667%; }

  .eleven.columns {
    width: 91.3333333333%; }

  .twelve.columns {
    width: 100%;
    margin-left: 0; }

  .one-third.column {
    width: 30.6666666667%; }

  .two-thirds.column {
    width: 65.3333333333%; } }
/* Customer Overrides */
.footer {
  text-align: center;
  color: #969696;
  padding-top: 10%; }

p.module-desc {
  font-size: 1.1em;
  color: #666666; }

a.link-seesrc {
  color: #aec7d2;
  font-style: italic; }

a.link-seesrc:hover {
  color: #6c9aae; }

#toc-list {
  word-wrap: break-word; }

ul.simple-toc {
  list-style: none; }

ul.simple-toc a.reference-toplevel {
  font-weight: bold;
  color: #0077b3; }

ul.simple-toc-section {
  list-style-type: circle;
  color: #6c9aae; }

ul.simple-toc-section a.reference {
  color: #0077b3; }

cite {
  font-style: italic !important; }

dt > pre {
  border-color: rgba(0, 0, 0, 0.15);
  background-color: transparent;
  margin: 15px 0px 5px; }

dd > pre {
  border-color: rgba(0, 0, 0, 0.1);
  background-color: whitesmoke;
  margin-top: 8px; }

.item > dd {
  margin-left: 10px;
  margin-bottom: 30px; }

/* Nim line-numbered tables */
.line-nums-table {
  width: 100%;
  table-layout: fixed; }

table.line-nums-table {
  border-radius: 4px;
  border: 1px solid #cccccc;
  background-color: whitesmoke;
  border-collapse: separate;
  margin-top: 15px;
  margin-bottom: 25px; }

.line-nums-table tbody {
  border: none; }

.line-nums-table td pre {
  border: none;
  background-color: transparent; }

.line-nums-table td.blob-line-nums {
  width: 28px; }

.line-nums-table td.blob-line-nums pre {
  color: #b0b0b0;
  -webkit-filter: opacity(75%);
  text-align: right;
  border-color: transparent;
  background-color: transparent;
  padding-left: 0px;
  margin-left: 0px;
  padding-right: 0px;
  margin-right: 0px; }

/* Docgen styles */
/* Links */
a {
  color: #0077b3;
  text-decoration: none; }

a:hover,
a:focus {
  color: #00334d;
  text-decoration: underline; }

a:visited {
  color: #00334d; }

a:focus {
  outline: thin dotted #2d2d2d;
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px; }

a:hover,
a:active {
  outline: 0; }

sub,
sup {
  position: relative;
  font-size: 75%;
  line-height: 0;
  vertical-align: baseline; }

sup {
  top: -0.5em; }

sub {
  bottom: -0.25em; }

img {
  width: auto;
  height: auto;
  max-width: 100%;
  vertical-align: middle;
  border: 0;
  -ms-interpolation-mode: bicubic; }

@media print {
  * {
    color: black !important;
    text-shadow: none !important;
    background: transparent !important;
    box-shadow: none !important; }

  a,
  a:visited {
    text-decoration: underline; }

  a[href]:after {
    content: " (" attr(href) ")"; }

  abbr[title]:after {
    content: " (" attr(title) ")"; }

  .ir a:after,
  a[href^="javascript:"]:after,
  a[href^="#"]:after {
    content: ""; }

  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid; }

  thead {
    display: table-header-group; }

  tr,
  img {
    page-break-inside: avoid; }

  img {
    max-width: 100% !important; }

  @page {
    margin: 0.5cm; }

  h1 {
    page-break-before: always; }

  h1.title {
    page-break-before: avoid; }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3; }

  h2,
  h3 {
    page-break-after: avoid; } }
.img-rounded {
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.img-polaroid {
  padding: 4px;
  background-color: rgba(252, 248, 244, 0.75);
  border: 1px solid #ccc;
  border: 1px solid rgba(0, 0, 0, 0.2);
  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }

p {
  margin: 0 0 12px; }

small {
  font-size: 85%; }

strong {
  font-weight: 600; }

em {
  font-style: italic; }

cite {
  font-style: normal; }

h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: 600;
  line-height: 20px;
  color: inherit;
  text-rendering: optimizelegibility; }

h1 {
  font-size: 2em;
  padding-bottom: .15em;
  border-bottom: 1px solid #aaaaaa;
  margin-top: 1.0em;
  line-height: 1.2em; }

h1.title {
  padding-bottom: 1em;
  border-bottom: 0px;
  font-size: 2.75em; }

h2 {
  font-size: 1.5em;
  margin-top: 1.5em; }

h3 {
  font-size: 1.3em;
  font-style: italic;
  margin-top: 0.75em; }

h4 {
  font-size: 1.3em;
  margin-top: 0.5em; }

h5 {
  font-size: 1.2em;
  margin-top: 0.25em; }

h6 {
  font-size: 1.1em; }

ul,
ol {
  padding: 0;
  margin: 0 0 0px 15px; }

ul ul,
ul ol,
ol ol,
ol ul {
  margin-bottom: 0; }

li {
  line-height: 20px; }

dl {
  margin-bottom: 20px; }

dt,
dd {
  line-height: 20px; }

dt {
  font-weight: bold; }

dd {
  margin-left: 10px;
  margin-bottom: 26px; }

hr {
  margin: 20px 0;
  border: 0;
  border-top: 1px solid #eeeeee;
  border-bottom: 1px solid #ffffff; }

abbr[title],
abbr[data-original-title] {
  cursor: help;
  border-bottom: 1px dotted #999999; }

abbr.initialism {
  font-size: 90%;
  text-transform: uppercase; }

blockquote {
  padding: 0 0 0 15px;
  margin: 0 0 20px;
  border-left: 5px solid #EFEBE0; }

table.docinfo + blockquote, table.docinfo blockquote, h1 + blockquote {
  border-left: 5px solid #c9c9c9;
}

table.docinfo + blockquote p, table.docinfo blockquote p, h1 + blockquote p {
  margin-bottom: 0;
  font-size: 15px;
  font-weight: 200;
  line-height: 1.5;
  font-style: italic; }

q:before,
q:after,
blockquote:before,
blockquote:after {
  content: ""; }

address {
  display: block;
  margin-bottom: 20px;
  font-style: normal;
  line-height: 20px; }

code,
pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  padding: 0 3px 2px;
  font-weight: 500;
  font-size: 12px;
  color: #444444;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px; }

.pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  font-weight: 600;
  /*color: #504da6;*/
}

code {
  padding: 2px 4px;
  color: #444444;
  white-space: nowrap;
  background-color: white;
  border: 1px solid #777777; }

pre {
  display: inline-block;
  box-sizing: border-box;
  min-width: calc(100% - 19.5px);
  padding: 9.5px;
  margin: 0 10px 0px 10px;
  font-size: 14px;
  line-height: 20px;
  white-space: pre !important;
  overflow-y: hidden;
  overflow-x: visible;
  background-color: whitesmoke;
  border: 1px solid #cccccc;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px; }

pre.prettyprint {
  margin-bottom: 20px; }

pre code {
  padding: 0;
  color: inherit;
  white-space: pre;
  overflow-x: visible;
  background-color: transparent;
  border: 0; }

.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll; }

table {
  max-width: 100%;
  background-color: transparent;
  border-collapse: collapse;
  border-spacing: 0; }

table th, table td {
  padding: 0px 8px 0px;
}

.table {
  width: 100%;
  margin-bottom: 20px; }

.table th,
.table td {
  padding: 8px;
  line-height: 20px;
  text-align: left;
  vertical-align: top;
  border-top: 1px solid #444444; }

.table th {
  font-weight: bold; }

.table thead th {
  vertical-align: bottom; }

.table caption + thead tr:first-child th,
.table caption + thead tr:first-child td,
.table colgroup + thead tr:first-child th,
.table colgroup + thead tr:first-child td,
.table thead:first-child tr:first-child th,
.table thead:first-child tr:first-child td {
  border-top: 0; }

.table tbody + tbody {
  border-top: 2px solid #444444; }

.table .table {
  background-color: rgba(252, 248, 244, 0.75); }

.table-condensed th,
.table-condensed td {
  padding: 4px 5px; }

.table-bordered {
  border: 1px solid #444444;
  border-collapse: separate;
  *border-collapse: collapse;
  border-left: 0;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px; }

.table-bordered th,
.table-bordered td {
  border-left: 1px solid #444444; }

.table-bordered caption + thead tr:first-child th,
.table-bordered caption + tbody tr:first-child th,
.table-bordered caption + tbody tr:first-child td,
.table-bordered colgroup + thead tr:first-child th,
.table-bordered colgroup + tbody tr:first-child th,
.table-bordered colgroup + tbody tr:first-child td,
.table-bordered thead:first-child tr:first-child th,
.table-bordered tbody:first-child tr:first-child th,
.table-bordered tbody:first-child tr:first-child td {
  border-top: 0; }

.table-bordered thead:first-child tr:first-child > th:first-child,
.table-bordered tbody:first-child tr:first-child > td:first-child,
.table-bordered tbody:first-child tr:first-child > th:first-child {
  -webkit-border-top-left-radius: 4px;
  border-top-left-radius: 4px;
  -moz-border-radius-topleft: 4px; }

.table-bordered thead:first-child tr:first-child > th:last-child,
.table-bordered tbody:first-child tr:first-child > td:last-child,
.table-bordered tbody:first-child tr:first-child > th:last-child {
  -webkit-border-top-right-radius: 4px;
  border-top-right-radius: 4px;
  -moz-border-radius-topright: 4px; }

.table-bordered thead:last-child tr:last-child > th:first-child,
.table-bordered tbody:last-child tr:last-child > td:first-child,
.table-bordered tbody:last-child tr:last-child > th:first-child,
.table-bordered tfoot:last-child tr:last-child > td:first-child,
.table-bordered tfoot:last-child tr:last-child > th:first-child {
  -webkit-border-bottom-left-radius: 4px;
  border-bottom-left-radius: 4px;
  -moz-border-radius-bottomleft: 4px; }

.table-bordered thead:last-child tr:last-child > th:last-child,
.table-bordered tbody:last-child tr:last-child > td:last-child,
.table-bordered tbody:last-child tr:last-child > th:last-child,
.table-bordered tfoot:last-child tr:last-child > td:last-child,
.table-bordered tfoot:last-child tr:last-child > th:last-child {
  -webkit-border-bottom-right-radius: 4px;
  border-bottom-right-radius: 4px;
  -moz-border-radius-bottomright: 4px; }

.table-bordered tfoot + tbody:last-child tr:last-child td:first-child {
  -webkit-border-bottom-left-radius: 0;
  border-bottom-left-radius: 0;
  -moz-border-radius-bottomleft: 0; }

.table-bordered tfoot + tbody:last-child tr:last-child td:last-child {
  -webkit-border-bottom-right-radius: 0;
  border-bottom-right-radius: 0;
  -moz-border-radius-bottomright: 0; }

.table-bordered caption + thead tr:first-child th:first-child,
.table-bordered caption + tbody tr:first-child td:first-child,
.table-bordered colgroup + thead tr:first-child th:first-child,
.table-bordered colgroup + tbody tr:first-child td:first-child {
  -webkit-border-top-left-radius: 4px;
  border-top-left-radius: 4px;
  -moz-border-radius-topleft: 4px; }

.table-bordered caption + thead tr:first-child th:last-child,
.table-bordered caption + tbody tr:first-child td:last-child,
.table-bordered colgroup + thead tr:first-child th:last-child,
.table-bordered colgroup + tbody tr:first-child td:last-child {
  -webkit-border-top-right-radius: 4px;
  border-top-right-radius: 4px;
  -moz-border-radius-topright: 4px; }

table.docutils th {
  background-color: #e8e8e8; }

table.docutils tr:hover {
  background-color: whitesmoke; }

.table-striped tbody > tr:nth-child(odd) > td,
.table-striped tbody > tr:nth-child(odd) > th {
  background-color: rgba(252, 248, 244, 0.75); }

.table-hover tbody tr:hover > td,
.table-hover tbody tr:hover > th {
  background-color: rgba(241, 222, 204, 0.75); }

table td[class*="span"],
table th[class*="span"],
.row-fluid table td[class*="span"],
.row-fluid table th[class*="span"] {
  display: table-cell;
  float: none;
  margin-left: 0; }

.hero-unit {
  padding: 60px;
  margin-bottom: 30px;
  font-size: 18px;
  font-weight: 200;
  line-height: 30px;
  color: inherit;
  background-color: rgba(230, 197, 164, 0.75);
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.hero-unit h1 {
  margin-bottom: 0;
  font-size: 60px;
  line-height: 1;
  letter-spacing: -1px;
  color: inherit; }

.hero-unit li {
  line-height: 30px; }

/* rst2html default used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0; }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 !important; }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 !important; }

.last, .with-subtitle {
  margin-bottom: 0 !important; }

.hidden {
  display: none; }

a.toc-backref {
  text-decoration: none;
  color: #444444; }

blockquote.epigraph {
  margin: 2em 5em; }

dl.docutils dd {
  margin-bottom: 0.5em; }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden; }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/
div.abstract {
  margin: 2em 5em; }

div.abstract p.topic-title {
  font-weight: bold;
  text-align: center; }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em;
  border: medium outset;
  padding: 1em; }

div.note, div.warning {
  margin: 1.5em 0px;
  border: none; }

div.note p.admonition-title,
div.warning p.admonition-title {
  display: none; }

/* Clearfix
 * http://css-tricks.com/snippets/css/clear-fix/
 */
div.note:after,
div.warning:after {
  content: "";
  display: table;
  clear: both; }

div.note p:before,
div.warning p:before {
  display: block;
  float: left;
  font-size: 4em;
  line-height: 1em;
  margin-right: 20px;
  margin-left: 0em;
  margin-top: -10px;
  content: '\0270D';
  /*handwriting*/ }

div.warning p:before {
  content: '\026A0';
  /*warning*/ }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold;
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: #b30000;
  font-weight: bold;
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/
div.dedication {
  margin: 2em 5em;
  text-align: center;
  font-style: italic; }

div.dedication p.topic-title {
  font-weight: bold;
  font-style: normal; }

div.figure {
  margin-left: 2em;
  margin-right: 2em; }

div.footer, div.header {
  clear: both;
  font-size: smaller; }

div.line-block {
  display: block;
  margin-top: 1em;
  margin-bottom: 1em; }

div.line-block div.line-block {
  margin-top: 0;
  margin-bottom: 0;
  margin-left: 1.5em; }

div.sidebar {
  margin: 0 0 0.5em 1em;
  border: medium outset;
  padding: 1em;
  background-color: rgba(252, 248, 244, 0.75);
  width: 40%;
  float: right;
  clear: right; }

div.sidebar p.rubric {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-size: medium; }

div.system-messages {
  margin: 5em; }

div.system-messages h1 {
  color: #b30000; }

div.system-message {
  border: medium outset;
  padding: 1em; }

div.system-message p.system-message-title {
  color: #b30000;
  font-weight: bold; }

div.topic {
  margin: 2em; }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em; }

h1.title {
  text-align: center; }

h2.subtitle {
  text-align: center; }

hr.docutils {
  width: 75%; }

img.align-left, .figure.align-left, object.align-left {
  clear: left;
  float: left;
  margin-right: 1em; }

img.align-right, .figure.align-right, object.align-right {
  clear: right;
  float: right;
  margin-left: 1em; }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto; }

.align-left {
  text-align: left; }

.align-center {
  clear: both;
  text-align: center; }

.align-right {
  text-align: right; }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit; }

/* div.align-center * { */
/*   text-align: left } */
ol.simple, ul.simple {
  margin-bottom: 1em; }

ol.arabic {
  list-style: decimal; }

ol.loweralpha {
  list-style: lower-alpha; }

ol.upperalpha {
  list-style: upper-alpha; }

ol.lowerroman {
  list-style: lower-roman; }

ol.upperroman {
  list-style: upper-roman; }

p.attribution {
  text-align: right;
  margin-left: 50%; }

p.caption {
  font-style: italic; }

p.credits {
  font-style: italic;
  font-size: smaller; }

p.label {
  white-space: nowrap; }

p.rubric {
  font-weight: bold;
  font-size: larger;
  color: maroon;
  text-align: center; }

p.sidebar-title {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold;
  font-size: larger; }

p.sidebar-subtitle {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold; }

p.topic-title {
  font-weight: bold; }

pre.address {
  margin-bottom: 0;
  margin-top: 0;
  font: inherit; }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em;
  margin-right: 2em; }

pre.code .ln {
  color: grey; }

/* line numbers */
pre.code, code {
  background-color: #eeeeee; }

pre.code .comment, code .comment {
  color: #5c6576; }

pre.code .keyword, code .keyword {
  color: #3B0D06;
  font-weight: bold; }

pre.code .literal.string, code .literal.string {
  color: #0c5404; }

pre.code .name.builtin, code .name.builtin {
  color: #352b84; }

pre.code .deleted, code .deleted {
  background-color: #DEB0A1; }

pre.code .inserted, code .inserted {
  background-color: #A3D289; }

span.classifier {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-style: oblique; }

span.classifier-delimiter {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold; }

span.interpreted {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

span.option {
  white-space: nowrap; }

span.pre {
  white-space: pre; }

span.problematic {
  color: #b30000; }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80%; }

table.citation {
  border-left: solid 1px #666666;
  margin-left: 1px; }

table.docinfo {
  margin: 0em;
  margin-top: 2em;
  margin-bottom: 2em;
  font-family: "Raleway", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif !important;
  color: #444444; }

table.docutils {
  margin-top: 0.5em;
  margin-bottom: 0.5em; }

table.footnote {
  border-left: solid 1px #2d2d2d;
  margin-left: 1px; }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em;
  padding-right: 0.5em;
  vertical-align: top; }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: 700;
  text-align: left;
  white-space: nowrap;
  padding-left: 0; }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100%; }

ul.auto-toc {
  list-style-type: none; }

span.DecNumber {
  color: #252dbe; }

span.BinNumber {
  color: #252dbe; }

span.HexNumber {
  color: #252dbe; }

span.OctNumber {
  color: #252dbe; }

span.FloatNumber {
  color: #252dbe; }

span.Identifier {
  color: #3b3b3b; }

span.Keyword {
  font-weight: 600;
  color: #5e8f60; }

span.StringLit {
  color: #a4255b; }

span.LongStringLit {
  color: #a4255b; }

span.CharLit {
  color: #a4255b; }

span.EscapeSequence {
  color: black; }

span.Operator {
  color: black; }

span.Punctuation {
  color: black; }

span.Comment, span.LongComment {
  font-style: italic;
  font-weight: 400;
  color: #484a86; }

span.RegularExpression {
  color: darkviolet; }

span.TagStart {
  color: darkviolet; }

span.TagEnd {
  color: darkviolet; }

span.Key {
  color: #252dbe; }

span.Value {
  color: #252dbe; }

span.RawData {
  color: #a4255b; }

span.Assembler {
  color: #252dbe; }

span.Preprocessor {
  color: #252dbe; }

span.Directive {
  color: #252dbe; }

span.Command, span.Rule, span.Hyperlink, span.Label, span.Reference,
span.Other {
  color: black; }

/* Pop type, const, proc, and iterator defs in nim def blocks */
dt pre > span.Identifier, dt pre > span.Operator {
  color: #155da4;
  font-weight: 700; }

dt pre > span.Identifier ~ span.Identifier, dt pre > span.Operator ~ span.Identifier {
  color: inherit;
  font-weight: inherit; }

dt pre > span.Operator ~ span.Identifier, dt pre > span.Operator ~ span.Operator {
  color: inherit;
  font-weight: inherit; }

/* Nim sprite for the footer (taken from main page favicon) */
.nim-sprite {
  display: inline-block;
  height: 12px;
  width: 12px;
  background-position: 0 0;
  background-size: 12px 12px;
  -webkit-filter: opacity(50%);
  background-repeat: no-repeat;
  background-image: url("data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA==");
  margin-bottom: -5px; }
</style>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Nim 语言教程 (第二部分)</h1>
    <div class="row">
  <div class="three columns">
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="_toc" href="#">介绍</a></li>
<li><a class="reference" id="_toc" href="#">编译注记</a></li>
<li><a class="reference" id="_toc" href="#">面向对象编程</a></li>
<ul class="simple"><li><a class="reference" id="objects_toc" href="#objects">Objects</a></li>
<li><a class="reference" id="_toc" href="#">互递归类型</a></li>
<li><a class="reference" id="type-conversions_toc" href="#type-conversions">Type conversions</a></li>
<li><a class="reference" id="object-variants_toc" href="#object-variants">Object variants</a></li>
<li><a class="reference" id="methods_toc" href="#methods">Methods</a></li>
<li><a class="reference" id="method-call-syntax_toc" href="#method-call-syntax">Method call syntax</a></li>
<li><a class="reference" id="properties_toc" href="#properties">Properties</a></li>
<li><a class="reference" id="dynamic-dispatch_toc" href="#dynamic-dispatch">Dynamic dispatch</a></li>
</ul><li><a class="reference" id="exceptions_toc" href="#exceptions">Exceptions</a></li>
<ul class="simple"><li><a class="reference" id="raise-statement_toc" href="#raise-statement">Raise statement</a></li>
<li><a class="reference" id="try-statement_toc" href="#try-statement">Try statement</a></li>
<li><a class="reference" id="annotating-procs-with-raised-exceptions_toc" href="#annotating-procs-with-raised-exceptions">Annotating procs with raised exceptions</a></li>
</ul><li><a class="reference" id="generics_toc" href="#generics">Generics</a></li>
<li><a class="reference" id="templates_toc" href="#templates">Templates</a></li>
<li><a class="reference" id="macros_toc" href="#macros">Macros</a></li>
<ul class="simple"><li><a class="reference" id="expression-macros_toc" href="#expression-macros">Expression Macros</a></li>
<li><a class="reference" id="statement-macros_toc" href="#statement-macros">Statement Macros</a></li>
<li><a class="reference" id="building-your-first-macro_toc" href="#building-your-first-macro">Building your first macro</a></li>
<ul class="simple"><li><a class="reference" id="generating-source-code_toc" href="#generating-source-code">Generating source code</a></li>
<li><a class="reference" id="generating-ast-by-hand_toc" href="#generating-ast-by-hand">Generating AST by hand</a></li>
</ul></ul>
</ul>

  </div>
  <div class="nine columns" id="content">
  <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">作者:</th><td> Andreas Rumpf</td></tr>
<tr><th class="docinfo-name">版本:</th><td> |nimversion|</td></tr>
</tbody></table>
<h1><a class="toc-backref" id="" href="#">介绍</a></h1><blockquote><p>&quot;Repetition renders the ridiculous reasonable.&quot; -- Norman Wildberger</p></blockquote>
<p>这篇文档是 <em>Nim</em> 编程语言高级部分的教程。**注意这篇文档可能已经过时** <a class="reference external" href="manual.html">manual</a> <strong>中包含有更多关于语言高级特性的示例。</strong></p>

<h1><a class="toc-backref" id="" href="#">编译注记</a></h1><p>编译注记是 Nim 用于告知编译器附加信息/命令的方法，以免定义一堆新关键字。 编译注记包含于特殊的 <tt class="docutils literal"><span class="pre">{.</span></tt> 和 <tt class="docutils literal"><span class="pre">.}</span></tt> 花括号点对之中。本教程没有介绍编译 注记的具体内容，了解可用的编译注记可从 <a class="reference external" href="manual.html#pragmas">manual</a> 或 <a class="reference external" href="nimc.html#additional-features">user guide</a> 中获取。</p>

<h1><a class="toc-backref" id="" href="#">面向对象编程</a></h1><p>Nim 的面向对象(OOP)支持简约而优雅，你可以自由地使用强大的 OOP 技术。显然 OOP 是*一种*程序设计的方式，但这方式并不*唯一*。通常，使用过程式的编程方式编写的 代码更加有效。特别地，组合通常比继承更佳。</p>

<h2><a class="toc-backref" id="objects" href="#objects">Objects</a></h2><p>和 tuples 一样，objects 是一种把不同的值用结构的方式打包在一起的方法。但 objects 提供了很多 tuples 没有的特性，如：继承与信息隐藏。因为 objects 包装了数据，对象 构造器 <tt class="docutils literal"><span class="pre">T()</span></tt> 只能在内部使用，程序员应该提供一个初始化对象的 proc (称做*构造器*)。</p>
<p>可以在运行时访问 Objects 的类型。``of`` 运算符能用于检查 object 的类型：</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">name</span><span class="Operator">*:</span> <span class="Identifier">string</span>  <span class="Comment"># * 表示 `name` 可以从其他模块访问</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>       <span class="Comment"># 没有 * 意味着这个字段对其他模块而言是不可见的</span>
  
  <span class="Identifier">Student</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Person</span> <span class="Comment"># Student 继承自 Person</span>
    <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="Identifier">int</span>                  <span class="Comment"># 另有一个 id 字段</span>

<span class="Keyword">var</span>
  <span class="Identifier">student</span><span class="Punctuation">:</span> <span class="Identifier">Student</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">student</span> <span class="Keyword">of</span> <span class="Identifier">Student</span><span class="Punctuation">)</span> <span class="Comment"># is true</span>
<span class="Comment"># 对象构造:</span>
<span class="Identifier">student</span> <span class="Operator">=</span> <span class="Identifier">Student</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Anton&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="DecNumber">2</span><span class="Punctuation">)</span></pre><p>Object 中的字段若希望在本模块之外的地方使用，则必须用 <tt class="docutils literal"><span class="pre">*</span></tt> 标记。不同于 tuples， 不同的 object 绝不*相等*。新的 object 类型只能在 type 块内定义。</p>
<p>继承用 <tt class="docutils literal"><span class="pre">object of</span></tt> 的语法实现，多重继承尚未支持。如果类型没有合适的基类(ancestor)， 可以使用 <tt class="docutils literal"><span class="pre">RootObj</span></tt> 作为其基类，但这只是一个惯例。没有指定基类的 Objects 会被隐式 指定为 <tt class="docutils literal"><span class="pre">final</span></tt> 的，你可以用 <tt class="docutils literal"><span class="pre">inheritable</span></tt> 编译注记来指定一个新的对象基类(roots)， 而不是 <tt class="docutils literal"><span class="pre">system.RootObj</span></tt> 。(如GTK的包装器)。</p>
<p><strong>注意</strong>: 对于代码重用，组合 (<em>has-a</em> 关系) 通常比继承 (<em>is-a</em> 关系) 更好，Nim 中的 objects 是值类型，因而组合与继承的效率相当。</p>

<h2><a class="toc-backref" id="" href="#">互递归类型</a></h2><p>Objects, tuples 及引用(references)可以塑造出相互依赖的相当复杂的数据结构。称作 <em>互递归</em> 。 在 Nim 中，这些类型只能在单个 type 块中声明。(不在此 type 块中的其它任何的符号,需要回溯 搜索会导致降低编译速度。)</p>
<p>例:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span> <span class="Comment"># 建立了一个对 NodeObj 的跟踪引用</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>     <span class="Comment"># 左右子树</span>
    <span class="Identifier">sym</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Sym</span>     <span class="Comment"># 叶子包含了对 Sym 的引用</span>
  
  <span class="Identifier">Sym</span> <span class="Operator">=</span> <span class="Keyword">object</span>       <span class="Comment"># 符号</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>     <span class="Comment"># 符号的名字</span>
    <span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">int</span>        <span class="Comment"># 符号声明所在的行</span>
    <span class="Identifier">code</span><span class="Punctuation">:</span> <span class="Identifier">PNode</span>      <span class="Comment"># 符号的抽象语法树</span></pre>
<h2><a class="toc-backref" id="type-conversions" href="#type-conversions">Type conversions</a></h2><p>Nim distinguishes between <span id="type-casts_1">type casts</span> and <span id="type-conversions_1">type conversions</span>. Casts are done with the <tt class="docutils literal"><span class="pre">cast</span></tt> operator and force the compiler to interpret a bit pattern to be of another type.</p>
<p>Type conversions are a much more polite way to convert a type into another: They preserve the abstract <em>value</em>, not necessarily the <em>bit-pattern</em>. If a type conversion is not possible, the compiler complains or an exception is raised.</p>
<p>The syntax for type conversions is <tt class="docutils literal"><span class="pre">destination_type(expression_to_convert)</span></tt> (like an ordinary call):</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">getID</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Person</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">Student</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">id</span></pre><p>The <tt class="docutils literal"><span class="pre">InvalidObjectConversionError</span></tt> exception is raised if <tt class="docutils literal"><span class="pre">x</span></tt> is not a <tt class="docutils literal"><span class="pre">Student</span></tt>.</p>

<h2><a class="toc-backref" id="object-variants" href="#object-variants">Object variants</a></h2><p>Often an object hierarchy is overkill in certain situations where simple variant types are needed.</p>
<p>An example:</p>
<pre><span class="Comment"># This is an example how an abstract syntax tree could be modelled in Nim</span>
<span class="Keyword">type</span>
  <span class="Identifier">NodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span>  <span class="Comment"># the different node types</span>
    <span class="Identifier">nkInt</span><span class="Punctuation">,</span>          <span class="Comment"># a leaf with an integer value</span>
    <span class="Identifier">nkFloat</span><span class="Punctuation">,</span>        <span class="Comment"># a leaf with a float value</span>
    <span class="Identifier">nkString</span><span class="Punctuation">,</span>       <span class="Comment"># a leaf with a string value</span>
    <span class="Identifier">nkAdd</span><span class="Punctuation">,</span>          <span class="Comment"># an addition</span>
    <span class="Identifier">nkSub</span><span class="Punctuation">,</span>          <span class="Comment"># a subtraction</span>
    <span class="Identifier">nkIf</span>            <span class="Comment"># an if statement</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">NodeKind</span>  <span class="Comment"># the ``kind`` field is the discriminator</span>
    <span class="Keyword">of</span> <span class="Identifier">nkInt</span><span class="Punctuation">:</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Keyword">of</span> <span class="Identifier">nkFloat</span><span class="Punctuation">:</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="Identifier">float</span>
    <span class="Keyword">of</span> <span class="Identifier">nkString</span><span class="Punctuation">:</span> <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">nkSub</span><span class="Punctuation">:</span>
      <span class="Identifier">leftOp</span><span class="Punctuation">,</span> <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">PNode</span>
    <span class="Keyword">of</span> <span class="Identifier">nkIf</span><span class="Punctuation">:</span>
      <span class="Identifier">condition</span><span class="Punctuation">,</span> <span class="Identifier">thenPart</span><span class="Punctuation">,</span> <span class="Identifier">elsePart</span><span class="Punctuation">:</span> <span class="Identifier">PNode</span>

<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">PNode</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkFloat</span><span class="Punctuation">,</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="FloatNumber">1.0</span><span class="Punctuation">)</span>
<span class="Comment"># the following statement raises an `FieldError` exception, because</span>
<span class="Comment"># n.kind's value does not fit:</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">strVal</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span></pre><p>As can been seen from the example, an advantage to an object hierarchy is that no conversion between different object types is needed. Yet, access to invalid object fields raises an exception.</p>

<h2><a class="toc-backref" id="methods" href="#methods">Methods</a></h2><p>In ordinary object oriented languages, procedures (also called <em>methods</em>) are bound to a class. This has disadvantages:</p>
<ul class="simple"><li>Adding a method to a class the programmer has no control over is impossible or needs ugly workarounds.</li>
<li>Often it is unclear where the method should belong to: is <tt class="docutils literal"><span class="pre">join</span></tt> a string method or an array method?</li>
</ul>
<p>Nim avoids these problems by not assigning methods to a class. All methods in Nim are multi-methods. As we will see later, multi-methods are distinguished from procs only for dynamic binding purposes.</p>

<h2><a class="toc-backref" id="method-call-syntax" href="#method-call-syntax">Method call syntax</a></h2><p>There is a syntactic sugar for calling routines: The syntax <tt class="docutils literal"><span class="pre">obj.method(args)</span></tt> can be used instead of <tt class="docutils literal"><span class="pre">method(obj, args)</span></tt>. If there are no remaining arguments, the parentheses can be omitted: <tt class="docutils literal"><span class="pre">obj.len</span></tt> (instead of <tt class="docutils literal"><span class="pre">len(obj)</span></tt>).</p>
<p>This method call syntax is not restricted to objects, it can be used for any type:</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span> <span class="Comment"># is the same as echo(len(&quot;abc&quot;))</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">toUpper</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">,</span> <span class="CharLit">'c'</span><span class="Punctuation">}</span><span class="Operator">.</span><span class="Identifier">card</span><span class="Punctuation">)</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hallo&quot;</span><span class="Punctuation">)</span> <span class="Comment"># the same as writeln(stdout, &quot;Hallo&quot;)</span></pre><p>(Another way to look at the method call syntax is that it provides the missing postfix notation.)</p>
<p>So &quot;pure object oriented&quot; code is easy to write:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">strutils</span>

<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;Give a list of numbers (separated by spaces): &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Operator">.</span><span class="Identifier">readLine</span><span class="Operator">.</span><span class="Identifier">split</span><span class="Operator">.</span><span class="Identifier">map</span><span class="Punctuation">(</span><span class="Identifier">parseInt</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">max</span><span class="Operator">.</span><span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">)</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot; is the maximum!&quot;</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="properties" href="#properties">Properties</a></h2><p>As the above example shows, Nim has no need for <em>get-properties</em>: Ordinary get-procedures that are called with the <em>method call syntax</em> achieve the same. But setting a value is different; for this a special setter syntax is needed:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Socket</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">FHost</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># cannot be accessed from the outside of the module</span>
               <span class="Comment"># the `F` prefix is a convention to avoid clashes since</span>
               <span class="Comment"># the accessors are named `host`</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Identifier">host</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Socket</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## setter of hostAddr</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">FHost</span> <span class="Operator">=</span> <span class="Identifier">value</span>

<span class="Keyword">proc</span> <span class="Identifier">host</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## getter of hostAddr</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">FHost</span>

<span class="Keyword">var</span>
  <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span>
<span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">host</span> <span class="Operator">=</span> <span class="DecNumber">34</span>  <span class="Comment"># same as `host=`(s, 34)</span></pre><p>(The example also shows <tt class="docutils literal"><span class="pre">inline</span></tt> procedures.)</p>
<p>The <tt class="docutils literal"><span class="pre">[]</span></tt> array access operator can be overloaded to provide <span id="array-properties_1">array properties</span>:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Vector</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">float</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Vector</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">float</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># setter</span>
  <span class="Keyword">case</span> <span class="Identifier">i</span>
  <span class="Keyword">of</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">value</span>
  <span class="Keyword">of</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">value</span>
  <span class="Keyword">of</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">value</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">false</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">Vector</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span>
  <span class="Comment"># getter</span>
  <span class="Keyword">case</span> <span class="Identifier">i</span>
  <span class="Keyword">of</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">x</span>
  <span class="Keyword">of</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">y</span>
  <span class="Keyword">of</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">z</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">false</span><span class="Punctuation">)</span></pre><p>The example is silly, since a vector is better modelled by a tuple which already provides <tt class="docutils literal"><span class="pre">v[]</span></tt> access.</p>

<h2><a class="toc-backref" id="dynamic-dispatch" href="#dynamic-dispatch">Dynamic dispatch</a></h2><p>Procedures always use static dispatch. For dynamic dispatch replace the <tt class="docutils literal"><span class="pre">proc</span></tt> keyword by <tt class="docutils literal"><span class="pre">method</span></tt>:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">PExpr</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span> <span class="Comment">## abstract base class for an expression</span>
  <span class="Identifier">PLiteral</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">PExpr</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">PPlusExpr</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">PExpr</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PExpr</span>

<span class="Comment"># watch out: 'eval' relies on dynamic binding</span>
<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">PExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># override this base method</span>
  <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">PLiteral</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">x</span>
<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">PPlusExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PLiteral</span> <span class="Operator">=</span> <span class="Identifier">PLiteral</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">x</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PPlusExpr</span> <span class="Operator">=</span> <span class="Identifier">PPlusExpr</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>Note that in the example the constructors <tt class="docutils literal"><span class="pre">newLit</span></tt> and <tt class="docutils literal"><span class="pre">newPlus</span></tt> are procs because it makes more sense for them to use static binding, but <tt class="docutils literal"><span class="pre">eval</span></tt> is a method because it requires dynamic binding.</p>
<p>In a multi-method all parameters that have an object type are used for the dispatching:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Thing</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
  <span class="Identifier">Unit</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Thing</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;1&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;2&quot;</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span>
<span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Comment"># output: 2</span></pre><p>As the example demonstrates, invocation of a multi-method cannot be ambiguous: Collide 2 is preferred over collide 1 because the resolution works from left to right. Thus <tt class="docutils literal"><span class="pre">Unit, Thing</span></tt> is preferred over <tt class="docutils literal"><span class="pre">Thing, Unit</span></tt>.</p>
<p><strong>Performance note</strong>: Nim does not produce a virtual method table, but generates dispatch trees. This avoids the expensive indirect branch for method calls and enables inlining. However, other optimizations like compile time evaluation or dead code elimination do not work with methods.</p>

<h1><a class="toc-backref" id="exceptions" href="#exceptions">Exceptions</a></h1><p>In Nim exceptions are objects. By convention, exception types are suffixed with 'Error'. The <a class="reference external" href="system.html">system</a> module defines an exception hierarchy that you might want to stick to. Exceptions derive from <tt class="docutils literal"><span class="pre">system.Exception</span></tt>, which provides the common interface.</p>
<p>Exceptions have to be allocated on the heap because their lifetime is unknown. The compiler will prevent you from raising an exception created on the stack. All raised exceptions should at least specify the reason for being raised in the <tt class="docutils literal"><span class="pre">msg</span></tt> field.</p>
<p>A convention is that exceptions should be raised in <em>exceptional</em> cases: For example, if a file cannot be opened, this should not raise an exception since this is quite common (the file may not exist).</p>

<h2><a class="toc-backref" id="raise-statement" href="#raise-statement">Raise statement</a></h2><p>Raising an exception is done with the <tt class="docutils literal"><span class="pre">raise</span></tt> statement:</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">OSError</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">)</span>
<span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">msg</span> <span class="Operator">=</span> <span class="StringLit">&quot;the request to the OS failed&quot;</span>
<span class="Keyword">raise</span> <span class="Identifier">e</span></pre><p>If the <tt class="docutils literal"><span class="pre">raise</span></tt> keyword is not followed by an expression, the last exception is <em>re-raised</em>. For the purpose of avoiding repeating this common code pattern, the template <tt class="docutils literal"><span class="pre">newException</span></tt> in the <tt class="docutils literal"><span class="pre">system</span></tt> module can be used:</p>
<pre><span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;the request to the OS failed&quot;</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="try-statement" href="#try-statement">Try statement</a></h2><p>The <tt class="docutils literal"><span class="pre">try</span></tt> statement handles exceptions:</p>
<pre><span class="Comment"># read the first two lines of a text file that should contain numbers</span>
<span class="Comment"># and tries to add them</span>
<span class="Keyword">var</span>
  <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
<span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Keyword">let</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;sum: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">OverflowError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;overflow!&quot;</span>
  <span class="Keyword">except</span> <span class="Identifier">ValueError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;could not convert string to integer&quot;</span>
  <span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;IO error!&quot;</span>
  <span class="Keyword">except</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;Unknown exception!&quot;</span>
    <span class="Comment"># reraise the unknown exception:</span>
    <span class="Keyword">raise</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span>
    <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span></pre><p>The statements after the <tt class="docutils literal"><span class="pre">try</span></tt> are executed unless an exception is raised. Then the appropriate <tt class="docutils literal"><span class="pre">except</span></tt> part is executed.</p>
<p>The empty <tt class="docutils literal"><span class="pre">except</span></tt> part is executed if there is an exception that is not explicitly listed. It is similar to an <tt class="docutils literal"><span class="pre">else</span></tt> part in <tt class="docutils literal"><span class="pre">if</span></tt> statements.</p>
<p>If there is a <tt class="docutils literal"><span class="pre">finally</span></tt> part, it is always executed after the exception handlers.</p>
<p>The exception is <em>consumed</em> in an <tt class="docutils literal"><span class="pre">except</span></tt> part. If an exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a <tt class="docutils literal"><span class="pre">finally</span></tt> clause - is not executed (if an exception occurs).</p>
<p>If you need to <em>access</em> the actual exception object or message inside an <tt class="docutils literal"><span class="pre">except</span></tt> branch you can use the <a class="reference external" href="system.html#getCurrentException">getCurrentException()</a> and <a class="reference external" href="system.html#getCurrentExceptionMsg">getCurrentExceptionMsg()</a> procs from the <a class="reference external" href="system.html">system</a> module. Example:</p>
<pre><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Identifier">doSomethingHere</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">except</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span>
    <span class="Identifier">e</span> <span class="Operator">=</span> <span class="Identifier">getCurrentException</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Identifier">msg</span> <span class="Operator">=</span> <span class="Identifier">getCurrentExceptionMsg</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Got exception &quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="StringLit">&quot; with message &quot;</span><span class="Punctuation">,</span> <span class="Identifier">msg</span></pre>
<h2><a class="toc-backref" id="annotating-procs-with-raised-exceptions" href="#annotating-procs-with-raised-exceptions">Annotating procs with raised exceptions</a></h2><p>Through the use of the optional <tt class="docutils literal"><span class="pre">{.raises.}</span></tt> pragma you can specify that a proc is meant to raise a specific set of exceptions, or none at all. If the <tt class="docutils literal"><span class="pre">{.raises.}</span></tt> pragma is used, the compiler will verify that this is true. For instance, if you specify that a proc raises <tt class="docutils literal"><span class="pre">IOError</span></tt>, and at some point it (or one of the procs it calls) starts raising a new exception the compiler will prevent that proc from compiling. Usage example:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">complexProc</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="Identifier">ArithmeticError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Identifier">simpleProc</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Operator">...</span></pre><p>Once you have code like this in place, if the list of raised exception changes the compiler will stop with an error specifying the line of the proc which stopped validating the pragma and the raised exception not being caught, along with the file and line where the uncaught exception is being raised, which may help you locate the offending code which has changed.</p>
<p>If you want to add the <tt class="docutils literal"><span class="pre">{.raises.}</span></tt> pragma to existing code, the compiler can also help you. You can add the <tt class="docutils literal"><span class="pre">{.effects.}</span></tt> pragma statement to your proc and the compiler will output all inferred effects up to that point (exception tracking is part of Nim's effect system). Another more roundabout way to find out the list of exceptions raised by a proc is to use the Nim <tt class="docutils literal"><span class="pre">doc2</span></tt> command which generates documentation for a whole module and decorates all procs with the list of raised exceptions. You can read more about Nim's <a class="reference external" href="manual.html#effect-system">effect system and related pragmas in the manual</a>.</p>

<h1><a class="toc-backref" id="generics" href="#generics">Generics</a></h1><p>Generics are Nim's means to parametrize procs, iterators or types with <span id="type-parameters_1">type parameters</span>. They are most useful for efficient type safe containers:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">BinaryTreeObj</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Comment"># BinaryTree is a generic type with</span>
                            <span class="Comment"># with generic param ``T``</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span>   <span class="Comment"># left and right subtrees; may be nil</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span>                 <span class="Comment"># the data stored in a node</span>
  <span class="Identifier">BinaryTree</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">BinaryTreeObj</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Comment"># type that is exported</span>

<span class="Keyword">proc</span> <span class="Identifier">newNode</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Comment"># constructor for a node</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="Identifier">data</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># insert a node into the tree</span>
  <span class="Keyword">if</span> <span class="Identifier">root</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Identifier">root</span> <span class="Operator">=</span> <span class="Identifier">n</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">root</span>
    <span class="Keyword">while</span> <span class="Identifier">it</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Comment"># compare the data items; uses the generic ``cmp`` proc</span>
      <span class="Comment"># that works for any type that has a ``==`` and ``&lt;`` operator</span>
      <span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span>
      <span class="Keyword">if</span> <span class="Identifier">c</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span>
      <span class="Keyword">else</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># convenience proc:</span>
  <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">iterator</span> <span class="Identifier">preorder</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Comment"># Preorder traversal of a binary tree.</span>
  <span class="Comment"># Since recursive iterators are not yet implemented,</span>
  <span class="Comment"># this uses an explicit stack (which is more efficient anyway):</span>
  <span class="Keyword">var</span> <span class="Identifier">stack</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="Identifier">root</span><span class="Punctuation">]</span>
  <span class="Keyword">while</span> <span class="Identifier">stack</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&gt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">stack</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Keyword">while</span> <span class="Identifier">n</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Keyword">yield</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span>
      <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">stack</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">ri</span><span class="Punctuation">)</span>  <span class="Comment"># push right subtree onto the stack</span>
      <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">le</span>          <span class="Comment"># and follow the left pointer</span>

<span class="Keyword">var</span>
  <span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Comment"># instantiate a BinaryTree with ``string``</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;hello&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># instantiates ``newNode`` and ``add``</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="StringLit">&quot;world&quot;</span><span class="Punctuation">)</span>          <span class="Comment"># instantiates the second ``add`` proc</span>
<span class="Keyword">for</span> <span class="Identifier">str</span> <span class="Keyword">in</span> <span class="Identifier">preorder</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">str</span><span class="Punctuation">)</span></pre><p>The example shows a generic binary tree. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type. As the example shows, generics work with overloading: the best match of <tt class="docutils literal"><span class="pre">add</span></tt> is used. The built-in <tt class="docutils literal"><span class="pre">add</span></tt> procedure for sequences is not hidden and is used in the <tt class="docutils literal"><span class="pre">preorder</span></tt> iterator.</p>

<h1><a class="toc-backref" id="templates" href="#templates">Templates</a></h1><p>Templates are a simple substitution mechanism that operates on Nim's abstract syntax trees. Templates are processed in the semantic pass of the compiler. They integrate well with the rest of the language and share none of C's preprocessor macros flaws.</p>
<p>To <em>invoke</em> a template, call it like a procedure.</p>
<p>Example:</p>
<pre><span class="Keyword">template</span> <span class="Punctuation">`</span><span class="Operator">!=</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Comment"># this definition exists in the System module</span>
  <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="DecNumber">5</span> <span class="Operator">!=</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># the compiler rewrites that to: assert(not (5 == 6))</span></pre><p>The <tt class="docutils literal"><span class="pre">!=</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;=</span></tt>, <tt class="docutils literal"><span class="pre">in</span></tt>, <tt class="docutils literal"><span class="pre">notin</span></tt>, <tt class="docutils literal"><span class="pre">isnot</span></tt> operators are in fact templates: this has the benefit that if you overload the <tt class="docutils literal"><span class="pre">==</span></tt> operator, the <tt class="docutils literal"><span class="pre">!=</span></tt> operator is available automatically and does the right thing. (Except for IEEE floating point numbers - NaN breaks basic boolean logic.)</p>
<p><tt class="docutils literal"><span class="pre">a &gt; b</span></tt> is transformed into <tt class="docutils literal"><span class="pre">b &lt; a</span></tt>. <tt class="docutils literal"><span class="pre">a in b</span></tt> is transformed into <tt class="docutils literal"><span class="pre">contains(b, a)</span></tt>. <tt class="docutils literal"><span class="pre">notin</span></tt> and <tt class="docutils literal"><span class="pre">isnot</span></tt> have the obvious meanings.</p>
<p>Templates are especially useful for lazy evaluation purposes. Consider a simple proc for logging:</p>
<pre><span class="Keyword">const</span>
  <span class="Identifier">debug</span> <span class="Operator">=</span> <span class="Identifier">true</span>

<span class="Keyword">proc</span> <span class="Identifier">log</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">debug</span><span class="Punctuation">:</span> <span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">log</span><span class="Punctuation">(</span><span class="StringLit">&quot;x has the value: &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>This code has a shortcoming: if <tt class="docutils literal"><span class="pre">debug</span></tt> is set to false someday, the quite expensive <tt class="docutils literal"><span class="pre">$</span></tt> and <tt class="docutils literal"><span class="pre">&amp;</span></tt> operations are still performed! (The argument evaluation for procedures is <em>eager</em>).</p>
<p>Turning the <tt class="docutils literal"><span class="pre">log</span></tt> proc into a template solves this problem:</p>
<pre><span class="Keyword">const</span>
  <span class="Identifier">debug</span> <span class="Operator">=</span> <span class="Identifier">true</span>

<span class="Keyword">template</span> <span class="Identifier">log</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">debug</span><span class="Punctuation">:</span> <span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">log</span><span class="Punctuation">(</span><span class="StringLit">&quot;x has the value: &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>The parameters' types can be ordinary types or the meta types <tt class="docutils literal"><span class="pre">expr</span></tt> (stands for <em>expression</em>), <tt class="docutils literal"><span class="pre">stmt</span></tt> (stands for <em>statement</em>) or <tt class="docutils literal"><span class="pre">typedesc</span></tt> (stands for <em>type description</em>). If the template has no explicit return type, <tt class="docutils literal"><span class="pre">stmt</span></tt> is used for consistency with procs and methods.</p>
<p>If there is a <tt class="docutils literal"><span class="pre">stmt</span></tt> parameter it should be the last in the template declaration. The reason is that statements can be passed to a template via a special <tt class="docutils literal"><span class="pre">:</span></tt> syntax:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">,</span> <span class="Identifier">filename</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">:</span> <span class="Identifier">FileMode</span><span class="Punctuation">,</span>
                  <span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">immediate</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">fn</span> <span class="Operator">=</span> <span class="Identifier">filename</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
  <span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">body</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;cannot open: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">fn</span><span class="Punctuation">)</span>

<span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">txt</span><span class="Punctuation">,</span> <span class="StringLit">&quot;ttempl3.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 1&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 2&quot;</span><span class="Punctuation">)</span></pre><p>In the example the two <tt class="docutils literal"><span class="pre">writeln</span></tt> statements are bound to the <tt class="docutils literal"><span class="pre">body</span></tt> parameter. The <tt class="docutils literal"><span class="pre">withFile</span></tt> template contains boilerplate code and helps to avoid a common bug: to forget to close the file. Note how the <tt class="docutils literal"><span class="pre">let fn = filename</span></tt> statement ensures that <tt class="docutils literal"><span class="pre">filename</span></tt> is evaluated only once.</p>

<h1><a class="toc-backref" id="macros" href="#macros">Macros</a></h1><p>Macros enable advanced compile-time code transformations, but they cannot change Nim's syntax. However, this is no real restriction because Nim's syntax is flexible enough anyway. Macros have to be implemented in pure Nim code if the <a class="reference external" href="manual.html#foreign-function-interface">foreign function interface (FFI)</a> is not enabled in the compiler, but other than that restriction (which at some point in the future will go away) you can write any kind of Nim code and the compiler will run it at compile time.</p>
<p>There are two ways to write a macro, either <em>generating</em> Nim source code and letting the compiler parse it, or creating manually an abstract syntax tree (AST) which you feed to the compiler. In order to build the AST one needs to know how the Nim concrete syntax is converted to an abstract syntax tree (AST). The AST is documented in the <a class="reference external" href="macros.html">macros</a> module.</p>
<p>Once your macro is finished, there are two ways to invoke it:</p>
<ol class="simple"><li>invoking a macro like a procedure call (expression macros)</li>
<li>invoking a macro with the special <tt class="docutils literal"><span class="pre">macrostmt</span></tt> syntax (statement macros)</li>
</ol>

<h2><a class="toc-backref" id="expression-macros" href="#expression-macros">Expression Macros</a></h2><p>The following example implements a powerful <tt class="docutils literal"><span class="pre">debug</span></tt> command that accepts a variable number of arguments:</p>
<pre><span class="Comment"># to work with Nim syntax trees, we need an API that is defined in the</span>
<span class="Comment"># ``macros`` module:</span>
<span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">expr</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Comment"># `n` is a Nim AST that contains a list of expressions;</span>
  <span class="Comment"># this macro returns a list of statements:</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newNimNode</span><span class="Punctuation">(</span><span class="Identifier">nnkStmtList</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span>
  <span class="Comment"># iterate over any argument that is passed to this macro:</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Comment"># add a call to the statement list that writes the expression;</span>
    <span class="Comment"># `toStrLit` converts an AST to its string representation:</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;write&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">toStrLit</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Comment"># add a call to the statement list that writes &quot;: &quot;</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;write&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newStrLitNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Comment"># add a call to the statement list that writes the expressions value:</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;writeln&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>The macro call expands to:</p>
<pre><span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[0]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[1]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;x&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="statement-macros" href="#statement-macros">Statement Macros</a></h2><p>Statement macros are defined just as expression macros. However, they are invoked by an expression following a colon.</p>
<p>The following example outlines a macro that generates a lexical analyzer from regular expressions:</p>
<pre><span class="Keyword">macro</span> <span class="Identifier">case_token</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Comment"># creates a lexical analyzer from regular expressions</span>
  <span class="Comment"># ... (implementation is an exercise for the reader :-)</span>
  <span class="Keyword">discard</span>

<span class="Identifier">case_token</span><span class="Punctuation">:</span> <span class="Comment"># this colon tells the parser it is a macro statement</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;[A-Za-z_]+[A-Za-z_0-9]*&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkIdentifier</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;0-9+&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkInteger</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;[\+\-\*\?]+&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkOperator</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkUnknown</span></pre>
<h2><a class="toc-backref" id="building-your-first-macro" href="#building-your-first-macro">Building your first macro</a></h2><p>To give a footstart to writing macros we will show now how to turn your typical dynamic code into something that compiles statically. For the exercise we will use the following snippet of code as the starting point:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">strutils</span><span class="Punctuation">,</span> <span class="Identifier">tables</span>

<span class="Keyword">proc</span> <span class="Identifier">readCfgAtRuntime</span><span class="Punctuation">(</span><span class="Identifier">cfgFilename</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">let</span>
    <span class="Identifier">inputString</span> <span class="Operator">=</span> <span class="Identifier">readFile</span><span class="Punctuation">(</span><span class="Identifier">cfgFilename</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span>
    <span class="Identifier">source</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span>
  
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">initTable</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">line</span> <span class="Keyword">in</span> <span class="Identifier">inputString</span><span class="Operator">.</span><span class="Identifier">splitLines</span><span class="Punctuation">:</span>
    <span class="Comment"># Ignore empty lines</span>
    <span class="Keyword">if</span> <span class="Identifier">line</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Keyword">continue</span>
    <span class="Keyword">var</span> <span class="Identifier">chunks</span> <span class="Operator">=</span> <span class="Identifier">split</span><span class="Punctuation">(</span><span class="Identifier">line</span><span class="Punctuation">,</span> <span class="CharLit">','</span><span class="Punctuation">)</span>
    <span class="Keyword">if</span> <span class="Identifier">chunks</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">!=</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
      <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;Input needs comma split values, got: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">line</span><span class="Punctuation">)</span>
    <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">chunks</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">chunks</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span>
  
  <span class="Keyword">if</span> <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;Input file empty!&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">let</span> <span class="Identifier">info</span> <span class="Operator">=</span> <span class="Identifier">readCfgAtRuntime</span><span class="Punctuation">(</span><span class="StringLit">&quot;data.cfg&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">when</span> <span class="Identifier">isMainModule</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">info</span><span class="Punctuation">[</span><span class="StringLit">&quot;licenseOwner&quot;</span><span class="Punctuation">]</span>
  <span class="Identifier">echo</span> <span class="Identifier">info</span><span class="Punctuation">[</span><span class="StringLit">&quot;licenseKey&quot;</span><span class="Punctuation">]</span>
  <span class="Identifier">echo</span> <span class="Identifier">info</span><span class="Punctuation">[</span><span class="StringLit">&quot;version&quot;</span><span class="Punctuation">]</span></pre><p>Presumably this snippet of code could be used in a commercial software, reading a configuration file to display information about the person who bought the software. This external file would be generated by an online web shopping cart to be included along the program containing the license information:<pre>
version,1.1
licenseOwner,Hyori Lee
licenseKey,M1Tl3PjBWO2CC48m</pre>
</p>
<p>The <tt class="docutils literal"><span class="pre">readCfgAtRuntime</span></tt> proc will open the given filename and return a <tt class="docutils literal"><span class="pre">Table</span></tt> from the <a class="reference external" href="tables.html">tables module</a>. The parsing of the file is done (without much care for handling invalid data or corner cases) using the <a class="reference external" href="strutils.html#splitLines">splitLines proc from the strutils module</a>. There are many things which can fail; mind the purpose is explaining how to make this run at compile time, not how to properly implement a DRM scheme.</p>
<p>The reimplementation of this code as a compile time proc will allow us to get rid of the <tt class="docutils literal"><span class="pre">data.cfg</span></tt> file we would need to distribute along the binary, plus if the information is really constant, it doesn't make from a logical point of view to have it <em>mutable</em> in a global variable, it would be better if it was a constant. Finally, and likely the most valuable feature, we can implement some verification at compile time. You could think of this as a <em>better unit testing</em>, since it is impossible to obtain a binary unless everything is correct, preventing you to ship to users a broken program which won't start because a small critical file is missing or its contents changed by mistake to something invalid.</p>

<h3><a class="toc-backref" id="generating-source-code" href="#generating-source-code">Generating source code</a></h3><p>Our first attempt will start by modifying the program to generate a compile time string with the <em>generated source code</em>, which we then pass to the <tt class="docutils literal"><span class="pre">parseStmt</span></tt> proc from the <a class="reference external" href="macros.html">macros module</a>. Here is the modified source code implementing the macro:</p>
<table class="line-nums-table"><tbody><tr><td class="blob-line-nums"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td><pre><span class="Keyword">import</span> <span class="Identifier">macros</span><span class="Punctuation">,</span> <span class="Identifier">strutils</span>

<span class="Keyword">macro</span> <span class="Identifier">readCfgAndBuildSource</span><span class="Punctuation">(</span><span class="Identifier">cfgFilename</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Keyword">let</span>
    <span class="Identifier">inputString</span> <span class="Operator">=</span> <span class="Identifier">slurp</span><span class="Punctuation">(</span><span class="Identifier">cfgFilename</span><span class="Operator">.</span><span class="Identifier">strVal</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span>
    <span class="Identifier">source</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span>
  
  <span class="Keyword">for</span> <span class="Identifier">line</span> <span class="Keyword">in</span> <span class="Identifier">inputString</span><span class="Operator">.</span><span class="Identifier">splitLines</span><span class="Punctuation">:</span>
    <span class="Comment"># Ignore empty lines</span>
    <span class="Keyword">if</span> <span class="Identifier">line</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Keyword">continue</span>
    <span class="Keyword">var</span> <span class="Identifier">chunks</span> <span class="Operator">=</span> <span class="Identifier">split</span><span class="Punctuation">(</span><span class="Identifier">line</span><span class="Punctuation">,</span> <span class="CharLit">','</span><span class="Punctuation">)</span>
    <span class="Keyword">if</span> <span class="Identifier">chunks</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">!=</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
      <span class="Identifier">error</span><span class="Punctuation">(</span><span class="StringLit">&quot;Input needs comma split values, got: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">line</span><span class="Punctuation">)</span>
    <span class="Identifier">source</span> <span class="Operator">&amp;=</span> <span class="StringLit">&quot;const cfg&quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">chunks</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;= </span><span class="EscapeSequence">\&quot;</span><span class="StringLit">&quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">chunks</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span>
  
  <span class="Keyword">if</span> <span class="Identifier">source</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">error</span><span class="Punctuation">(</span><span class="StringLit">&quot;Input file empty!&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">parseStmt</span><span class="Punctuation">(</span><span class="Identifier">source</span><span class="Punctuation">)</span>

<span class="Identifier">readCfgAndBuildSource</span><span class="Punctuation">(</span><span class="StringLit">&quot;data.cfg&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">when</span> <span class="Identifier">isMainModule</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">cfglicenseOwner</span>
  <span class="Identifier">echo</span> <span class="Identifier">cfglicenseKey</span>
  <span class="Identifier">echo</span> <span class="Identifier">cfgversion</span></pre></td></tr></tbody></table><p>The good news is not much has changed! First, we need to change the handling of the input parameter (line 3). In the dynamic version the <tt class="docutils literal"><span class="pre">readCfgAtRuntime</span></tt> proc receives a string parameter. However, in the macro version it is also declared as string, but this is the <em>outside</em> interface of the macro.  When the macro is run, it actually gets a <tt class="docutils literal"><span class="pre">PNimNode</span></tt> object instead of a string, and we have to call the <a class="reference external" href="macros.html#strVal">strVal proc</a> (line 5) from the <a class="reference external" href="macros.html">macros module</a> to obtain the string being passed in to the macro.</p>
<p>Second, we cannot use the <a class="reference external" href="system.html#readFile">readFile proc</a> from the <a class="reference external" href="system.html">system module</a> due to FFI restriction at compile time. If we try to use this proc, or any other which depends on FFI, the compiler will error with the message <tt class="docutils literal"><span class="pre">cannot evaluate</span></tt> and a dump of the macro's source code, along with a stack trace where the compiler reached before bailing out. We can get around this limitation by using the <a class="reference external" href="system.html#slurp">slurp proc</a> from the <a class="reference external" href="system.html">system module</a>, which was precisely made for compilation time (just like <a class="reference external" href="system.html#gorge">gorge</a> which executes an external program and captures its output).</p>
<p>The interesting thing is that our macro does not return a runtime <a class="reference external" href="tables.html#Table">Table</a> object. Instead, it builds up Nim source code into the <tt class="docutils literal"><span class="pre">source</span></tt> variable.  For each line of the configuration file a <tt class="docutils literal"><span class="pre">const</span></tt> variable will be generated (line 15).  To avoid conflicts we prefix these variables with <tt class="docutils literal"><span class="pre">cfg</span></tt>. In essence, what the compiler is doing is replacing the line calling the macro with the following snippet of code:</p>
<pre><span class="Keyword">const</span> <span class="Identifier">cfgversion</span><span class="Operator">=</span> <span class="StringLit">&quot;1.1&quot;</span>
<span class="Keyword">const</span> <span class="Identifier">cfglicenseOwner</span><span class="Operator">=</span> <span class="StringLit">&quot;Hyori Lee&quot;</span>
<span class="Keyword">const</span> <span class="Identifier">cfglicenseKey</span><span class="Operator">=</span> <span class="StringLit">&quot;M1Tl3PjBWO2CC48m&quot;</span></pre><p>You can verify this yourself adding the line <tt class="docutils literal"><span class="pre">echo source</span></tt> somewhere at the end of the macro and compiling the program. Another difference is that instead of calling the usual <a class="reference external" href="system.html#quit">quit proc</a> to abort (which we could still call) this version calls the <a class="reference external" href="macros.html#error">error proc</a> (line 14). The <tt class="docutils literal"><span class="pre">error</span></tt> proc has the same behavior as <tt class="docutils literal"><span class="pre">quit</span></tt> but will dump also the source and file line information where the error happened, making it easier for the programmer to find where compilation failed. In this situation it would point to the line invoking the macro, but <strong>not</strong> the line of <tt class="docutils literal"><span class="pre">data.cfg</span></tt> we are processing, that's something the macro itself would need to control.</p>

<h3><a class="toc-backref" id="generating-ast-by-hand" href="#generating-ast-by-hand">Generating AST by hand</a></h3><p>To generate an AST we would need to intimately know the structures used by the Nim compiler exposed in the <a class="reference external" href="macros.html">macros module</a>, which at first look seems a daunting task. But we can use as helper shortcut the <a class="reference external" href="macros.html#dumpTree">dumpTree macro</a>, which is used as a statement macro instead of an expression macro.  Since we know that we want to generate a bunch of <tt class="docutils literal"><span class="pre">const</span></tt> symbols we can create the following source file and compile it to see what the compiler <em>expects</em> from us:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Identifier">dumpTree</span><span class="Punctuation">:</span>
  <span class="Keyword">const</span> <span class="Identifier">cfgversion</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;1.1&quot;</span>
  <span class="Keyword">const</span> <span class="Identifier">cfglicenseOwner</span><span class="Operator">=</span> <span class="StringLit">&quot;Hyori Lee&quot;</span>
  <span class="Keyword">const</span> <span class="Identifier">cfglicenseKey</span><span class="Operator">=</span> <span class="StringLit">&quot;M1Tl3PjBWO2CC48m&quot;</span></pre><p>During compilation of the source code we should see the following lines in the output (again, since this is a macro, compilation is enough, you don't have to run any binary):<pre>
StmtList
  ConstSection
    ConstDef
      Ident !&quot;cfgversion&quot;
      Ident !&quot;string&quot;
      StrLit 1.1
  ConstSection
    ConstDef
      Ident !&quot;cfglicenseOwner&quot;
      Empty
      StrLit Hyori Lee
  ConstSection
    ConstDef
      Ident !&quot;cfglicenseKey&quot;
      Empty
      StrLit M1Tl3PjBWO2CC48m</pre>
</p>
<p>With this output we have a better idea of what kind of input the compiler expects. We need to generate a list of statements. For each constant the source code generates a <tt class="docutils literal"><span class="pre">ConstSection</span></tt> and a <tt class="docutils literal"><span class="pre">ConstDef</span></tt>. If we were to move all the constants to a single <tt class="docutils literal"><span class="pre">const</span></tt> block we would see only a single <tt class="docutils literal"><span class="pre">ConstSection</span></tt> with three children.</p>
<p>Maybe you didn't notice, but in the <tt class="docutils literal"><span class="pre">dumpTree</span></tt> example the first constant explicitly specifies the type of the constant.  That's why in the tree output the two last constants have their second child <tt class="docutils literal"><span class="pre">Empty</span></tt> but the first has a string identifier. So basically a <tt class="docutils literal"><span class="pre">const</span></tt> definition is made up from an identifier, optionally a type (can be an <em>empty</em> node) and the value. Armed with this knowledge, let's look at the finished version of the AST building macro:</p>
<table class="line-nums-table"><tbody><tr><td class="blob-line-nums"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td><pre><span class="Keyword">import</span> <span class="Identifier">macros</span><span class="Punctuation">,</span> <span class="Identifier">strutils</span>

<span class="Keyword">macro</span> <span class="Identifier">readCfgAndBuildAST</span><span class="Punctuation">(</span><span class="Identifier">cfgFilename</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Keyword">let</span>
    <span class="Identifier">inputString</span> <span class="Operator">=</span> <span class="Identifier">slurp</span><span class="Punctuation">(</span><span class="Identifier">cfgFilename</span><span class="Operator">.</span><span class="Identifier">strVal</span><span class="Punctuation">)</span>
  
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newNimNode</span><span class="Punctuation">(</span><span class="Identifier">nnkStmtList</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">line</span> <span class="Keyword">in</span> <span class="Identifier">inputString</span><span class="Operator">.</span><span class="Identifier">splitLines</span><span class="Punctuation">:</span>
    <span class="Comment"># Ignore empty lines</span>
    <span class="Keyword">if</span> <span class="Identifier">line</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Keyword">continue</span>
    <span class="Keyword">var</span> <span class="Identifier">chunks</span> <span class="Operator">=</span> <span class="Identifier">split</span><span class="Punctuation">(</span><span class="Identifier">line</span><span class="Punctuation">,</span> <span class="CharLit">','</span><span class="Punctuation">)</span>
    <span class="Keyword">if</span> <span class="Identifier">chunks</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">!=</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
      <span class="Identifier">error</span><span class="Punctuation">(</span><span class="StringLit">&quot;Input needs comma split values, got: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">line</span><span class="Punctuation">)</span>
    <span class="Keyword">var</span>
      <span class="Identifier">section</span> <span class="Operator">=</span> <span class="Identifier">newNimNode</span><span class="Punctuation">(</span><span class="Identifier">nnkConstSection</span><span class="Punctuation">)</span>
      <span class="Identifier">constDef</span> <span class="Operator">=</span> <span class="Identifier">newNimNode</span><span class="Punctuation">(</span><span class="Identifier">nnkConstDef</span><span class="Punctuation">)</span>
    <span class="Identifier">constDef</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;cfg&quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">chunks</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">constDef</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">newEmptyNode</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">constDef</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">newStrLitNode</span><span class="Punctuation">(</span><span class="Identifier">chunks</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">section</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">constDef</span><span class="Punctuation">)</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">section</span><span class="Punctuation">)</span>
  
  <span class="Keyword">if</span> <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">error</span><span class="Punctuation">(</span><span class="StringLit">&quot;Input file empty!&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">readCfgAndBuildAST</span><span class="Punctuation">(</span><span class="StringLit">&quot;data.cfg&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">when</span> <span class="Identifier">isMainModule</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">cfglicenseOwner</span>
  <span class="Identifier">echo</span> <span class="Identifier">cfglicenseKey</span>
  <span class="Identifier">echo</span> <span class="Identifier">cfgversion</span></pre></td></tr></tbody></table><p>Since we are building on the previous example generating source code, we will only mention the differences to it. Instead of creating a temporary <tt class="docutils literal"><span class="pre">string</span></tt> variable and writing into it source code as if it were written <em>by hand</em>, we use the <tt class="docutils literal"><span class="pre">result</span></tt> variable directly and create a statement list node (<tt class="docutils literal"><span class="pre">nnkStmtList</span></tt>) which will hold our children (line 7).</p>
<p>For each input line we have to create a constant definition (<tt class="docutils literal"><span class="pre">nnkConstDef</span></tt>) and wrap it inside a constant section (<tt class="docutils literal"><span class="pre">nnkConstSection</span></tt>). Once these variables are created, we fill them hierarchichally (line 17) like the previous AST dump tree showed: the constant definition is a child of the section definition, and the constant definition has an identifier node, an empty node (we let the compiler figure out the type), and a string literal with the value.</p>
<p>A last tip when writing a macro: if you are not sure the AST you are building looks ok, you may be tempted to use the <tt class="docutils literal"><span class="pre">dumpTree</span></tt> macro. But you can't use it <em>inside</em> the macro you are writting/debugging. Instead <tt class="docutils literal"><span class="pre">echo</span></tt> the string generated by <a class="reference external" href="macros.html#treeRepr">treeRepr</a>. If at the end of the this example you add <tt class="docutils literal"><span class="pre">echo treeRepr(result)</span></tt> you should get the same output as using the <tt class="docutils literal"><span class="pre">dumpTree</span></tt> macro, but of course you can call that at any point of the macro where you might be having troubles. </p>
</p>
  
  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small>Made with Nim. Generated: 2015-03-14 19:31:03 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
