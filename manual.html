<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nimrod. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>

<!-- Google fonts -->
<link href='http://fonts.googleapis.com/css?family=Raleway:400,600,900' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'>

<!-- CSS -->
<title>Nim Manual</title>
<style type="text/css" >
/*
Stylesheet for use with Docutils/rst2html.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.

Modified from Chad Skeeters' rst2html-style
https://bitbucket.org/cskeeters/rst2html-style/

Modified by Boyd Greenfield
*/
/* SCSS variables */
/* Text weights */
/* Body colors */
/* Text colors */
/* Link colors */
/* Syntax highlighting colors */
/* Pct changes */
/* Mixins */
/* Body/layout */
html {
  font-size: 100%;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%; }

/* Where we want fancier font if available */
h1, h2, h3, h4, h5, h6, p.module-desc, table.docinfo + blockquote p, table.docinfo blockquote p, h1 + blockquote p {
  font-family: "Raleway", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif !important; }

h1.title {
  font-weight: 900; }

body {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: 14px;
  line-height: 20px;
  color: #2d2d2d;
  background-color: rgba(252, 248, 244, 0.75); }

/* Skeleton grid */
.container {
  position: relative;
  width: 100%;
  max-width: 960px;
  margin: 0 auto;
  padding: 0 20px;
  box-sizing: border-box; }

.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box; }

/* For devices larger than 400px */
@media (min-width: 400px) {
  .container {
    width: 100%;
    padding: 0; } }
/* For devices larger than 650px */
@media (min-width: 650px) {
  .container {
    width: 100%; }

  .column,
  .columns {
    margin-left: 4%; }

  .column:first-child,
  .columns:first-child {
    margin-left: 0; }

  .one.column,
  .one.columns {
    width: 4.66666666667%; }

  .two.columns {
    width: 13.3333333333%; }

  .three.columns {
    width: 22%; }

  .four.columns {
    width: 30.6666666667%; }

  .five.columns {
    width: 39.3333333333%; }

  .six.columns {
    width: 48%; }

  .seven.columns {
    width: 56.6666666667%; }

  .eight.columns {
    width: 65.3333333333%; }

  .nine.columns {
    width: 74.0%; }

  .ten.columns {
    width: 82.6666666667%; }

  .eleven.columns {
    width: 91.3333333333%; }

  .twelve.columns {
    width: 100%;
    margin-left: 0; }

  .one-third.column {
    width: 30.6666666667%; }

  .two-thirds.column {
    width: 65.3333333333%; } }
/* Customer Overrides */
.footer {
  text-align: center;
  color: #969696;
  padding-top: 10%; }

p.module-desc {
  font-size: 1.1em;
  color: #666666; }

a.link-seesrc {
  color: #aec7d2;
  font-style: italic; }

a.link-seesrc:hover {
  color: #6c9aae; }

#toc-list {
  word-wrap: break-word; }

ul.simple-toc {
  list-style: none; }

ul.simple-toc a.reference-toplevel {
  font-weight: bold;
  color: #0077b3; }

ul.simple-toc-section {
  list-style-type: circle;
  color: #6c9aae; }

ul.simple-toc-section a.reference {
  color: #0077b3; }

cite {
  font-style: italic !important; }

dt > pre {
  border-color: rgba(0, 0, 0, 0.15);
  background-color: transparent;
  margin: 15px 0px 5px; }

dd > pre {
  border-color: rgba(0, 0, 0, 0.1);
  background-color: whitesmoke;
  margin-top: 8px; }

.item > dd {
  margin-left: 10px;
  margin-bottom: 30px; }

/* Nim line-numbered tables */
.line-nums-table {
  width: 100%;
  table-layout: fixed; }

table.line-nums-table {
  border-radius: 4px;
  border: 1px solid #cccccc;
  background-color: whitesmoke;
  border-collapse: separate;
  margin-top: 15px;
  margin-bottom: 25px; }

.line-nums-table tbody {
  border: none; }

.line-nums-table td pre {
  border: none;
  background-color: transparent; }

.line-nums-table td.blob-line-nums {
  width: 28px; }

.line-nums-table td.blob-line-nums pre {
  color: #b0b0b0;
  -webkit-filter: opacity(75%);
  text-align: right;
  border-color: transparent;
  background-color: transparent;
  padding-left: 0px;
  margin-left: 0px;
  padding-right: 0px;
  margin-right: 0px; }

/* Docgen styles */
/* Links */
a {
  color: #0077b3;
  text-decoration: none; }

a:hover,
a:focus {
  color: #00334d;
  text-decoration: underline; }

a:visited {
  color: #00334d; }

a:focus {
  outline: thin dotted #2d2d2d;
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px; }

a:hover,
a:active {
  outline: 0; }

sub,
sup {
  position: relative;
  font-size: 75%;
  line-height: 0;
  vertical-align: baseline; }

sup {
  top: -0.5em; }

sub {
  bottom: -0.25em; }

img {
  width: auto;
  height: auto;
  max-width: 100%;
  vertical-align: middle;
  border: 0;
  -ms-interpolation-mode: bicubic; }

@media print {
  * {
    color: black !important;
    text-shadow: none !important;
    background: transparent !important;
    box-shadow: none !important; }

  a,
  a:visited {
    text-decoration: underline; }

  a[href]:after {
    content: " (" attr(href) ")"; }

  abbr[title]:after {
    content: " (" attr(title) ")"; }

  .ir a:after,
  a[href^="javascript:"]:after,
  a[href^="#"]:after {
    content: ""; }

  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid; }

  thead {
    display: table-header-group; }

  tr,
  img {
    page-break-inside: avoid; }

  img {
    max-width: 100% !important; }

  @page {
    margin: 0.5cm; }

  h1 {
    page-break-before: always; }

  h1.title {
    page-break-before: avoid; }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3; }

  h2,
  h3 {
    page-break-after: avoid; } }
.img-rounded {
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.img-polaroid {
  padding: 4px;
  background-color: rgba(252, 248, 244, 0.75);
  border: 1px solid #ccc;
  border: 1px solid rgba(0, 0, 0, 0.2);
  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }

p {
  margin: 0 0 12px; }

small {
  font-size: 85%; }

strong {
  font-weight: 600; }

em {
  font-style: italic; }

cite {
  font-style: normal; }

h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: 600;
  line-height: 20px;
  color: inherit;
  text-rendering: optimizelegibility; }

h1 {
  font-size: 2em;
  padding-bottom: .15em;
  border-bottom: 1px solid #aaaaaa;
  margin-top: 1.0em;
  line-height: 1.2em; }

h1.title {
  padding-bottom: 1em;
  border-bottom: 0px;
  font-size: 2.75em; }

h2 {
  font-size: 1.5em;
  margin-top: 1.5em; }

h3 {
  font-size: 1.3em;
  font-style: italic;
  margin-top: 0.75em; }

h4 {
  font-size: 1.3em;
  margin-top: 0.5em; }

h5 {
  font-size: 1.2em;
  margin-top: 0.25em; }

h6 {
  font-size: 1.1em; }

ul,
ol {
  padding: 0;
  margin: 0 0 0px 15px; }

ul ul,
ul ol,
ol ol,
ol ul {
  margin-bottom: 0; }

li {
  line-height: 20px; }

dl {
  margin-bottom: 20px; }

dt,
dd {
  line-height: 20px; }

dt {
  font-weight: bold; }

dd {
  margin-left: 10px;
  margin-bottom: 26px; }

hr {
  margin: 20px 0;
  border: 0;
  border-top: 1px solid #eeeeee;
  border-bottom: 1px solid #ffffff; }

abbr[title],
abbr[data-original-title] {
  cursor: help;
  border-bottom: 1px dotted #999999; }

abbr.initialism {
  font-size: 90%;
  text-transform: uppercase; }

blockquote {
  padding: 0 0 0 15px;
  margin: 0 0 20px;
  border-left: 5px solid #EFEBE0; }

table.docinfo + blockquote, table.docinfo blockquote, h1 + blockquote {
  border-left: 5px solid #c9c9c9;
}

table.docinfo + blockquote p, table.docinfo blockquote p, h1 + blockquote p {
  margin-bottom: 0;
  font-size: 15px;
  font-weight: 200;
  line-height: 1.5;
  font-style: italic; }

q:before,
q:after,
blockquote:before,
blockquote:after {
  content: ""; }

address {
  display: block;
  margin-bottom: 20px;
  font-style: normal;
  line-height: 20px; }

code,
pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  padding: 0 3px 2px;
  font-weight: 500;
  font-size: 12px;
  color: #444444;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px; }

.pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  font-weight: 600;
  /*color: #504da6;*/
}

code {
  padding: 2px 4px;
  color: #444444;
  white-space: nowrap;
  background-color: white;
  border: 1px solid #777777; }

pre {
  display: inline-block;
  box-sizing: border-box;
  min-width: calc(100% - 19.5px);
  padding: 9.5px;
  margin: 0 10px 0px 10px;
  font-size: 14px;
  line-height: 20px;
  white-space: pre !important;
  overflow-y: hidden;
  overflow-x: visible;
  background-color: whitesmoke;
  border: 1px solid #cccccc;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px; }

pre.prettyprint {
  margin-bottom: 20px; }

pre code {
  padding: 0;
  color: inherit;
  white-space: pre;
  overflow-x: visible;
  background-color: transparent;
  border: 0; }

.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll; }

table {
  max-width: 100%;
  background-color: transparent;
  border-collapse: collapse;
  border-spacing: 0; }

table th, table td {
  padding: 0px 8px 0px;
}

.table {
  width: 100%;
  margin-bottom: 20px; }

.table th,
.table td {
  padding: 8px;
  line-height: 20px;
  text-align: left;
  vertical-align: top;
  border-top: 1px solid #444444; }

.table th {
  font-weight: bold; }

.table thead th {
  vertical-align: bottom; }

.table caption + thead tr:first-child th,
.table caption + thead tr:first-child td,
.table colgroup + thead tr:first-child th,
.table colgroup + thead tr:first-child td,
.table thead:first-child tr:first-child th,
.table thead:first-child tr:first-child td {
  border-top: 0; }

.table tbody + tbody {
  border-top: 2px solid #444444; }

.table .table {
  background-color: rgba(252, 248, 244, 0.75); }

.table-condensed th,
.table-condensed td {
  padding: 4px 5px; }

.table-bordered {
  border: 1px solid #444444;
  border-collapse: separate;
  *border-collapse: collapse;
  border-left: 0;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px; }

.table-bordered th,
.table-bordered td {
  border-left: 1px solid #444444; }

.table-bordered caption + thead tr:first-child th,
.table-bordered caption + tbody tr:first-child th,
.table-bordered caption + tbody tr:first-child td,
.table-bordered colgroup + thead tr:first-child th,
.table-bordered colgroup + tbody tr:first-child th,
.table-bordered colgroup + tbody tr:first-child td,
.table-bordered thead:first-child tr:first-child th,
.table-bordered tbody:first-child tr:first-child th,
.table-bordered tbody:first-child tr:first-child td {
  border-top: 0; }

.table-bordered thead:first-child tr:first-child > th:first-child,
.table-bordered tbody:first-child tr:first-child > td:first-child,
.table-bordered tbody:first-child tr:first-child > th:first-child {
  -webkit-border-top-left-radius: 4px;
  border-top-left-radius: 4px;
  -moz-border-radius-topleft: 4px; }

.table-bordered thead:first-child tr:first-child > th:last-child,
.table-bordered tbody:first-child tr:first-child > td:last-child,
.table-bordered tbody:first-child tr:first-child > th:last-child {
  -webkit-border-top-right-radius: 4px;
  border-top-right-radius: 4px;
  -moz-border-radius-topright: 4px; }

.table-bordered thead:last-child tr:last-child > th:first-child,
.table-bordered tbody:last-child tr:last-child > td:first-child,
.table-bordered tbody:last-child tr:last-child > th:first-child,
.table-bordered tfoot:last-child tr:last-child > td:first-child,
.table-bordered tfoot:last-child tr:last-child > th:first-child {
  -webkit-border-bottom-left-radius: 4px;
  border-bottom-left-radius: 4px;
  -moz-border-radius-bottomleft: 4px; }

.table-bordered thead:last-child tr:last-child > th:last-child,
.table-bordered tbody:last-child tr:last-child > td:last-child,
.table-bordered tbody:last-child tr:last-child > th:last-child,
.table-bordered tfoot:last-child tr:last-child > td:last-child,
.table-bordered tfoot:last-child tr:last-child > th:last-child {
  -webkit-border-bottom-right-radius: 4px;
  border-bottom-right-radius: 4px;
  -moz-border-radius-bottomright: 4px; }

.table-bordered tfoot + tbody:last-child tr:last-child td:first-child {
  -webkit-border-bottom-left-radius: 0;
  border-bottom-left-radius: 0;
  -moz-border-radius-bottomleft: 0; }

.table-bordered tfoot + tbody:last-child tr:last-child td:last-child {
  -webkit-border-bottom-right-radius: 0;
  border-bottom-right-radius: 0;
  -moz-border-radius-bottomright: 0; }

.table-bordered caption + thead tr:first-child th:first-child,
.table-bordered caption + tbody tr:first-child td:first-child,
.table-bordered colgroup + thead tr:first-child th:first-child,
.table-bordered colgroup + tbody tr:first-child td:first-child {
  -webkit-border-top-left-radius: 4px;
  border-top-left-radius: 4px;
  -moz-border-radius-topleft: 4px; }

.table-bordered caption + thead tr:first-child th:last-child,
.table-bordered caption + tbody tr:first-child td:last-child,
.table-bordered colgroup + thead tr:first-child th:last-child,
.table-bordered colgroup + tbody tr:first-child td:last-child {
  -webkit-border-top-right-radius: 4px;
  border-top-right-radius: 4px;
  -moz-border-radius-topright: 4px; }

table.docutils th {
  background-color: #e8e8e8; }

table.docutils tr:hover {
  background-color: whitesmoke; }

.table-striped tbody > tr:nth-child(odd) > td,
.table-striped tbody > tr:nth-child(odd) > th {
  background-color: rgba(252, 248, 244, 0.75); }

.table-hover tbody tr:hover > td,
.table-hover tbody tr:hover > th {
  background-color: rgba(241, 222, 204, 0.75); }

table td[class*="span"],
table th[class*="span"],
.row-fluid table td[class*="span"],
.row-fluid table th[class*="span"] {
  display: table-cell;
  float: none;
  margin-left: 0; }

.hero-unit {
  padding: 60px;
  margin-bottom: 30px;
  font-size: 18px;
  font-weight: 200;
  line-height: 30px;
  color: inherit;
  background-color: rgba(230, 197, 164, 0.75);
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.hero-unit h1 {
  margin-bottom: 0;
  font-size: 60px;
  line-height: 1;
  letter-spacing: -1px;
  color: inherit; }

.hero-unit li {
  line-height: 30px; }

/* rst2html default used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0; }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 !important; }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 !important; }

.last, .with-subtitle {
  margin-bottom: 0 !important; }

.hidden {
  display: none; }

a.toc-backref {
  text-decoration: none;
  color: #444444; }

blockquote.epigraph {
  margin: 2em 5em; }

dl.docutils dd {
  margin-bottom: 0.5em; }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden; }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/
div.abstract {
  margin: 2em 5em; }

div.abstract p.topic-title {
  font-weight: bold;
  text-align: center; }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em;
  border: medium outset;
  padding: 1em; }

div.note, div.warning {
  margin: 1.5em 0px;
  border: none; }

div.note p.admonition-title,
div.warning p.admonition-title {
  display: none; }

/* Clearfix
 * http://css-tricks.com/snippets/css/clear-fix/
 */
div.note:after,
div.warning:after {
  content: "";
  display: table;
  clear: both; }

div.note p:before,
div.warning p:before {
  display: block;
  float: left;
  font-size: 4em;
  line-height: 1em;
  margin-right: 20px;
  margin-left: 0em;
  margin-top: -10px;
  content: '\0270D';
  /*handwriting*/ }

div.warning p:before {
  content: '\026A0';
  /*warning*/ }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold;
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: #b30000;
  font-weight: bold;
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/
div.dedication {
  margin: 2em 5em;
  text-align: center;
  font-style: italic; }

div.dedication p.topic-title {
  font-weight: bold;
  font-style: normal; }

div.figure {
  margin-left: 2em;
  margin-right: 2em; }

div.footer, div.header {
  clear: both;
  font-size: smaller; }

div.line-block {
  display: block;
  margin-top: 1em;
  margin-bottom: 1em; }

div.line-block div.line-block {
  margin-top: 0;
  margin-bottom: 0;
  margin-left: 1.5em; }

div.sidebar {
  margin: 0 0 0.5em 1em;
  border: medium outset;
  padding: 1em;
  background-color: rgba(252, 248, 244, 0.75);
  width: 40%;
  float: right;
  clear: right; }

div.sidebar p.rubric {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-size: medium; }

div.system-messages {
  margin: 5em; }

div.system-messages h1 {
  color: #b30000; }

div.system-message {
  border: medium outset;
  padding: 1em; }

div.system-message p.system-message-title {
  color: #b30000;
  font-weight: bold; }

div.topic {
  margin: 2em; }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em; }

h1.title {
  text-align: center; }

h2.subtitle {
  text-align: center; }

hr.docutils {
  width: 75%; }

img.align-left, .figure.align-left, object.align-left {
  clear: left;
  float: left;
  margin-right: 1em; }

img.align-right, .figure.align-right, object.align-right {
  clear: right;
  float: right;
  margin-left: 1em; }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto; }

.align-left {
  text-align: left; }

.align-center {
  clear: both;
  text-align: center; }

.align-right {
  text-align: right; }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit; }

/* div.align-center * { */
/*   text-align: left } */
ol.simple, ul.simple {
  margin-bottom: 1em; }

ol.arabic {
  list-style: decimal; }

ol.loweralpha {
  list-style: lower-alpha; }

ol.upperalpha {
  list-style: upper-alpha; }

ol.lowerroman {
  list-style: lower-roman; }

ol.upperroman {
  list-style: upper-roman; }

p.attribution {
  text-align: right;
  margin-left: 50%; }

p.caption {
  font-style: italic; }

p.credits {
  font-style: italic;
  font-size: smaller; }

p.label {
  white-space: nowrap; }

p.rubric {
  font-weight: bold;
  font-size: larger;
  color: maroon;
  text-align: center; }

p.sidebar-title {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold;
  font-size: larger; }

p.sidebar-subtitle {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold; }

p.topic-title {
  font-weight: bold; }

pre.address {
  margin-bottom: 0;
  margin-top: 0;
  font: inherit; }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em;
  margin-right: 2em; }

pre.code .ln {
  color: grey; }

/* line numbers */
pre.code, code {
  background-color: #eeeeee; }

pre.code .comment, code .comment {
  color: #5c6576; }

pre.code .keyword, code .keyword {
  color: #3B0D06;
  font-weight: bold; }

pre.code .literal.string, code .literal.string {
  color: #0c5404; }

pre.code .name.builtin, code .name.builtin {
  color: #352b84; }

pre.code .deleted, code .deleted {
  background-color: #DEB0A1; }

pre.code .inserted, code .inserted {
  background-color: #A3D289; }

span.classifier {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-style: oblique; }

span.classifier-delimiter {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold; }

span.interpreted {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

span.option {
  white-space: nowrap; }

span.pre {
  white-space: pre; }

span.problematic {
  color: #b30000; }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80%; }

table.citation {
  border-left: solid 1px #666666;
  margin-left: 1px; }

table.docinfo {
  margin: 0em;
  margin-top: 2em;
  margin-bottom: 2em;
  font-family: "Raleway", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif !important;
  color: #444444; }

table.docutils {
  margin-top: 0.5em;
  margin-bottom: 0.5em; }

table.footnote {
  border-left: solid 1px #2d2d2d;
  margin-left: 1px; }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em;
  padding-right: 0.5em;
  vertical-align: top; }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: 700;
  text-align: left;
  white-space: nowrap;
  padding-left: 0; }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100%; }

ul.auto-toc {
  list-style-type: none; }

span.DecNumber {
  color: #252dbe; }

span.BinNumber {
  color: #252dbe; }

span.HexNumber {
  color: #252dbe; }

span.OctNumber {
  color: #252dbe; }

span.FloatNumber {
  color: #252dbe; }

span.Identifier {
  color: #3b3b3b; }

span.Keyword {
  font-weight: 600;
  color: #5e8f60; }

span.StringLit {
  color: #a4255b; }

span.LongStringLit {
  color: #a4255b; }

span.CharLit {
  color: #a4255b; }

span.EscapeSequence {
  color: black; }

span.Operator {
  color: black; }

span.Punctuation {
  color: black; }

span.Comment, span.LongComment {
  font-style: italic;
  font-weight: 400;
  color: #484a86; }

span.RegularExpression {
  color: darkviolet; }

span.TagStart {
  color: darkviolet; }

span.TagEnd {
  color: darkviolet; }

span.Key {
  color: #252dbe; }

span.Value {
  color: #252dbe; }

span.RawData {
  color: #a4255b; }

span.Assembler {
  color: #252dbe; }

span.Preprocessor {
  color: #252dbe; }

span.Directive {
  color: #252dbe; }

span.Command, span.Rule, span.Hyperlink, span.Label, span.Reference,
span.Other {
  color: black; }

/* Pop type, const, proc, and iterator defs in nim def blocks */
dt pre > span.Identifier, dt pre > span.Operator {
  color: #155da4;
  font-weight: 700; }

dt pre > span.Identifier ~ span.Identifier, dt pre > span.Operator ~ span.Identifier {
  color: inherit;
  font-weight: inherit; }

dt pre > span.Operator ~ span.Identifier, dt pre > span.Operator ~ span.Operator {
  color: inherit;
  font-weight: inherit; }

/* Nim sprite for the footer (taken from main page favicon) */
.nim-sprite {
  display: inline-block;
  height: 12px;
  width: 12px;
  background-position: 0 0;
  background-size: 12px 12px;
  -webkit-filter: opacity(50%);
  background-repeat: no-repeat;
  background-image: url("data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA==");
  margin-bottom: -5px; }
</style>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Nim Manual</h1>
    <div class="row">
  <div class="three columns">
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="about-this-document_toc" href="#about-this-document">About this document</a></li>
<li><a class="reference" id="definitions_toc" href="#definitions">Definitions</a></li>
<li><a class="reference" id="lexical-analysis_toc" href="#lexical-analysis">Lexical Analysis</a></li>
<ul class="simple"><li><a class="reference" id="encoding_toc" href="#encoding">Encoding</a></li>
<li><a class="reference" id="indentation_toc" href="#indentation">Indentation</a></li>
<li><a class="reference" id="comments_toc" href="#comments">Comments</a></li>
<li><a class="reference" id="identifiers-keywords_toc" href="#identifiers-keywords">Identifiers &amp; Keywords</a></li>
<li><a class="reference" id="identifier-equality_toc" href="#identifier-equality">Identifier equality</a></li>
<li><a class="reference" id="string-literals_toc" href="#string-literals">String literals</a></li>
<li><a class="reference" id="triple-quoted-string-literals_toc" href="#triple-quoted-string-literals">Triple quoted string literals</a></li>
<li><a class="reference" id="raw-string-literals_toc" href="#raw-string-literals">Raw string literals</a></li>
<li><a class="reference" id="generalized-raw-string-literals_toc" href="#generalized-raw-string-literals">Generalized raw string literals</a></li>
<li><a class="reference" id="character-literals_toc" href="#character-literals">Character literals</a></li>
<li><a class="reference" id="numerical-constants_toc" href="#numerical-constants">Numerical constants</a></li>
<li><a class="reference" id="operators_toc" href="#operators">Operators</a></li>
<li><a class="reference" id="other-tokens_toc" href="#other-tokens">Other tokens</a></li>
</ul><li><a class="reference" id="syntax_toc" href="#syntax">Syntax</a></li>
<ul class="simple"><li><a class="reference" id="associativity_toc" href="#associativity">Associativity</a></li>
<li><a class="reference" id="precedence_toc" href="#precedence">Precedence</a></li>
<li><a class="reference" id="strong-spaces_toc" href="#strong-spaces">Strong spaces</a></li>
<li><a class="reference" id="grammar_toc" href="#grammar">Grammar</a></li>
</ul><li><a class="reference" id="types_toc" href="#types">Types</a></li>
<ul class="simple"><li><a class="reference" id="ordinal-types_toc" href="#ordinal-types">Ordinal types</a></li>
<li><a class="reference" id="pre-defined-integer-types_toc" href="#pre-defined-integer-types">Pre-defined integer types</a></li>
<li><a class="reference" id="subrange-types_toc" href="#subrange-types">Subrange types</a></li>
<li><a class="reference" id="pre-defined-floating-point-types_toc" href="#pre-defined-floating-point-types">Pre-defined floating point types</a></li>
<li><a class="reference" id="boolean-type_toc" href="#boolean-type">Boolean type</a></li>
<li><a class="reference" id="character-type_toc" href="#character-type">Character type</a></li>
<li><a class="reference" id="enumeration-types_toc" href="#enumeration-types">Enumeration types</a></li>
<li><a class="reference" id="string-type_toc" href="#string-type">String type</a></li>
<li><a class="reference" id="cstring-type_toc" href="#cstring-type">cstring type</a></li>
<li><a class="reference" id="structured-types_toc" href="#structured-types">Structured types</a></li>
<li><a class="reference" id="array-and-sequence-types_toc" href="#array-and-sequence-types">Array and sequence types</a></li>
<li><a class="reference" id="open-arrays_toc" href="#open-arrays">Open arrays</a></li>
<li><a class="reference" id="varargs_toc" href="#varargs">Varargs</a></li>
<li><a class="reference" id="tuples-and-object-types_toc" href="#tuples-and-object-types">Tuples and object types</a></li>
<li><a class="reference" id="object-construction_toc" href="#object-construction">Object construction</a></li>
<li><a class="reference" id="object-variants_toc" href="#object-variants">Object variants</a></li>
<li><a class="reference" id="set-type_toc" href="#set-type">Set type</a></li>
<li><a class="reference" id="reference-and-pointer-types_toc" href="#reference-and-pointer-types">Reference and pointer types</a></li>
<li><a class="reference" id="not-nil-annotation_toc" href="#not-nil-annotation">Not nil annotation</a></li>
<li><a class="reference" id="memory-regions_toc" href="#memory-regions">Memory regions</a></li>
<li><a class="reference" id="procedural-type_toc" href="#procedural-type">Procedural type</a></li>
<li><a class="reference" id="distinct-type_toc" href="#distinct-type">Distinct type</a></li>
<ul class="simple"><li><a class="reference" id="modelling-currencies_toc" href="#modelling-currencies">Modelling currencies</a></li>
<li><a class="reference" id="avoiding-sql-injection-attacks_toc" href="#avoiding-sql-injection-attacks">Avoiding SQL injection attacks</a></li>
</ul><li><a class="reference" id="void-type_toc" href="#void-type">Void type</a></li>
</ul><li><a class="reference" id="type-relations_toc" href="#type-relations">Type relations</a></li>
<ul class="simple"><li><a class="reference" id="type-equality_toc" href="#type-equality">Type equality</a></li>
<li><a class="reference" id="type-equality-modulo-type-distinction_toc" href="#type-equality-modulo-type-distinction">Type equality modulo type distinction</a></li>
<li><a class="reference" id="subtype-relation_toc" href="#subtype-relation">Subtype relation</a></li>
<li><a class="reference" id="convertible-relation_toc" href="#convertible-relation">Convertible relation</a></li>
<li><a class="reference" id="assignment-compatibility_toc" href="#assignment-compatibility">Assignment compatibility</a></li>
<li><a class="reference" id="overloading-resolution_toc" href="#overloading-resolution">Overloading resolution</a></li>
</ul><li><a class="reference" id="statements-and-expressions_toc" href="#statements-and-expressions">Statements and expressions</a></li>
<ul class="simple"><li><a class="reference" id="statement-list-expression_toc" href="#statement-list-expression">Statement list expression</a></li>
<li><a class="reference" id="discard-statement_toc" href="#discard-statement">Discard statement</a></li>
<li><a class="reference" id="var-statement_toc" href="#var-statement">Var statement</a></li>
<li><a class="reference" id="let-statement_toc" href="#let-statement">let statement</a></li>
<li><a class="reference" id="const-section_toc" href="#const-section">Const section</a></li>
<li><a class="reference" id="static-statement-expression_toc" href="#static-statement-expression">Static statement/expression</a></li>
<li><a class="reference" id="if-statement_toc" href="#if-statement">If statement</a></li>
<li><a class="reference" id="case-statement_toc" href="#case-statement">Case statement</a></li>
<li><a class="reference" id="when-statement_toc" href="#when-statement">When statement</a></li>
<li><a class="reference" id="return-statement_toc" href="#return-statement">Return statement</a></li>
<li><a class="reference" id="yield-statement_toc" href="#yield-statement">Yield statement</a></li>
<li><a class="reference" id="block-statement_toc" href="#block-statement">Block statement</a></li>
<li><a class="reference" id="break-statement_toc" href="#break-statement">Break statement</a></li>
<li><a class="reference" id="while-statement_toc" href="#while-statement">While statement</a></li>
<li><a class="reference" id="continue-statement_toc" href="#continue-statement">Continue statement</a></li>
<li><a class="reference" id="assembler-statement_toc" href="#assembler-statement">Assembler statement</a></li>
<li><a class="reference" id="using-statement_toc" href="#using-statement">Using statement</a></li>
<li><a class="reference" id="if-expression_toc" href="#if-expression">If expression</a></li>
<li><a class="reference" id="when-expression_toc" href="#when-expression">When expression</a></li>
<li><a class="reference" id="case-expression_toc" href="#case-expression">Case expression</a></li>
<li><a class="reference" id="table-constructor_toc" href="#table-constructor">Table constructor</a></li>
<li><a class="reference" id="type-conversions_toc" href="#type-conversions">Type conversions</a></li>
<li><a class="reference" id="type-casts_toc" href="#type-casts">Type casts</a></li>
<li><a class="reference" id="the-addr-operator_toc" href="#the-addr-operator">The addr operator</a></li>
</ul><li><a class="reference" id="procedures_toc" href="#procedures">Procedures</a></li>
<ul class="simple"><li><a class="reference" id="export-marker_toc" href="#export-marker">Export marker</a></li>
<li><a class="reference" id="method-call-syntax_toc" href="#method-call-syntax">Method call syntax</a></li>
<li><a class="reference" id="properties_toc" href="#properties">Properties</a></li>
<li><a class="reference" id="command-invocation-syntax_toc" href="#command-invocation-syntax">Command invocation syntax</a></li>
<li><a class="reference" id="closures_toc" href="#closures">Closures</a></li>
<li><a class="reference" id="anonymous-procs_toc" href="#anonymous-procs">Anonymous Procs</a></li>
<li><a class="reference" id="do-notation_toc" href="#do-notation">Do notation</a></li>
<li><a class="reference" id="nonoverloadable-builtins_toc" href="#nonoverloadable-builtins">Nonoverloadable builtins</a></li>
<li><a class="reference" id="var-parameters_toc" href="#var-parameters">Var parameters</a></li>
<li><a class="reference" id="var-return-type_toc" href="#var-return-type">Var return type</a></li>
<li><a class="reference" id="overloading-of-the-subscript-operator_toc" href="#overloading-of-the-subscript-operator">Overloading of the subscript operator</a></li>
</ul><li><a class="reference" id="multi-methods_toc" href="#multi-methods">Multi-methods</a></li>
<li><a class="reference" id="iterators-and-the-for-statement_toc" href="#iterators-and-the-for-statement">Iterators and the for statement</a></li>
<ul class="simple"><li><a class="reference" id="implict-items-pairs-invocations_toc" href="#implict-items-pairs-invocations">Implict items/pairs invocations</a></li>
<li><a class="reference" id="first-class-iterators_toc" href="#first-class-iterators">First class iterators</a></li>
</ul><li><a class="reference" id="converters_toc" href="#converters">Converters</a></li>
<li><a class="reference" id="type-sections_toc" href="#type-sections">Type sections</a></li>
<li><a class="reference" id="exception-handling_toc" href="#exception-handling">Exception handling</a></li>
<ul class="simple"><li><a class="reference" id="try-statement_toc" href="#try-statement">Try statement</a></li>
<li><a class="reference" id="try-expression_toc" href="#try-expression">Try expression</a></li>
<li><a class="reference" id="except-clauses_toc" href="#except-clauses">Except clauses</a></li>
<li><a class="reference" id="defer-statement_toc" href="#defer-statement">Defer statement</a></li>
<li><a class="reference" id="raise-statement_toc" href="#raise-statement">Raise statement</a></li>
<li><a class="reference" id="exception-hierarchy_toc" href="#exception-hierarchy">Exception hierarchy</a></li>
</ul><li><a class="reference" id="effect-system_toc" href="#effect-system">Effect system</a></li>
<ul class="simple"><li><a class="reference" id="exception-tracking_toc" href="#exception-tracking">Exception tracking</a></li>
<li><a class="reference" id="tag-tracking_toc" href="#tag-tracking">Tag tracking</a></li>
<li><a class="reference" id="read-write-tracking_toc" href="#read-write-tracking">Read/Write tracking</a></li>
<li><a class="reference" id="effects-pragma_toc" href="#effects-pragma">Effects pragma</a></li>
</ul><li><a class="reference" id="generics_toc" href="#generics">Generics</a></li>
<ul class="simple"><li><a class="reference" id="is-operator_toc" href="#is-operator">Is operator</a></li>
<li><a class="reference" id="type-operator_toc" href="#type-operator">Type operator</a></li>
<li><a class="reference" id="type-classes_toc" href="#type-classes">Type Classes</a></li>
<li><a class="reference" id="user-defined-type-classes_toc" href="#user-defined-type-classes">User defined type classes</a></li>
<li><a class="reference" id="type-inference-with-type-classes_toc" href="#type-inference-with-type-classes">Type inference with type classes</a></li>
<li><a class="reference" id="symbol-lookup-in-generics_toc" href="#symbol-lookup-in-generics">Symbol lookup in generics</a></li>
<li><a class="reference" id="bind-statement_toc" href="#bind-statement">Bind statement</a></li>
</ul><li><a class="reference" id="templates_toc" href="#templates">Templates</a></li>
<ul class="simple"><li><a class="reference" id="ordinary-vs-immediate-templates_toc" href="#ordinary-vs-immediate-templates">Ordinary vs immediate templates</a></li>
<li><a class="reference" id="passing-a-code-block-to-a-template_toc" href="#passing-a-code-block-to-a-template">Passing a code block to a template</a></li>
<li><a class="reference" id="symbol-binding-in-templates_toc" href="#symbol-binding-in-templates">Symbol binding in templates</a></li>
<li><a class="reference" id="identifier-construction_toc" href="#identifier-construction">Identifier construction</a></li>
<li><a class="reference" id="lookup-rules-for-template-parameters_toc" href="#lookup-rules-for-template-parameters">Lookup rules for template parameters</a></li>
<li><a class="reference" id="hygiene-in-templates_toc" href="#hygiene-in-templates">Hygiene in templates</a></li>
<li><a class="reference" id="limitations-of-the-method-call-syntax_toc" href="#limitations-of-the-method-call-syntax">Limitations of the method call syntax</a></li>
</ul><li><a class="reference" id="macros_toc" href="#macros">Macros</a></li>
<ul class="simple"><li><a class="reference" id="expression-macros_toc" href="#expression-macros">Expression Macros</a></li>
<li><a class="reference" id="bindsym_toc" href="#bindsym">BindSym</a></li>
<li><a class="reference" id="statement-macros_toc" href="#statement-macros">Statement Macros</a></li>
<li><a class="reference" id="macros-as-pragmas_toc" href="#macros-as-pragmas">Macros as pragmas</a></li>
</ul><li><a class="reference" id="special-types_toc" href="#special-types">Special Types</a></li>
<ul class="simple"><li><a class="reference" id="static-t_toc" href="#static-t">static[T]</a></li>
<li><a class="reference" id="typedesc_toc" href="#typedesc">typedesc</a></li>
</ul><li><a class="reference" id="special-operators_toc" href="#special-operators">Special Operators</a></li>
<ul class="simple"><li><a class="reference" id="dot-operators_toc" href="#dot-operators">dot operators</a></li>
<li><a class="reference" id="operator_toc" href="#operator">operator <cite>.</cite></a></li>
<li><a class="reference" id="operator_toc" href="#operator">operator <cite>.()</cite></a></li>
<li><a class="reference" id="operator_toc" href="#operator">operator <cite>.=</cite></a></li>
</ul><li><a class="reference" id="type-bound-operations_toc" href="#type-bound-operations">Type bound operations</a></li>
<ul class="simple"><li><a class="reference" id="operator_toc" href="#operator">operator <cite>=</cite></a></li>
<li><a class="reference" id="destructors_toc" href="#destructors">destructors</a></li>
<li><a class="reference" id="deepcopy_toc" href="#deepcopy">deepCopy</a></li>
</ul><li><a class="reference" id="term-rewriting-macros_toc" href="#term-rewriting-macros">Term rewriting macros</a></li>
<ul class="simple"><li><a class="reference" id="parameter-constraints_toc" href="#parameter-constraints">Parameter constraints</a></li>
<li><a class="reference" id="pattern-operators_toc" href="#pattern-operators">Pattern operators</a></li>
<ul class="simple"><li><a class="reference" id="the-operator_toc" href="#the-operator">The <tt class="docutils literal"><span class="pre">|</span></tt> operator</a></li>
<li><a class="reference" id="the-operator_toc" href="#the-operator">The <tt class="docutils literal"><span class="pre">{}</span></tt> operator</a></li>
<li><a class="reference" id="the-operator_toc" href="#the-operator">The <tt class="docutils literal"><span class="pre">~</span></tt> operator</a></li>
<li><a class="reference" id="the-operator_toc" href="#the-operator">The <tt class="docutils literal"><span class="pre">*</span></tt> operator</a></li>
<li><a class="reference" id="the-operator_toc" href="#the-operator">The <tt class="docutils literal"><span class="pre">**</span></tt> operator</a></li>
</ul><li><a class="reference" id="parameters_toc" href="#parameters">Parameters</a></li>
<li><a class="reference" id="example-partial-evaluation_toc" href="#example-partial-evaluation">Example: Partial evaluation</a></li>
<li><a class="reference" id="example-hoisting_toc" href="#example-hoisting">Example: Hoisting</a></li>
</ul><li><a class="reference" id="ast-based-overloading_toc" href="#ast-based-overloading">AST based overloading</a></li>
<ul class="simple"><li><a class="reference" id="move-optimization_toc" href="#move-optimization">Move optimization</a></li>
</ul><li><a class="reference" id="modules_toc" href="#modules">Modules</a></li>
<ul class="simple"><li><a class="reference" id="import-statement_toc" href="#import-statement">Import statement</a></li>
<li><a class="reference" id="include-statement_toc" href="#include-statement">Include statement</a></li>
<li><a class="reference" id="module-names-in-imports_toc" href="#module-names-in-imports">Module names in imports</a></li>
<li><a class="reference" id="from-import-statement_toc" href="#from-import-statement">From import statement</a></li>
<li><a class="reference" id="export-statement_toc" href="#export-statement">Export statement</a></li>
</ul><ul class="simple"><li><a class="reference" id="scope-rules_toc" href="#scope-rules">Scope rules</a></li>
<ul class="simple"><li><a class="reference" id="block-scope_toc" href="#block-scope">Block scope</a></li>
<li><a class="reference" id="tuple-or-object-scope_toc" href="#tuple-or-object-scope">Tuple or object scope</a></li>
<li><a class="reference" id="module-scope_toc" href="#module-scope">Module scope</a></li>
</ul></ul><li><a class="reference" id="compiler-messages_toc" href="#compiler-messages">Compiler Messages</a></li>
<li><a class="reference" id="pragmas_toc" href="#pragmas">Pragmas</a></li>
<ul class="simple"><li><a class="reference" id="deprecated-pragma_toc" href="#deprecated-pragma">deprecated pragma</a></li>
<li><a class="reference" id="nosideeffect-pragma_toc" href="#nosideeffect-pragma">noSideEffect pragma</a></li>
<li><a class="reference" id="destructor-pragma_toc" href="#destructor-pragma">destructor pragma</a></li>
<li><a class="reference" id="override-pragma_toc" href="#override-pragma">override pragma</a></li>
<li><a class="reference" id="procvar-pragma_toc" href="#procvar-pragma">procvar pragma</a></li>
<li><a class="reference" id="compiletime-pragma_toc" href="#compiletime-pragma">compileTime pragma</a></li>
<li><a class="reference" id="noreturn-pragma_toc" href="#noreturn-pragma">noReturn pragma</a></li>
<li><a class="reference" id="acyclic-pragma_toc" href="#acyclic-pragma">acyclic pragma</a></li>
<li><a class="reference" id="final-pragma_toc" href="#final-pragma">final pragma</a></li>
<li><a class="reference" id="shallow-pragma_toc" href="#shallow-pragma">shallow pragma</a></li>
<li><a class="reference" id="pure-pragma_toc" href="#pure-pragma">pure pragma</a></li>
<li><a class="reference" id="asmnostackframe-pragma_toc" href="#asmnostackframe-pragma">asmNoStackFrame pragma</a></li>
<li><a class="reference" id="error-pragma_toc" href="#error-pragma">error pragma</a></li>
<li><a class="reference" id="fatal-pragma_toc" href="#fatal-pragma">fatal pragma</a></li>
<li><a class="reference" id="warning-pragma_toc" href="#warning-pragma">warning pragma</a></li>
<li><a class="reference" id="hint-pragma_toc" href="#hint-pragma">hint pragma</a></li>
<li><a class="reference" id="line-pragma_toc" href="#line-pragma">line pragma</a></li>
<li><a class="reference" id="linearscanend-pragma_toc" href="#linearscanend-pragma">linearScanEnd pragma</a></li>
<li><a class="reference" id="computedgoto-pragma_toc" href="#computedgoto-pragma">computedGoto pragma</a></li>
<li><a class="reference" id="unroll-pragma_toc" href="#unroll-pragma">unroll pragma</a></li>
<li><a class="reference" id="immediate-pragma_toc" href="#immediate-pragma">immediate pragma</a></li>
<li><a class="reference" id="compilation-option-pragmas_toc" href="#compilation-option-pragmas">compilation option pragmas</a></li>
<li><a class="reference" id="push-and-pop-pragmas_toc" href="#push-and-pop-pragmas">push and pop pragmas</a></li>
<li><a class="reference" id="register-pragma_toc" href="#register-pragma">register pragma</a></li>
<li><a class="reference" id="global-pragma_toc" href="#global-pragma">global pragma</a></li>
<li><a class="reference" id="deadcodeelim-pragma_toc" href="#deadcodeelim-pragma">deadCodeElim pragma</a></li>
<li><a class="reference" id="pragma-pragma_toc" href="#pragma-pragma">pragma pragma</a></li>
<li><a class="reference" id="disabling-certain-messages_toc" href="#disabling-certain-messages">Disabling certain messages</a></li>
<li><a class="reference" id="experimental-pragma_toc" href="#experimental-pragma">experimental pragma</a></li>
</ul><li><a class="reference" id="foreign-function-interface_toc" href="#foreign-function-interface">Foreign function interface</a></li>
<ul class="simple"><li><a class="reference" id="importc-pragma_toc" href="#importc-pragma">Importc pragma</a></li>
<li><a class="reference" id="exportc-pragma_toc" href="#exportc-pragma">Exportc pragma</a></li>
<li><a class="reference" id="extern-pragma_toc" href="#extern-pragma">Extern pragma</a></li>
<li><a class="reference" id="bycopy-pragma_toc" href="#bycopy-pragma">Bycopy pragma</a></li>
<li><a class="reference" id="byref-pragma_toc" href="#byref-pragma">Byref pragma</a></li>
<li><a class="reference" id="varargs-pragma_toc" href="#varargs-pragma">Varargs pragma</a></li>
<li><a class="reference" id="union-pragma_toc" href="#union-pragma">Union pragma</a></li>
<li><a class="reference" id="packed-pragma_toc" href="#packed-pragma">Packed pragma</a></li>
<li><a class="reference" id="unchecked-pragma_toc" href="#unchecked-pragma">Unchecked pragma</a></li>
<li><a class="reference" id="dynlib-pragma-for-import_toc" href="#dynlib-pragma-for-import">Dynlib pragma for import</a></li>
<li><a class="reference" id="dynlib-pragma-for-export_toc" href="#dynlib-pragma-for-export">Dynlib pragma for export</a></li>
</ul><li><a class="reference" id="threads_toc" href="#threads">Threads</a></li>
<ul class="simple"><li><a class="reference" id="thread-pragma_toc" href="#thread-pragma">Thread pragma</a></li>
<li><a class="reference" id="gc-safety_toc" href="#gc-safety">GC safety</a></li>
<li><a class="reference" id="threadvar-pragma_toc" href="#threadvar-pragma">Threadvar pragma</a></li>
<li><a class="reference" id="threads-and-exceptions_toc" href="#threads-and-exceptions">Threads and exceptions</a></li>
</ul><li><a class="reference" id="parallel-spawn_toc" href="#parallel-spawn">Parallel &amp; Spawn</a></li>
<ul class="simple"><li><a class="reference" id="spawn-statement_toc" href="#spawn-statement">Spawn statement</a></li>
<li><a class="reference" id="parallel-statement_toc" href="#parallel-statement">Parallel statement</a></li>
</ul><li><a class="reference" id="guards-and-locks_toc" href="#guards-and-locks">Guards and locks</a></li>
<ul class="simple"><li><a class="reference" id="guards-and-the-locks-section_toc" href="#guards-and-the-locks-section">Guards and the locks section</a></li>
<ul class="simple"><li><a class="reference" id="protecting-global-variables_toc" href="#protecting-global-variables">Protecting global variables</a></li>
<li><a class="reference" id="protecting-general-locations_toc" href="#protecting-general-locations">Protecting general locations</a></li>
</ul><li><a class="reference" id="lock-levels_toc" href="#lock-levels">Lock levels</a></li>
</ul><li><a class="reference" id="taint-mode_toc" href="#taint-mode">Taint mode</a></li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Authors:</th><td> Andreas Rumpf, Zahary Karadjov</td></tr>
<tr><th class="docinfo-name">Version:</th><td> |nimversion|</td></tr>
</tbody></table><blockquote><p>&quot;Complexity&quot; seems to be a lot like &quot;energy&quot;: you can transfer it from the end user to one/some of the other players, but the total amount seems to remain pretty much constant for a given task. -- Ran</p></blockquote>

<h1><a class="toc-backref" id="about-this-document" href="#about-this-document">About this document</a></h1><p><strong>Note</strong>: This document is a draft! Several of Nim's features need more precise wording. This manual will evolve into a proper specification some day.</p>
<p>This document describes the lexis, the syntax, and the semantics of Nim.</p>
<p>The language constructs are explained using an extended BNF, in which <tt class="docutils literal"><span class="pre">(a)*</span></tt> means 0 or more <tt class="docutils literal"><span class="pre">a</span></tt>'s, <tt class="docutils literal"><span class="pre">a+</span></tt> means 1 or more <tt class="docutils literal"><span class="pre">a</span></tt>'s, and <tt class="docutils literal"><span class="pre">(a)?</span></tt> means an optional <em>a</em>. Parentheses may be used to group elements.</p>
<p><tt class="docutils literal"><span class="pre">&amp;</span></tt> is the lookahead operator; <tt class="docutils literal"><span class="pre">&amp;a</span></tt> means that an <tt class="docutils literal"><span class="pre">a</span></tt> is expected but not consumed. It will be consumed in the following rule.</p>
<p>The <tt class="docutils literal"><span class="pre">|</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt> symbols are used to mark alternatives and have the lowest precedence. <tt class="docutils literal"><span class="pre">/</span></tt> is the ordered choice that requires the parser to try the alternatives in the given order. <tt class="docutils literal"><span class="pre">/</span></tt> is often used to ensure the grammar is not ambiguous.</p>
<p>Non-terminals start with a lowercase letter, abstract terminal symbols are in UPPERCASE. Verbatim terminal symbols (including keywords) are quoted with <tt class="docutils literal"><span class="pre">'</span></tt>. An example:<pre>
ifStmt = 'if' expr ':' stmts ('elif' expr ':' stmts)* ('else' stmts)?</pre>
</p>
<p>The binary <tt class="docutils literal"><span class="pre">^*</span></tt> operator is used as a shorthand for 0 or more occurrences separated by its second argument; likewise <tt class="docutils literal"><span class="pre">^+</span></tt> means 1 or more occurrences: <tt class="docutils literal"><span class="pre">a ^+ b</span></tt> is short for <tt class="docutils literal"><span class="pre">a (b a)*</span></tt> and <tt class="docutils literal"><span class="pre">a ^* b</span></tt> is short for <tt class="docutils literal"><span class="pre">(a (b a)*)?</span></tt>. Example:<pre>
arrayConstructor = '[' expr ^* ',' ']'</pre>
</p>
<p>Other parts of Nim - like scoping rules or runtime semantics are only described in an informal manner for now.</p>

<h1><a class="toc-backref" id="definitions" href="#definitions">Definitions</a></h1><p>A Nim program specifies a computation that acts on a memory consisting of components called <span id="locations_1">locations</span>. A variable is basically a name for a location. Each variable and location is of a certain <span id="type_1">type</span>. The variable's type is called <span id="static-type_1">static type</span>, the location's type is called <span id="dynamic-type_1">dynamic type</span>. If the static type is not the same as the dynamic type, it is a super-type or subtype of the dynamic type.</p>
<p>An <span id="identifier_1">identifier</span> is a symbol declared as a name for a variable, type, procedure, etc. The region of the program over which a declaration applies is called the <span id="scope_1">scope</span> of the declaration. Scopes can be nested. The meaning of an identifier is determined by the smallest enclosing scope in which the identifier is declared unless overloading resolution rules suggest otherwise.</p>
<p>An expression specifies a computation that produces a value or location. Expressions that produce locations are called <span id="l-values_1">l-values</span>. An l-value can denote either a location or the value the location contains, depending on the context. Expressions whose values can be determined statically are called <span id="constant-expressions_1">constant expressions</span>; they are never l-values.</p>
<p>A <span id="static-error_1">static error</span> is an error that the implementation detects before program execution. Unless explicitly classified, an error is a static error.</p>
<p>A <span id="checked-runtime-error_1">checked runtime error</span> is an error that the implementation detects and reports at runtime. The method for reporting such errors is via <em>raising exceptions</em> or <em>dying with a fatal error</em>. However, the implementation provides a means to disable these runtime checks. See the section <a class="reference external" href="#pragmas">pragmas</a> for details.</p>
<p>Wether a checked runtime error results in an exception or in a fatal error at runtime is implementation specific. Thus the following program is always invalid:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">]</span>
<span class="Keyword">let</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">5</span>
<span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="CharLit">'N'</span>
<span class="Keyword">except</span> <span class="Identifier">IndexError</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;invalid index&quot;</span></pre><p>An <span id="unchecked-runtime-error_1">unchecked runtime error</span> is an error that is not guaranteed to be detected, and can cause the subsequent behavior of the computation to be arbitrary. Unchecked runtime errors cannot occur if only <span id="safe_1">safe</span> language features are used.</p>

<h1><a class="toc-backref" id="lexical-analysis" href="#lexical-analysis">Lexical Analysis</a></h1>
<h2><a class="toc-backref" id="encoding" href="#encoding">Encoding</a></h2><p>All Nim source files are in the UTF-8 encoding (or its ASCII subset). Other encodings are not supported. Any of the standard platform line termination sequences can be used - the Unix form using ASCII LF (linefeed), the Windows form using the ASCII sequence CR LF (return followed by linefeed), or the old Macintosh form using the ASCII CR (return) character. All of these forms can be used equally, regardless of platform.</p>

<h2><a class="toc-backref" id="indentation" href="#indentation">Indentation</a></h2><p>Nim's standard grammar describes an <span id="indentation-sensitive_1">indentation sensitive</span> language. This means that all the control structures are recognized by indentation. Indentation consists only of spaces; tabulators are not allowed.</p>
<p>The indentation handling is implemented as follows: The lexer annotates the following token with the preceding number of spaces; indentation is not a separate token. This trick allows parsing of Nim with only 1 token of lookahead.</p>
<p>The parser uses a stack of indentation levels: the stack consists of integers counting the spaces. The indentation information is queried at strategic places in the parser but ignored otherwise: The pseudo terminal <tt class="docutils literal"><span class="pre">IND{&gt;}</span></tt> denotes an indentation that consists of more spaces than the entry at the top of the stack; IND{=} an indentation that has the same number of spaces. <tt class="docutils literal"><span class="pre">DED</span></tt> is another pseudo terminal that describes the <em>action</em> of popping a value from the stack, <tt class="docutils literal"><span class="pre">IND{&gt;}</span></tt> then implies to push onto the stack.</p>
<p>With this notation we can now easily define the core of the grammar: A block of statements (simplified example):<pre>
ifStmt = 'if' expr ':' stmt
         (IND{=} 'elif' expr ':' stmt)*
         (IND{=} 'else' ':' stmt)?

simpleStmt = ifStmt / ...

stmt = IND{&gt;} stmt ^+ IND{=} DED  # list of statements
     / simpleStmt                 # or a simple statement</pre>
</p>

<h2><a class="toc-backref" id="comments" href="#comments">Comments</a></h2><p>Comments start anywhere outside a string or character literal with the hash character <tt class="docutils literal"><span class="pre">#</span></tt>. Comments consist of a concatenation of <span id="comment-pieces_1">comment pieces</span>. A comment piece starts with <tt class="docutils literal"><span class="pre">#</span></tt> and runs until the end of the line. The end of line characters belong to the piece. If the next line only consists of a comment piece with no other tokens between it and the preceding one, it does not start a new comment:</p>
<pre><span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>     <span class="Comment"># This is a single comment over multiple lines.</span>
  <span class="Comment"># The scanner merges these two pieces.</span>
  <span class="Comment"># The comment continues here.</span></pre><p><span id="documentation-comments_1">Documentation comments</span> are comments that start with two <tt class="docutils literal"><span class="pre">##</span></tt>. Documentation comments are tokens; they are only allowed at certain places in the input file as they belong to the syntax tree!</p>

<h2><a class="toc-backref" id="identifiers-keywords" href="#identifiers-keywords">Identifiers &amp; Keywords</a></h2><p>Identifiers in Nim can be any string of letters, digits and underscores, beginning with a letter. Two immediate following underscores <tt class="docutils literal"><span class="pre">__</span></tt> are not allowed:<pre>
letter ::= 'A'..'Z' | 'a'..'z' | '\x80'..'\xff'
digit ::= '0'..'9'
IDENTIFIER ::= letter ( ['_'] (letter | digit) )*</pre>
</p>
<p>Currently any unicode character with an ordinal value &gt; 127 (non ASCII) is classified as a <tt class="docutils literal"><span class="pre">letter</span></tt> and may thus be part of an identifier but later versions of the language may assign some Unicode characters to belong to the operator characters instead.</p>
<p>The following keywords are reserved and cannot be used as identifiers:</p>
<pre><span class="Keyword">addr</span> <span class="Keyword">and</span> <span class="Keyword">as</span> <span class="Keyword">asm</span> <span class="Keyword">atomic</span>
<span class="Keyword">bind</span> <span class="Keyword">block</span> <span class="Keyword">break</span>
<span class="Keyword">case</span> <span class="Keyword">cast</span> <span class="Keyword">const</span> <span class="Keyword">continue</span> <span class="Keyword">converter</span>
<span class="Keyword">defer</span> <span class="Keyword">discard</span> <span class="Keyword">distinct</span> <span class="Keyword">div</span> <span class="Keyword">do</span>
<span class="Keyword">elif</span> <span class="Keyword">else</span> <span class="Keyword">end</span> <span class="Keyword">enum</span> <span class="Keyword">except</span> <span class="Keyword">export</span>
<span class="Keyword">finally</span> <span class="Keyword">for</span> <span class="Keyword">from</span> <span class="Keyword">func</span>
<span class="Keyword">generic</span>
<span class="Keyword">if</span> <span class="Keyword">import</span> <span class="Keyword">in</span> <span class="Keyword">include</span> <span class="Keyword">interface</span> <span class="Keyword">is</span> <span class="Keyword">isnot</span> <span class="Keyword">iterator</span>
<span class="Keyword">let</span>
<span class="Keyword">macro</span> <span class="Keyword">method</span> <span class="Keyword">mixin</span> <span class="Keyword">mod</span>
<span class="Keyword">nil</span> <span class="Keyword">not</span> <span class="Keyword">notin</span>
<span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Keyword">or</span> <span class="Keyword">out</span>
<span class="Keyword">proc</span> <span class="Keyword">ptr</span>
<span class="Keyword">raise</span> <span class="Keyword">ref</span> <span class="Keyword">return</span>
<span class="Keyword">shl</span> <span class="Keyword">shr</span> <span class="Keyword">static</span>
<span class="Keyword">template</span> <span class="Keyword">try</span> <span class="Keyword">tuple</span> <span class="Keyword">type</span>
<span class="Keyword">using</span>
<span class="Keyword">var</span>
<span class="Keyword">when</span> <span class="Keyword">while</span> <span class="Keyword">with</span> <span class="Keyword">without</span>
<span class="Keyword">xor</span>
<span class="Keyword">yield</span>
</pre><p>Some keywords are unused; they are reserved for future developments of the language.</p>

<h2><a class="toc-backref" id="identifier-equality" href="#identifier-equality">Identifier equality</a></h2><p>Two identifiers are considered equal if the following algorithm returns true:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">sameIdentifier</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Keyword">and</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">replace</span><span class="Punctuation">(</span><span class="StringLit">&quot;_&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">toLower</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">replace</span><span class="Punctuation">(</span><span class="StringLit">&quot;_&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">toLower</span></pre><p>That means only the first letters are compared in a case sensitive manner. Other letters are compared case insensitively and underscores are ignored.</p>
<p>This rather strange way to do identifier comparisons is called <span id="partial-case-insensitivity_1">partial case insensitivity</span> and has some advantages over the conventional case sensitivity:</p>
<p>It allows programmers to mostly use their own preferred spelling style and libraries written by different programmers cannot use incompatible conventions. A Nim-aware editor or IDE can show the identifiers as preferred. Another advantage is that it frees the programmer from remembering the exact spelling of an identifier. The exception with respect to the first letter allows common code like <tt class="docutils literal"><span class="pre">var foo: Foo</span></tt> to be parsed unambiguously.</p>
<p>Historically, Nim was a <span id="style-insensitive_1">style-insensitive</span> language. This means that it was not case-sensitive and underscores were ignored and there was no distinction between <tt class="docutils literal"><span class="pre">foo</span></tt> and <tt class="docutils literal"><span class="pre">Foo</span></tt>.</p>

<h2><a class="toc-backref" id="string-literals" href="#string-literals">String literals</a></h2><p>Terminal symbol in the grammar: <tt class="docutils literal"><span class="pre">STR_LIT</span></tt>.</p>
<p>String literals can be delimited by matching double quotes, and can contain the following <span id="escape-sequences_1">escape sequences</span>:</p>
<table border="1" class="docutils"><tr><th>Escape sequence</th><th>Meaning</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">\n</span></tt></td><td><span id="newline_1">newline</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\r</span></tt>, <tt class="docutils literal"><span class="pre">\c</span></tt></td><td><span id="carriage-return_1">carriage return</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\l</span></tt></td><td><span id="line-feed_1">line feed</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\f</span></tt></td><td><span id="form-feed_1">form feed</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\t</span></tt></td><td><span id="tabulator_1">tabulator</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\v</span></tt></td><td><span id="vertical-tabulator_1">vertical tabulator</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\\</span></tt></td><td><span id="backslash_1">backslash</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\&quot;</span></tt></td><td><span id="quotation-mark_1">quotation mark</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\'</span></tt></td><td><span id="apostrophe_1">apostrophe</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\</span></tt> '0'..'9'+</td><td><span id="character-with-decimal-value-d_1">character with decimal value d</span>; all decimal digits directly following are used for the character</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\a</span></tt></td><td><span id="alert_1">alert</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\b</span></tt></td><td><span id="backspace_1">backspace</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\e</span></tt></td><td><span id="escape_1">escape</span> <span id="esc_1">[ESC]</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\x</span></tt> HH</td><td><span id="character-with-hex-value-hh_1">character with hex value HH</span>; exactly two hex digits are allowed</td></tr>
</table><p>Strings in Nim may contain any 8-bit value, even embedded zeros. However some operations may interpret the first binary zero as a terminator.</p>

<h2><a class="toc-backref" id="triple-quoted-string-literals" href="#triple-quoted-string-literals">Triple quoted string literals</a></h2><p>Terminal symbol in the grammar: <tt class="docutils literal"><span class="pre">TRIPLESTR_LIT</span></tt>.</p>
<p>String literals can also be delimited by three double quotes <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> ... <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt>. Literals in this form may run for several lines, may contain <tt class="docutils literal"><span class="pre">&quot;</span></tt> and do not interpret any escape sequences. For convenience, when the opening <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> is followed by a newline (there may be whitespace between the opening <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> and the newline), the newline (and the preceding whitespace) is not included in the string. The ending of the string literal is defined by the pattern <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;[^&quot;]</span></tt>, so this:</p>
<pre><span class="LongStringLit">&quot;&quot;&quot;&quot;long string within quotes&quot;&quot;&quot;&quot;</span></pre><p>Produces:<pre>
&quot;long string within quotes&quot;</pre>
</p>

<h2><a class="toc-backref" id="raw-string-literals" href="#raw-string-literals">Raw string literals</a></h2><p>Terminal symbol in the grammar: <tt class="docutils literal"><span class="pre">RSTR_LIT</span></tt>.</p>
<p>There are also raw string literals that are preceded with the letter <tt class="docutils literal"><span class="pre">r</span></tt> (or <tt class="docutils literal"><span class="pre">R</span></tt>) and are delimited by matching double quotes (just like ordinary string literals) and do not interpret the escape sequences. This is especially convenient for regular expressions or Windows paths:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">openFile</span><span class="Punctuation">(</span><span class="RawData">r&quot;C:\texts\text.txt&quot;</span><span class="Punctuation">)</span> <span class="Comment"># a raw string, so ``\t`` is no tab</span></pre><p>To produce a single <tt class="docutils literal"><span class="pre">&quot;</span></tt> within a raw string literal, it has to be doubled:</p>
<pre><span class="RawData">r&quot;a&quot;&quot;</span><span class="RawData">b&quot;</span></pre><p>Produces:<pre>
a&quot;b</pre>
</p>
<p><tt class="docutils literal"><span class="pre">r&quot;&quot;&quot;&quot;</span></tt> is not possible with this notation, because the three leading quotes introduce a triple quoted string literal. <tt class="docutils literal"><span class="pre">r&quot;&quot;&quot;</span></tt> is the same as <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> since triple quoted string literals do not interpret escape sequences either.</p>

<h2><a class="toc-backref" id="generalized-raw-string-literals" href="#generalized-raw-string-literals">Generalized raw string literals</a></h2><p>Terminal symbols in the grammar: <tt class="docutils literal"><span class="pre">GENERALIZED_STR_LIT</span></tt>, <tt class="docutils literal"><span class="pre">GENERALIZED_TRIPLESTR_LIT</span></tt>.</p>
<p>The construct <tt class="docutils literal"><span class="pre">identifier&quot;string literal&quot;</span></tt> (without whitespace between the identifier and the opening quotation mark) is a generalized raw string literal. It is a shortcut for the construct <tt class="docutils literal"><span class="pre">identifier(r&quot;string literal&quot;)</span></tt>, so it denotes a procedure call with a raw string literal as its only argument. Generalized raw string literals are especially convenient for embedding mini languages directly into Nim (for example regular expressions).</p>
<p>The construct <tt class="docutils literal"><span class="pre">identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;</span></tt> exists too. It is a shortcut for <tt class="docutils literal"><span class="pre">identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)</span></tt>.</p>

<h2><a class="toc-backref" id="character-literals" href="#character-literals">Character literals</a></h2><p>Character literals are enclosed in single quotes <tt class="docutils literal"><span class="pre">''</span></tt> and can contain the same escape sequences as strings - with one exception: <span id="newline_2">newline</span> (<tt class="docutils literal"><span class="pre">\n</span></tt>) is not allowed as it may be wider than one character (often it is the pair CR/LF for example).  Here are the valid <span id="escape-sequences_2">escape sequences</span> for character literals:</p>
<table border="1" class="docutils"><tr><th>Escape sequence</th><th>Meaning</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">\r</span></tt>, <tt class="docutils literal"><span class="pre">\c</span></tt></td><td><span id="carriage-return_2">carriage return</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\l</span></tt></td><td><span id="line-feed_2">line feed</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\f</span></tt></td><td><span id="form-feed_2">form feed</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\t</span></tt></td><td><span id="tabulator_2">tabulator</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\v</span></tt></td><td><span id="vertical-tabulator_2">vertical tabulator</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\\</span></tt></td><td><span id="backslash_2">backslash</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\&quot;</span></tt></td><td><span id="quotation-mark_2">quotation mark</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\'</span></tt></td><td><span id="apostrophe_2">apostrophe</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\</span></tt> '0'..'9'+</td><td><span id="character-with-decimal-value-d_2">character with decimal value d</span>; all decimal digits directly following are used for the character</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\a</span></tt></td><td><span id="alert_2">alert</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\b</span></tt></td><td><span id="backspace_2">backspace</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\e</span></tt></td><td><span id="escape_2">escape</span> <span id="esc_2">[ESC]</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\x</span></tt> HH</td><td><span id="character-with-hex-value-hh_2">character with hex value HH</span>; exactly two hex digits are allowed</td></tr>
</table><p>A character is not an Unicode character but a single byte. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can thus support <tt class="docutils literal"><span class="pre">array[char, int]</span></tt> or <tt class="docutils literal"><span class="pre">set[char]</span></tt> efficiently as many algorithms rely on this feature.  The <cite>Rune</cite> type is used for Unicode characters, it can represent any Unicode character. <tt class="docutils literal"><span class="pre">Rune</span></tt> is declared in the <a class="reference external" href="unicode.html">unicode module</a>.</p>

<h2><a class="toc-backref" id="numerical-constants" href="#numerical-constants">Numerical constants</a></h2><p>Numerical constants are of a single type and have the form:<pre>
hexdigit = digit | 'A'..'F' | 'a'..'f'
octdigit = '0'..'7'
bindigit = '0'..'1'
HEX_LIT = '0' ('x' | 'X' ) hexdigit ( ['_'] hexdigit )*
DEC_LIT = digit ( ['_'] digit )*
OCT_LIT = '0o' octdigit ( ['_'] octdigit )*
BIN_LIT = '0' ('b' | 'B' ) bindigit ( ['_'] bindigit )*

INT_LIT = HEX_LIT
        | DEC_LIT
        | OCT_LIT
        | BIN_LIT

INT8_LIT = INT_LIT ['\''] ('i' | 'I') '8'
INT16_LIT = INT_LIT ['\''] ('i' | 'I') '16'
INT32_LIT = INT_LIT ['\''] ('i' | 'I') '32'
INT64_LIT = INT_LIT ['\''] ('i' | 'I') '64'

UINT8_LIT = INT_LIT ['\''] ('u' | 'U')
UINT8_LIT = INT_LIT ['\''] ('u' | 'U') '8'
UINT16_LIT = INT_LIT ['\''] ('u' | 'U') '16'
UINT32_LIT = INT_LIT ['\''] ('u' | 'U') '32'
UINT64_LIT = INT_LIT ['\''] ('u' | 'U') '64'

exponent = ('e' | 'E' ) ['+' | '-'] digit ( ['_'] digit )*
FLOAT_LIT = digit (['_'] digit)* (('.' (['_'] digit)* [exponent]) |exponent)
FLOAT32_LIT = HEX_LIT '\'' ('f'|'F') '32'
            | (FLOAT_LIT | DEC_LIT | OCT_LIT | BIN_LIT) ['\''] ('f'|'F') '32'
FLOAT64_LIT = HEX_LIT '\'' ('f'|'F') '64'
            | (FLOAT_LIT | DEC_LIT | OCT_LIT | BIN_LIT) ['\''] ('f'|'F') '64'</pre>
</p>
<p>As can be seen in the productions, numerical constants can contain underscores for readability. Integer and floating point literals may be given in decimal (no prefix), binary (prefix <tt class="docutils literal"><span class="pre">0b</span></tt>), octal (prefix <tt class="docutils literal"><span class="pre">0o</span></tt>) and hexadecimal (prefix <tt class="docutils literal"><span class="pre">0x</span></tt>) notation.</p>
<p>There exists a literal for each numerical type that is defined. The suffix starting with an apostrophe (''') is called a <span id="type-suffix_1">type suffix</span>. Literals without a type suffix are of the type <tt class="docutils literal"><span class="pre">int</span></tt>, unless the literal contains a dot or <tt class="docutils literal"><span class="pre">E|e</span></tt> in which case it is of type <tt class="docutils literal"><span class="pre">float</span></tt>. For notational convenience the apostrophe of a type suffix is optional if it is not ambiguous (only hexadecimal floating point literals with a type suffix can be ambiguous).</p>
<p>The type suffixes are:</p>
<table border="1" class="docutils"><tr><th>Type Suffix</th><th>Resulting type of literal</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i8</span></tt></td><td>int8</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i16</span></tt></td><td>int16</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i32</span></tt></td><td>int32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'i64</span></tt></td><td>int64</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u</span></tt></td><td>uint</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u8</span></tt></td><td>uint8</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u16</span></tt></td><td>uint16</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u32</span></tt></td><td>uint32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'u64</span></tt></td><td>uint64</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'f32</span></tt></td><td>float32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">'f64</span></tt></td><td>float64</td></tr>
</table><p>Floating point literals may also be in binary, octal or hexadecimal notation: <tt class="docutils literal"><span class="pre">0B0_10001110100_0000101001000111101011101111111011000101001101001001'f64</span></tt> is approximately 1.72826e35 according to the IEEE floating point standard.</p>

<h2><a class="toc-backref" id="operators" href="#operators">Operators</a></h2><p>In Nim one can define his own operators. An operator is any combination of the following characters:<pre>
=     +     -     *     /     &lt;     &gt;
@     $     ~     &amp;     %     |
!     ?     ^     .     :     \</pre>
</p>
<p>These keywords are also operators: <tt class="docutils literal"><span class="pre">and or not xor shl shr div mod in notin is isnot of</span></tt>.</p>
<p><span class="tok">=</span>, <span class="tok">:</span>, <span class="tok">::</span> are not available as general operators; they are used for other notational purposes.</p>
<p><tt class="docutils literal"><span class="pre">*:</span></tt> is as a special case the two tokens <span class="tok">*</span> and <span class="tok">:</span> (to support <tt class="docutils literal"><span class="pre">var v*: T</span></tt>).</p>

<h2><a class="toc-backref" id="other-tokens" href="#other-tokens">Other tokens</a></h2><p>The following strings denote other tokens:<pre>
`   (     )     {     }     [     ]     ,  ;   [.    .]  {.   .}  (.  .)</pre>
</p>
<p>The <span id="slice_1">slice</span> operator <span class="tok">..</span> takes precedence over other tokens that contain a dot: <span class="tok">{..}</span> are the three tokens <span class="tok">{</span>, <span class="tok">..</span>, <span class="tok">}</span> and not the two tokens <span class="tok">{.</span>, <span class="tok">.}</span>.</p>

<h1><a class="toc-backref" id="syntax" href="#syntax">Syntax</a></h1><p>This section lists Nim's standard syntax. How the parser handles the indentation is already described in the <a class="reference external" href="#lexical-analysis">Lexical Analysis</a> section.</p>
<p>Nim allows user-definable operators. Binary operators have 11 different levels of precedence.</p>

<h2><a class="toc-backref" id="associativity" href="#associativity">Associativity</a></h2><p>Binary operators whose first character is <tt class="docutils literal"><span class="pre">^</span></tt> are right-associative, all other binary operators are left-associative.</p>
<p>Operators ending in <tt class="docutils literal"><span class="pre">&gt;</span></tt> but longer than a single character are called <span id="arrow-like_1">arrow like</span>.</p>

<h2><a class="toc-backref" id="precedence" href="#precedence">Precedence</a></h2><p>Unary operators always bind stronger than any binary operator: <tt class="docutils literal"><span class="pre">$a + b</span></tt> is <tt class="docutils literal"><span class="pre">($a) + b</span></tt> and not <tt class="docutils literal"><span class="pre">$(a + b)</span></tt>.</p>
<p>If an unary operator's first character is <tt class="docutils literal"><span class="pre">@</span></tt> it is a <span id="sigil-like_1">sigil-like</span> operator which binds stronger than a <tt class="docutils literal"><span class="pre">primarySuffix</span></tt>: <tt class="docutils literal"><span class="pre">@x.abc</span></tt> is parsed as <tt class="docutils literal"><span class="pre">(@x).abc</span></tt> whereas <tt class="docutils literal"><span class="pre">$x.abc</span></tt> is parsed as <tt class="docutils literal"><span class="pre">$(x.abc)</span></tt>.</p>
<p>For binary operators that are not keywords the precedence is determined by the following rules:</p>
<p>If the operator ends with <tt class="docutils literal"><span class="pre">=</span></tt> and its first character is none of <tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">!</span></tt>, <tt class="docutils literal"><span class="pre">=</span></tt>, <tt class="docutils literal"><span class="pre">~</span></tt>, <tt class="docutils literal"><span class="pre">?</span></tt>, it is an <em>assignment operator</em> which has the lowest precedence.</p>
<p>Otherwise precedence is determined by the first character.</p>
<table border="1" class="docutils"><tr><th>Precedence level</th><th>Operators</th><th>First character</th><th>Terminal symbol</th></tr>
<tr><td>10 (highest)</td><td></td><td><tt class="docutils literal"><span class="pre">$ ^</span></tt></td><td>OP10</td></tr>
<tr><td>9</td><td><tt class="docutils literal"><span class="pre">* / div mod shl shr %</span></tt></td><td><tt class="docutils literal"><span class="pre">* % \ /</span></tt></td><td>OP9</td></tr>
<tr><td>8</td><td><tt class="docutils literal"><span class="pre">+ -</span></tt></td><td><tt class="docutils literal"><span class="pre">+ ~ |</span></tt></td><td>OP8</td></tr>
<tr><td>7</td><td><tt class="docutils literal"><span class="pre">&amp;</span></tt></td><td><tt class="docutils literal"><span class="pre">&amp;</span></tt></td><td>OP7</td></tr>
<tr><td>6</td><td><tt class="docutils literal"><span class="pre">..</span></tt></td><td><tt class="docutils literal"><span class="pre">.</span></tt></td><td>OP6</td></tr>
<tr><td>5</td><td><tt class="docutils literal"><span class="pre">== &lt;= &lt; &gt;= &gt; != in notin is isnot not of</span></tt></td><td><tt class="docutils literal"><span class="pre">= &lt; &gt; !</span></tt></td><td>OP5</td></tr>
<tr><td>4</td><td><tt class="docutils literal"><span class="pre">and</span></tt></td><td></td><td>OP4</td></tr>
<tr><td>3</td><td><tt class="docutils literal"><span class="pre">or xor</span></tt></td><td></td><td>OP3</td></tr>
<tr><td>2</td><td></td><td><tt class="docutils literal"><span class="pre">@ : ?</span></tt></td><td>OP2</td></tr>
<tr><td>1</td><td><em>assignment operator</em> (like <tt class="docutils literal"><span class="pre">+=</span></tt>, <tt class="docutils literal"><span class="pre">*=</span></tt>)</td><td></td><td>OP1</td></tr>
<tr><td>0 (lowest)</td><td><em>arrow like operator</em> (like <tt class="docutils literal"><span class="pre">-&gt;</span></tt>, <tt class="docutils literal"><span class="pre">=&gt;</span></tt>)</td><td></td><td>OP0</td></tr>
</table>
<h2><a class="toc-backref" id="strong-spaces" href="#strong-spaces">Strong spaces</a></h2><p>The number of spaces preceding a non-keyword operator affects precedence if the experimental parser directive <tt class="docutils literal"><span class="pre">#!strongSpaces</span></tt> is used. Indentation is not used to determine the number of spaces. If 2 or more operators have the same number of preceding spaces the precedence table applies, so <tt class="docutils literal"><span class="pre">1 + 3 * 4</span></tt> is still parsed as <tt class="docutils literal"><span class="pre">1 + (3 * 4)</span></tt>, but <tt class="docutils literal"><span class="pre">1+3 * 4</span></tt> is parsed as <tt class="docutils literal"><span class="pre">(1+3) * 4</span></tt>:</p>
<pre><span class="Comment">#! strongSpaces</span>
<span class="Keyword">if</span> <span class="Identifier">foo</span><span class="Operator">+</span><span class="DecNumber">4</span> <span class="Operator">*</span> <span class="DecNumber">4</span> <span class="Operator">==</span> <span class="DecNumber">8</span> <span class="Keyword">and</span> <span class="Identifier">b</span><span class="Operator">&amp;</span><span class="Identifier">c</span> <span class="Operator">|</span> <span class="DecNumber">9</span>  <span class="Operator">++</span>
    <span class="Identifier">bar</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;&quot;</span>
<span class="Comment"># is parsed as</span>
<span class="Keyword">if</span> <span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">foo</span><span class="Operator">+</span><span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Operator">*</span><span class="DecNumber">4</span> <span class="Operator">==</span> <span class="DecNumber">8</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Operator">&amp;</span><span class="Identifier">c</span><span class="Punctuation">)</span> <span class="Operator">|</span> <span class="DecNumber">9</span><span class="Punctuation">)</span> <span class="Operator">++</span> <span class="Identifier">bar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;&quot;</span></pre><p>Furthermore whether an operator is used a prefix operator is affected by the number of spaces:</p>
<pre><span class="Comment">#! strongSpaces</span>
<span class="Identifier">echo</span> <span class="Operator">$</span><span class="Identifier">foo</span>
<span class="Comment"># is parsed as</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">foo</span><span class="Punctuation">)</span></pre><p>This also affects whether <tt class="docutils literal"><span class="pre">[]</span></tt>, <tt class="docutils literal"><span class="pre">{}</span></tt>, <tt class="docutils literal"><span class="pre">()</span></tt> are parsed as constructors or as accessors:</p>
<pre><span class="Comment">#! strongSpaces</span>
<span class="Identifier">echo</span> <span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">)</span>
<span class="Comment"># is parsed as</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>Only 0, 1, 2, 4 or 8 spaces are allowed to specify precedence and it is enforced that infix operators have the same amount of spaces before and after them. This rules does not apply when a newline follows after the operator, then only the preceding spaces are considered.</p>

<h2><a class="toc-backref" id="grammar" href="#grammar">Grammar</a></h2><p>The grammar's start symbol is <tt class="docutils literal"><span class="pre">module</span></tt>.</p>
<pre>module = stmt ^* (';' / IND{=})
comma = ',' COMMENT?
semicolon = ';' COMMENT?
colon = ':' COMMENT?
colcom = ':' COMMENT?

operator =  OP0 | OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9 | OP10
         | 'or' | 'xor' | 'and'
         | 'is' | 'isnot' | 'in' | 'notin' | 'of'
         | 'div' | 'mod' | 'shl' | 'shr' | 'not' | 'addr' | 'static' | '..'

prefixOperator = operator

optInd = COMMENT?
optPar = (IND{&gt;} | IND{=})?

simpleExpr = arrowExpr (OP0 optInd arrowExpr)*
arrowExpr = assignExpr (OP1 optInd assignExpr)*
assignExpr = orExpr (OP2 optInd orExpr)*
orExpr = andExpr (OP3 optInd andExpr)*
andExpr = cmpExpr (OP4 optInd cmpExpr)*
cmpExpr = sliceExpr (OP5 optInd sliceExpr)*
sliceExpr = ampExpr (OP6 optInd ampExpr)*
ampExpr = plusExpr (OP7 optInd plusExpr)*
plusExpr = mulExpr (OP8 optInd mulExpr)*
mulExpr = dollarExpr (OP9 optInd dollarExpr)*
dollarExpr = primary (OP10 optInd primary)*
symbol = '`' (KEYW|IDENT|literal|(operator|'('|')'|'['|']'|'{'|'}'|'=')+)+ '`'
       | IDENT
indexExpr = expr
indexExprList = indexExpr ^+ comma
exprColonEqExpr = expr (':'|'=' expr)?
exprList = expr ^+ comma
dotExpr = expr '.' optInd ('type' | 'addr' | symbol)
qualifiedIdent = symbol ('.' optInd ('type' | 'addr' | symbol))?
exprColonEqExprList = exprColonEqExpr (comma exprColonEqExpr)* (comma)?
setOrTableConstr = '{' ((exprColonEqExpr comma)* | ':' ) '}'
castExpr = 'cast' '[' optInd typeDesc optPar ']' '(' optInd expr optPar ')'
parKeyw = 'discard' | 'include' | 'if' | 'while' | 'case' | 'try'
        | 'finally' | 'except' | 'for' | 'block' | 'const' | 'let'
        | 'when' | 'var' | 'mixin'
par = '(' optInd (&amp;parKeyw complexOrSimpleStmt ^+ ';' 
                 | simpleExpr ('=' expr (';' complexOrSimpleStmt ^+ ';' )? )?
                            | (':' expr)? (',' (exprColonEqExpr comma?)*)?  )?
        optPar ')'
literal = | INT_LIT | INT8_LIT | INT16_LIT | INT32_LIT | INT64_LIT
          | UINT_LIT | UINT8_LIT | UINT16_LIT | UINT32_LIT | UINT64_LIT
          | FLOAT_LIT | FLOAT32_LIT | FLOAT64_LIT
          | STR_LIT | RSTR_LIT | TRIPLESTR_LIT
          | CHAR_LIT
          | NIL
generalizedLit = GENERALIZED_STR_LIT | GENERALIZED_TRIPLESTR_LIT
identOrLiteral = generalizedLit | symbol | literal
               | par | arrayConstr | setOrTableConstr
               | castExpr
tupleConstr = '(' optInd (exprColonEqExpr comma?)* optPar ')'
arrayConstr = '[' optInd (exprColonEqExpr comma?)* optPar ']'
primarySuffix = '(' (exprColonEqExpr comma?)* ')' doBlocks?
              | doBlocks
              | '.' optInd ('type' | 'addr' | symbol) generalizedLit?
              | '[' optInd indexExprList optPar ']'
              | '{' optInd indexExprList optPar '}'
              | &amp;( '`'|IDENT|literal|'cast') expr # command syntax
condExpr = expr colcom expr optInd
        ('elif' expr colcom expr optInd)*
         'else' colcom expr
ifExpr = 'if' condExpr
whenExpr = 'when' condExpr
pragma = '{.' optInd (exprColonExpr comma?)* optPar ('.}' | '}')
identVis = symbol opr?  # postfix position
identWithPragma = identVis pragma?
declColonEquals = identWithPragma (comma identWithPragma)* comma?
                  (':' optInd typeDesc)? ('=' optInd expr)?
identColonEquals = ident (comma ident)* comma?
     (':' optInd typeDesc)? ('=' optInd expr)?)
inlTupleDecl = 'tuple'
    [' optInd  (identColonEquals (comma/semicolon)?)*  optPar ']'
extTupleDecl = 'tuple'
    COMMENT? (IND{&gt;} identColonEquals (IND{=} identColonEquals)*)?
paramList = '(' declColonEquals ^* (comma/semicolon) ')'
paramListArrow = paramList? ('-&gt;' optInd typeDesc)?
paramListColon = paramList? (':' optInd typeDesc)?
doBlock = 'do' paramListArrow pragmas? colcom stmt
doBlocks = doBlock ^* IND{=}
procExpr = 'proc' paramListColon pragmas? ('=' COMMENT? stmt)?
distinct = 'distinct' optInd typeDesc
expr = (ifExpr
      | whenExpr
      | caseExpr
      | tryExpr)
      / simpleExpr
typeKeyw = 'var' | 'ref' | 'ptr' | 'shared' | 'type' | 'tuple'
         | 'proc' | 'iterator' | 'distinct' | 'object' | 'enum'
primary = typeKeyw typeDescK
        /  prefixOperator* identOrLiteral primarySuffix*
        / 'addr' primary
        / 'static' primary
        / 'bind' primary
typeDesc = simpleExpr
typeDefAux = simpleExpr
           | 'generic' typeClass
macroColon = ':' stmt? ( IND{=} 'of' exprList ':' stmt 
                       | IND{=} 'elif' expr ':' stmt
                       | IND{=} 'except' exprList ':' stmt
                       | IND{=} 'else' ':' stmt )*
exprStmt = simpleExpr
         (( '=' optInd expr )
         / ( expr ^+ comma
             doBlocks
              / macroColon
           ))?
importStmt = 'import' optInd expr
              ((comma expr)*
              / 'except' optInd (expr ^+ comma))
includeStmt = 'include' optInd expr ^+ comma
fromStmt = 'from' moduleName 'import' optInd expr (comma expr)*
returnStmt = 'return' optInd expr?
raiseStmt = 'raise' optInd expr?
yieldStmt = 'yield' optInd expr?
discardStmt = 'discard' optInd expr?
breakStmt = 'break' optInd expr?
continueStmt = 'break' optInd expr?
condStmt = expr colcom stmt COMMENT?
           (IND{=} 'elif' expr colcom stmt)*
           (IND{=} 'else' colcom stmt)?
ifStmt = 'if' condStmt
whenStmt = 'when' condStmt
whileStmt = 'while' expr colcom stmt
ofBranch = 'of' exprList colcom stmt
ofBranches = ofBranch (IND{=} ofBranch)*
                      (IND{=} 'elif' expr colcom stmt)*
                      (IND{=} 'else' colcom stmt)?
caseStmt = 'case' expr ':'? COMMENT?
            (IND{&gt;} ofBranches DED
            | IND{=} ofBranches)
tryStmt = 'try' colcom stmt &amp;(IND{=}? 'except'|'finally')
           (IND{=}? 'except' exprList colcom stmt)*
           (IND{=}? 'finally' colcom stmt)?
tryExpr = 'try' colcom stmt &amp;(optInd 'except'|'finally')
           (optInd 'except' exprList colcom stmt)*
           (optInd 'finally' colcom stmt)?
exceptBlock = 'except' colcom stmt
forStmt = 'for' (identWithPragma ^+ comma) 'in' expr colcom stmt
blockStmt = 'block' symbol? colcom stmt
staticStmt = 'static' colcom stmt
deferStmt = 'defer' colcom stmt
asmStmt = 'asm' pragma? (STR_LIT | RSTR_LIT | TRIPLE_STR_LIT)
genericParam = symbol (comma symbol)* (colon expr)? ('=' optInd expr)?
genericParamList = '[' optInd
  genericParam ^* (comma/semicolon) optPar ']'
pattern = '{' stmt '}'
indAndComment = (IND{&gt;} COMMENT)? | COMMENT?
routine = optInd identVis pattern? genericParamList?
  paramListColon pragma? ('=' COMMENT? stmt)? indAndComment
commentStmt = COMMENT
section(p) = COMMENT? p / (IND{&gt;} (p / COMMENT)^+IND{=} DED)
constant = identWithPragma (colon typedesc)? '=' optInd expr indAndComment
enum = 'enum' optInd (symbol optInd ('=' optInd expr COMMENT?)? comma?)+
objectWhen = 'when' expr colcom objectPart COMMENT?
            ('elif' expr colcom objectPart COMMENT?)*
            ('else' colcom objectPart COMMENT?)?
objectBranch = 'of' exprList colcom objectPart
objectBranches = objectBranch (IND{=} objectBranch)*
                      (IND{=} 'elif' expr colcom objectPart)*
                      (IND{=} 'else' colcom objectPart)?
objectCase = 'case' identWithPragma ':' typeDesc ':'? COMMENT?
            (IND{&gt;} objectBranches DED
            | IND{=} objectBranches)
objectPart = IND{&gt;} objectPart^+IND{=} DED
           / objectWhen / objectCase / 'nil' / 'discard' / declColonEquals
object = 'object' pragma? ('of' typeDesc)? COMMENT? objectPart
typeClassParam = ('var')? symbol
typeClass = typeClassParam ^* ',' (pragma)? ('of' typeDesc ^* ',')?
              &amp;IND{&gt;} stmt
typeDef = identWithPragma genericParamList? '=' optInd typeDefAux
            indAndComment?
varTuple = '(' optInd identWithPragma ^+ comma optPar ')' '=' optInd expr
variable = (varTuple / identColonEquals) indAndComment
bindStmt = 'bind' optInd qualifiedIdent ^+ comma
mixinStmt = 'mixin' optInd qualifiedIdent ^+ comma
pragmaStmt = pragma (':' COMMENT? stmt)?
simpleStmt = ((returnStmt | raiseStmt | yieldStmt | discardStmt | breakStmt
           | continueStmt | pragmaStmt | importStmt | exportStmt | fromStmt
           | includeStmt | commentStmt) / exprStmt) COMMENT?
complexOrSimpleStmt = (ifStmt | whenStmt | whileStmt
                    | tryStmt | finallyStmt | exceptStmt | forStmt
                    | blockStmt | staticStmt | deferStmt | asmStmt
                    | 'proc' routine
                    | 'method' routine
                    | 'iterator' routine
                    | 'macro' routine
                    | 'template' routine
                    | 'converter' routine
                    | 'type' section(typeDef)
                    | 'const' section(constant)
                    | ('let' | 'var') section(variable)
                    | bindStmt | mixinStmt)
                    / simpleStmt
stmt = (IND{&gt;} complexOrSimpleStmt^+(IND{=} / ';') DED)
     / simpleStmt ^+ ';'
</pre>

<h1><a class="toc-backref" id="types" href="#types">Types</a></h1><p>All expressions have a type which is known at compile time. Nim is statically typed. One can declare new types, which is in essence defining an identifier that can be used to denote this custom type.</p>
<p>These are the major type classes:</p>
<ul class="simple"><li>ordinal types (consist of integer, bool, character, enumeration (and subranges thereof) types)</li>
<li>floating point types</li>
<li>string type</li>
<li>structured types</li>
<li>reference (pointer) type</li>
<li>procedural type</li>
<li>generic type</li>
</ul>

<h2><a class="toc-backref" id="ordinal-types" href="#ordinal-types">Ordinal types</a></h2><p>Ordinal types have the following characteristics:</p>
<ul class="simple"><li>Ordinal types are countable and ordered. This property allows the operation of functions as <tt class="docutils literal"><span class="pre">inc</span></tt>, <tt class="docutils literal"><span class="pre">ord</span></tt>, <tt class="docutils literal"><span class="pre">dec</span></tt> on ordinal types to be defined.</li>
<li>Ordinal values have a smallest possible value. Trying to count further down than the smallest value gives a checked runtime or static error.</li>
<li>Ordinal values have a largest possible value. Trying to count further than the largest value gives a checked runtime or static error.</li>
</ul>
<p>Integers, bool, characters and enumeration types (and subranges of these types) belong to ordinal types. For reasons of simplicity of implementation the types <tt class="docutils literal"><span class="pre">uint</span></tt> and <tt class="docutils literal"><span class="pre">uint64</span></tt> are not ordinal types.</p>

<h2><a class="toc-backref" id="pre-defined-integer-types" href="#pre-defined-integer-types">Pre-defined integer types</a></h2><p>These integer types are pre-defined:</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">int</span></tt></dt>
<dd>the generic signed integer type; its size is platform dependent and has the same size as a pointer. This type should be used in general. An integer literal that has no type suffix is of this type.</dd>
<dt>intXX</dt>
<dd>additional signed integer types of XX bits use this naming scheme (example: int16 is a 16 bit wide integer). The current implementation supports <tt class="docutils literal"><span class="pre">int8</span></tt>, <tt class="docutils literal"><span class="pre">int16</span></tt>, <tt class="docutils literal"><span class="pre">int32</span></tt>, <tt class="docutils literal"><span class="pre">int64</span></tt>. Literals of these types have the suffix 'iXX.</dd>
<dt><tt class="docutils literal"><span class="pre">uint</span></tt></dt>
<dd>the generic <span id="unsigned-integer_1">unsigned integer</span> type; its size is platform dependent and has the same size as a pointer. An integer literal with the type suffix <tt class="docutils literal"><span class="pre">'u</span></tt> is of this type.</dd>
<dt>uintXX</dt>
<dd>additional signed integer types of XX bits use this naming scheme (example: uint16 is a 16 bit wide unsigned integer). The current implementation supports <tt class="docutils literal"><span class="pre">uint8</span></tt>, <tt class="docutils literal"><span class="pre">uint16</span></tt>, <tt class="docutils literal"><span class="pre">uint32</span></tt>, <tt class="docutils literal"><span class="pre">uint64</span></tt>. Literals of these types have the suffix 'uXX. Unsigned operations all wrap around; they cannot lead to over- or underflow errors.</dd>
</dl>
<p>In addition to the usual arithmetic operators for signed and unsigned integers (<tt class="docutils literal"><span class="pre">+ - *</span></tt> etc.) there are also operators that formally work on <em>signed</em> integers but treat their arguments as <em>unsigned</em>: They are mostly provided for backwards compatibility with older versions of the language that lacked unsigned integer types. These unsigned operations for signed integers use the <tt class="docutils literal"><span class="pre">%</span></tt> suffix as convention:</p>
<table border="1" class="docutils"><tr><th>operation</th><th>meaning</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">a +% b</span></tt></td><td>unsigned integer addition</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a -% b</span></tt></td><td>unsigned integer subtraction</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a *% b</span></tt></td><td>unsigned integer multiplication</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a /% b</span></tt></td><td>unsigned integer division</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a %% b</span></tt></td><td>unsigned integer modulo operation</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a &lt;% b</span></tt></td><td>treat <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> as unsigned and compare</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">a &lt;=% b</span></tt></td><td>treat <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> as unsigned and compare</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">ze(a)</span></tt></td><td>extends the bits of <tt class="docutils literal"><span class="pre">a</span></tt> with zeros until it has the width of the <tt class="docutils literal"><span class="pre">int</span></tt> type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">toU8(a)</span></tt></td><td>treats <tt class="docutils literal"><span class="pre">a</span></tt> as unsigned and converts it to an unsigned integer of 8 bits (but still the <tt class="docutils literal"><span class="pre">int8</span></tt> type)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">toU16(a)</span></tt></td><td>treats <tt class="docutils literal"><span class="pre">a</span></tt> as unsigned and converts it to an unsigned integer of 16 bits (but still the <tt class="docutils literal"><span class="pre">int16</span></tt> type)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">toU32(a)</span></tt></td><td>treats <tt class="docutils literal"><span class="pre">a</span></tt> as unsigned and converts it to an unsigned integer of 32 bits (but still the <tt class="docutils literal"><span class="pre">int32</span></tt> type)</td></tr>
</table><p><span id="automatic-type-conversion_1">Automatic type conversion</span> is performed in expressions where different kinds of integer types are used: the smaller type is converted to the larger.</p>
<p>A <span id="narrowing-type-conversion_1">narrowing type conversion</span> converts a larger to a smaller type (for example <tt class="docutils literal"><span class="pre">int32 -&gt; int16</span></tt>. A <span id="widening-type-conversion_1">widening type conversion</span> converts a smaller type to a larger type (for example <tt class="docutils literal"><span class="pre">int16 -&gt; int32</span></tt>). In Nim only widening type conversions are <em>implicit</em>:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">myInt16</span> <span class="Operator">=</span> <span class="DecNumber">5</span><span class="Identifier">i16</span>
<span class="Keyword">var</span> <span class="Identifier">myInt</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="DecNumber">34</span>     <span class="Comment"># of type ``int16``</span>
<span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="Identifier">myInt</span>  <span class="Comment"># of type ``int``</span>
<span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="DecNumber">2</span><span class="Identifier">i32</span>   <span class="Comment"># of type ``int32``</span></pre><p>However, <tt class="docutils literal"><span class="pre">int</span></tt> literals are implicitly convertible to a smaller integer type if the literal's value fits this smaller type and such a conversion is less expensive than other implicit conversions, so <tt class="docutils literal"><span class="pre">myInt16 + 34</span></tt> produces an <tt class="docutils literal"><span class="pre">int16</span></tt> result.</p>
<p>For further details, see <a class="reference external" href="#convertible-relation">Convertible relation</a>.</p>

<h2><a class="toc-backref" id="subrange-types" href="#subrange-types">Subrange types</a></h2><p>A subrange type is a range of values from an ordinal type (the base type). To define a subrange type, one must specify it's limiting values: the lowest and highest value of the type:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Subrange</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">]</span></pre><p><tt class="docutils literal"><span class="pre">Subrange</span></tt> is a subrange of an integer which can only hold the values 0 to 5. Assigning any other value to a variable of type <tt class="docutils literal"><span class="pre">Subrange</span></tt> is a checked runtime error (or static error if it can be statically determined). Assignments from the base type to one of its subrange types (and vice versa) are allowed.</p>
<p>A subrange type has the same size as its base type (<tt class="docutils literal"><span class="pre">int</span></tt> in the example).</p>
<p>Nim requires <span id="interval-arithmetic_1">interval arithmetic</span> for subrange types over a set of built-in operators that involve constants: <tt class="docutils literal"><span class="pre">x %% 3</span></tt> is of type <tt class="docutils literal"><span class="pre">range[0..2]</span></tt>. The following built-in operators for integers are affected by this rule: <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">min</span></tt>, <tt class="docutils literal"><span class="pre">max</span></tt>, <tt class="docutils literal"><span class="pre">succ</span></tt>, <tt class="docutils literal"><span class="pre">pred</span></tt>, <tt class="docutils literal"><span class="pre">mod</span></tt>, <tt class="docutils literal"><span class="pre">div</span></tt>, <tt class="docutils literal"><span class="pre">%%</span></tt>, <tt class="docutils literal"><span class="pre">and</span></tt> (bitwise <tt class="docutils literal"><span class="pre">and</span></tt>).</p>
<p>Bitwise <tt class="docutils literal"><span class="pre">and</span></tt> only produces a <tt class="docutils literal"><span class="pre">range</span></tt> if one of its operands is a constant <em>x</em> so that (x+1) is a number of two. (Bitwise <tt class="docutils literal"><span class="pre">and</span></tt> is then a <tt class="docutils literal"><span class="pre">%%</span></tt> operation.)</p>
<p>This means that the following code is accepted:</p>
<pre><span class="Keyword">case</span> <span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Keyword">and</span> <span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="DecNumber">7</span>
<span class="Keyword">of</span> <span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;A&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;B&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">9</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;C&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">10</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;D&quot;</span>
<span class="Comment"># note: no ``else`` required as (x and 3) + 7 has the type: range[7..10]</span></pre>
<h2><a class="toc-backref" id="pre-defined-floating-point-types" href="#pre-defined-floating-point-types">Pre-defined floating point types</a></h2><p>The following floating point types are pre-defined:</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">float</span></tt></dt>
<dd>the generic floating point type; its size is platform dependent (the compiler chooses the processor's fastest floating point type). This type should be used in general.</dd>
<dt>floatXX</dt>
<dd>an implementation may define additional floating point types of XX bits using this naming scheme (example: float64 is a 64 bit wide float). The current implementation supports <tt class="docutils literal"><span class="pre">float32</span></tt> and <tt class="docutils literal"><span class="pre">float64</span></tt>. Literals of these types have the suffix 'fXX.</dd>
</dl>
<p>Automatic type conversion in expressions with different kinds of floating point types is performed: See <a class="reference external" href="#convertible-relation">Convertible relation</a> for further details. Arithmetic performed on floating point types follows the IEEE standard. Integer types are not converted to floating point types automatically and vice versa.</p>
<p>The IEEE standard defines five types of floating-point exceptions:</p>
<ul class="simple"><li>Invalid: operations with mathematically invalid operands, for example 0.0/0.0, sqrt(-1.0), and log(-37.8).</li>
<li>Division by zero: divisor is zero and dividend is a finite nonzero number, for example 1.0/0.0.</li>
<li>Overflow: operation produces a result that exceeds the range of the exponent, for example MAXDOUBLE+0.0000000000001e308.</li>
<li>Underflow: operation produces a result that is too small to be represented as a normal number, for example, MINDOUBLE * MINDOUBLE.</li>
<li>Inexact: operation produces a result that cannot be represented with infinite precision, for example, 2.0 / 3.0, log(1.1) and 0.1 in input.</li>
</ul>
<p>The IEEE exceptions are either ignored at runtime or mapped to the Nim exceptions: <span id="floatinvalidoperror_1">FloatInvalidOpError</span>, <span id="floatdivbyzeroerror_1">FloatDivByZeroError</span>, <span id="floatoverflowerror_1">FloatOverflowError</span>, <span id="floatunderflowerror_1">FloatUnderflowError</span>, and <span id="floatinexacterror_1">FloatInexactError</span>. These exceptions inherit from the <span id="floatingpointerror_1">FloatingPointError</span> base class.</p>
<p>Nim provides the pragmas <span id="nanchecks_1">NaNChecks</span> and <span id="infchecks_1">InfChecks</span> to control whether the IEEE exceptions are ignored or trap a Nim exception:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">NanChecks</span><span class="Punctuation">:</span> <span class="Identifier">on</span><span class="Punctuation">,</span> <span class="Identifier">InfChecks</span><span class="Punctuation">:</span> <span class="Identifier">on</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="FloatNumber">1.0</span>
<span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="FloatNumber">0.0</span>
<span class="Identifier">echo</span> <span class="Identifier">b</span> <span class="Operator">/</span> <span class="Identifier">b</span> <span class="Comment"># raises FloatInvalidOpError</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">/</span> <span class="Identifier">b</span> <span class="Comment"># raises FloatOverflowError</span></pre><p>In the current implementation <tt class="docutils literal"><span class="pre">FloatDivByZeroError</span></tt> and <tt class="docutils literal"><span class="pre">FloatInexactError</span></tt> are never raised. <tt class="docutils literal"><span class="pre">FloatOverflowError</span></tt> is raised instead of <tt class="docutils literal"><span class="pre">FloatDivByZeroError</span></tt>. There is also a <span id="floatchecks_1">floatChecks</span> pragma that is a short-cut for the combination of <tt class="docutils literal"><span class="pre">NaNChecks</span></tt> and <tt class="docutils literal"><span class="pre">InfChecks</span></tt> pragmas. <tt class="docutils literal"><span class="pre">floatChecks</span></tt> are turned off as default.</p>
<p>The only operations that are affected by the <tt class="docutils literal"><span class="pre">floatChecks</span></tt> pragma are the <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt> operators for floating point types.</p>
<p>An implementation should always use the maximum precision available to evaluate floating pointer values at compile time; this means expressions like <tt class="docutils literal"><span class="pre">0.09'f32 + 0.01'f32 == 0.09'f64 + 0.01'f64</span></tt> are true.</p>

<h2><a class="toc-backref" id="boolean-type" href="#boolean-type">Boolean type</a></h2><p>The boolean type is named <span id="bool_1">bool</span> in Nim and can be one of the two pre-defined values <tt class="docutils literal"><span class="pre">true</span></tt> and <tt class="docutils literal"><span class="pre">false</span></tt>. Conditions in while, if, elif, when statements need to be of type bool.</p>
<p>This condition holds:<pre>
ord(false) == 0 and ord(true) == 1</pre>
</p>
<p>The operators <tt class="docutils literal"><span class="pre">not, and, or, xor, &lt;, &lt;=, &gt;, &gt;=, !=, ==</span></tt> are defined for the bool type. The <tt class="docutils literal"><span class="pre">and</span></tt> and <tt class="docutils literal"><span class="pre">or</span></tt> operators perform short-cut evaluation. Example:</p>
<pre><span class="Keyword">while</span> <span class="Identifier">p</span> <span class="Operator">!=</span> <span class="Keyword">nil</span> <span class="Keyword">and</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">!=</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">:</span>
  <span class="Comment"># p.name is not evaluated if p == nil</span>
  <span class="Identifier">p</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">next</span></pre><p>The size of the bool type is one byte.</p>

<h2><a class="toc-backref" id="character-type" href="#character-type">Character type</a></h2><p>The character type is named <tt class="docutils literal"><span class="pre">char</span></tt> in Nim. Its size is one byte. Thus it cannot represent an UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can support <tt class="docutils literal"><span class="pre">array[char, int]</span></tt> or <tt class="docutils literal"><span class="pre">set[char]</span></tt> efficiently as many algorithms rely on this feature. The <cite>Rune</cite> type is used for Unicode characters, it can represent any Unicode character. <tt class="docutils literal"><span class="pre">Rune</span></tt> is declared in the <a class="reference external" href="unicode.html">unicode module</a>.</p>

<h2><a class="toc-backref" id="enumeration-types" href="#enumeration-types">Enumeration types</a></h2><p>Enumeration types define a new type whose values consist of the ones specified. The values are ordered. Example:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Direction</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">north</span><span class="Punctuation">,</span> <span class="Identifier">east</span><span class="Punctuation">,</span> <span class="Identifier">south</span><span class="Punctuation">,</span> <span class="Identifier">west</span></pre><p>Now the following holds:<pre>
ord(north) == 0
ord(east) == 1
ord(south) == 2
ord(west) == 3</pre>
</p>
<p>Thus, north &lt; east &lt; south &lt; west. The comparison operators can be used with enumeration types.</p>
<p>For better interfacing to other programming languages, the fields of enum types can be assigned an explicit ordinal value. However, the ordinal values have to be in ascending order. A field whose ordinal value is not explicitly given is assigned the value of the previous field + 1.</p>
<p>An explicit ordered enum can have <em>holes</em>:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">TokenType</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="DecNumber">89</span> <span class="Comment"># holes are valid</span></pre><p>However, it is then not an ordinal anymore, so it is not possible to use these enums as an index type for arrays. The procedures <tt class="docutils literal"><span class="pre">inc</span></tt>, <tt class="docutils literal"><span class="pre">dec</span></tt>, <tt class="docutils literal"><span class="pre">succ</span></tt> and <tt class="docutils literal"><span class="pre">pred</span></tt> are not available for them either.</p>
<p>The compiler supports the built-in stringify operator <tt class="docutils literal"><span class="pre">$</span></tt> for enumerations. The stringify's result can be controlled by explicitly giving the string values to use:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valueA</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="StringLit">&quot;my value A&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
    <span class="Identifier">valueB</span> <span class="Operator">=</span> <span class="StringLit">&quot;value B&quot;</span><span class="Punctuation">,</span>
    <span class="Identifier">valueC</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">,</span>
    <span class="Identifier">valueD</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">)</span></pre><p>As can be seen from the example, it is possible to both specify a field's ordinal value and its string value by using a tuple. It is also possible to only specify one of them.</p>
<p>An enum can be marked with the <tt class="docutils literal"><span class="pre">pure</span></tt> pragma so that it's fields are not added to the current scope, so they always need to be accessed via <tt class="docutils literal"><span class="pre">MyEnum.value</span></tt>:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valueA</span><span class="Punctuation">,</span> <span class="Identifier">valueB</span><span class="Punctuation">,</span> <span class="Identifier">valueC</span><span class="Punctuation">,</span> <span class="Identifier">valueD</span>

<span class="Identifier">echo</span> <span class="Identifier">valueA</span> <span class="Comment"># error: Unknown identifier</span>
<span class="Identifier">echo</span> <span class="Identifier">MyEnum</span><span class="Operator">.</span><span class="Identifier">valueA</span> <span class="Comment"># works</span></pre>
<h2><a class="toc-backref" id="string-type" href="#string-type">String type</a></h2><p>All string literals are of the type <tt class="docutils literal"><span class="pre">string</span></tt>. A string in Nim is very similar to a sequence of characters. However, strings in Nim are both zero-terminated and have a length field. One can retrieve the length with the builtin <tt class="docutils literal"><span class="pre">len</span></tt> procedure; the length never counts the terminating zero. The assignment operator for strings always copies the string. The <tt class="docutils literal"><span class="pre">&amp;</span></tt> operator concatenates strings.</p>
<p>Strings are compared by their lexicographical order. All comparison operators are available. Strings can be indexed like arrays (lower bound is 0). Unlike arrays, they can be used in case statements:</p>
<pre><span class="Keyword">case</span> <span class="Identifier">paramStr</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;-v&quot;</span><span class="Punctuation">:</span> <span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">options</span><span class="Punctuation">,</span> <span class="Identifier">optVerbose</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;-h&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;-?&quot;</span><span class="Punctuation">:</span> <span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">options</span><span class="Punctuation">,</span> <span class="Identifier">optHelp</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;invalid command line option!</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span></pre><p>Per convention, all strings are UTF-8 strings, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation <tt class="docutils literal"><span class="pre">s[i]</span></tt> means the i-th <em>char</em> of <tt class="docutils literal"><span class="pre">s</span></tt>, not the i-th <em>unichar</em>. The iterator <tt class="docutils literal"><span class="pre">runes</span></tt> from the <a class="reference external" href="unicode.html">unicode module</a> can be used for iteration over all Unicode characters.</p>

<h2><a class="toc-backref" id="cstring-type" href="#cstring-type">cstring type</a></h2><p>The <tt class="docutils literal"><span class="pre">cstring</span></tt> type represents a pointer to a zero-terminated char array compatible to the type <tt class="docutils literal"><span class="pre">char*</span></tt> in Ansi C. Its primary purpose lies in easy interfacing with C. The index operation <tt class="docutils literal"><span class="pre">s[i]</span></tt> means the i-th <em>char</em> of <tt class="docutils literal"><span class="pre">s</span></tt>; however no bounds checking for <tt class="docutils literal"><span class="pre">cstring</span></tt> is performed making the index operation unsafe.</p>
<p>A Nim <tt class="docutils literal"><span class="pre">string</span></tt> is implicitly convertible to <tt class="docutils literal"><span class="pre">cstring</span></tt> for convenience. If a Nim string is passed to a C-style variadic proc, it is implicitly converted to <tt class="docutils literal"><span class="pre">cstring</span></tt> too:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;printf&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Punctuation">,</span>
                                  <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;stdio.h&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Identifier">printf</span><span class="Punctuation">(</span><span class="StringLit">&quot;This works %s&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;as expected&quot;</span><span class="Punctuation">)</span></pre><p>Even though the conversion is implicit, it is not <em>safe</em>: The garbage collector does not consider a <tt class="docutils literal"><span class="pre">cstring</span></tt> to be a root and may collect the underlying memory. However in practice this almost never happens as the GC considers stack roots conservatively. One can use the builtin procs <tt class="docutils literal"><span class="pre">GC_ref</span></tt> and <tt class="docutils literal"><span class="pre">GC_unref</span></tt> to keep the string data alive for the rare cases where it does not work.</p>
<p>A <cite>$</cite> proc is defined for cstrings that returns a string. Thus to get a nim string from a cstring:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">str</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;Hello!&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">cstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span> <span class="Operator">=</span> <span class="Identifier">str</span>
<span class="Keyword">var</span> <span class="Identifier">newstr</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">cstr</span></pre>
<h2><a class="toc-backref" id="structured-types" href="#structured-types">Structured types</a></h2><p>A variable of a structured type can hold multiple values at the same time. Structured types can be nested to unlimited levels. Arrays, sequences, tuples, objects and sets belong to the structured types.</p>

<h2><a class="toc-backref" id="array-and-sequence-types" href="#array-and-sequence-types">Array and sequence types</a></h2><p>Arrays are a homogeneous type, meaning that each element in the array has the same type. Arrays always have a fixed length which is specified at compile time (except for open arrays). They can be indexed by any ordinal type. A parameter <tt class="docutils literal"><span class="pre">A</span></tt> may be an <em>open array</em>, in which case it is indexed by integers from 0 to <tt class="docutils literal"><span class="pre">len(A)-1</span></tt>. An array expression may be constructed by the array constructor <tt class="docutils literal"><span class="pre">[]</span></tt>.</p>
<p>Sequences are similar to arrays but of dynamic length which may change during runtime (like strings). Sequences are implemented as growable arrays, allocating pieces of memory as items are added. A sequence <tt class="docutils literal"><span class="pre">S</span></tt> is always indexed by integers from 0 to <tt class="docutils literal"><span class="pre">len(S)-1</span></tt> and its bounds are checked. Sequences can be constructed by the array constructor <tt class="docutils literal"><span class="pre">[]</span></tt> in conjunction with the array to sequence operator <tt class="docutils literal"><span class="pre">@</span></tt>. Another way to allocate space for a sequence is to call the built-in <tt class="docutils literal"><span class="pre">newSeq</span></tt> procedure.</p>
<p>A sequence may be passed to a parameter that is of type <em>open array</em>.</p>
<p>Example:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">IntArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># an array that is indexed with 0..5</span>
  <span class="Identifier">IntSeq</span> <span class="Operator">=</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># a sequence of integers</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">IntArray</span>
  <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">IntSeq</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span>  <span class="Comment"># [] is the array constructor</span>
<span class="Identifier">y</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Comment"># the @ turns the array into a sequence</span></pre><p>The lower bound of an array or sequence may be received by the built-in proc <tt class="docutils literal"><span class="pre">low()</span></tt>, the higher bound by <tt class="docutils literal"><span class="pre">high()</span></tt>. The length may be received by <tt class="docutils literal"><span class="pre">len()</span></tt>. <tt class="docutils literal"><span class="pre">low()</span></tt> for a sequence or an open array always returns 0, as this is the first valid index. One can append elements to a sequence with the <tt class="docutils literal"><span class="pre">add()</span></tt> proc or the <tt class="docutils literal"><span class="pre">&amp;</span></tt> operator, and remove (and get) the last element of a sequence with the <tt class="docutils literal"><span class="pre">pop()</span></tt> proc.</p>
<p>The notation <tt class="docutils literal"><span class="pre">x[i]</span></tt> can be used to access the i-th element of <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>Arrays are always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the <tt class="docutils literal"><span class="pre">--boundChecks:off</span></tt> command line switch.</p>

<h2><a class="toc-backref" id="open-arrays" href="#open-arrays">Open arrays</a></h2><p>Often fixed size arrays turn out to be too inflexible; procedures should be able to deal with arrays of different sizes. The <span id="openarray_1">openarray</span> type allows this; it can only be used for parameters. Openarrays are always indexed with an <tt class="docutils literal"><span class="pre">int</span></tt> starting at position 0. The <tt class="docutils literal"><span class="pre">len</span></tt>, <tt class="docutils literal"><span class="pre">low</span></tt> and <tt class="docutils literal"><span class="pre">high</span></tt> operations are available for open arrays too. Any array with a compatible base type can be passed to an openarray parameter, the index type does not matter. In addition to arrays sequences can also be passed to an open array parameter.</p>
<p>The openarray type cannot be nested: multidimensional openarrays are not supported because this is seldom needed and cannot be done efficiently.</p>

<h2><a class="toc-backref" id="varargs" href="#varargs">Varargs</a></h2><p>A <tt class="docutils literal"><span class="pre">varargs</span></tt> parameter is an openarray parameter that additionally allows to pass a variable number of arguments to a procedure. The compiler converts the list of arguments to an array implicitly:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">)</span>
<span class="Comment"># is transformed to:</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>This transformation is only done if the varargs parameter is the last parameter in the procedure header. It is also possible to perform type conversions in this context:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="FloatNumber">4.0</span><span class="Punctuation">)</span>
<span class="Comment"># is transformed to:</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="Operator">$</span><span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="FloatNumber">4.0</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>In this example <tt class="docutils literal"><span class="pre">$</span></tt> is applied to any argument that is passed to the parameter <tt class="docutils literal"><span class="pre">a</span></tt>. (Note that <tt class="docutils literal"><span class="pre">$</span></tt> applied to strings is a nop.)</p>

<h2><a class="toc-backref" id="tuples-and-object-types" href="#tuples-and-object-types">Tuples and object types</a></h2><p>A variable of a tuple or object type is a heterogeneous storage container. A tuple or object defines various named <em>fields</em> of a type. A tuple also defines an <em>order</em> of the fields. Tuples are meant for heterogeneous storage types with no overhead and few abstraction possibilities. The constructor <tt class="docutils literal"><span class="pre">()</span></tt> can be used to construct tuples. The order of the fields in the constructor must match the order of the tuple's definition. Different tuple-types are <em>equivalent</em> if they specify the same fields of the same type in the same order. The <em>names</em> of the fields also have to be identical.</p>
<p>The assignment operator for tuples copies each component. The default assignment operator for objects copies each component. Overloading of the assignment operator for objects is not possible, but this will change in future versions of the compiler.</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># type representing a person:</span>
                                         <span class="Comment"># a person consists of a name</span>
                                         <span class="Comment"># and an age</span>
<span class="Keyword">var</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>
<span class="Comment"># the same, but less readable:</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">30</span><span class="Punctuation">)</span></pre><p>The implementation aligns the fields for best access performance. The alignment is compatible with the way the C compiler does it.</p>
<p>For consistency  with <tt class="docutils literal"><span class="pre">object</span></tt> declarations, tuples in a <tt class="docutils literal"><span class="pre">type</span></tt> section can also be defined with indentation instead of <tt class="docutils literal"><span class="pre">[]</span></tt>:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">tuple</span>   <span class="Comment"># type representing a person</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>   <span class="Comment"># a person consists of a name</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">natural</span>   <span class="Comment"># and an age</span></pre><p>Objects provide many features that tuples do not. Object provide inheritance and information hiding. Objects have access to their type at runtime, so that the <tt class="docutils literal"><span class="pre">of</span></tt> operator can be used to determine the object's type.</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inheritable</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">name</span><span class="Operator">*:</span> <span class="Identifier">string</span>   <span class="Comment"># the * means that `name` is accessible from other modules</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>        <span class="Comment"># no * means that the field is hidden</span>
  
  <span class="Identifier">Student</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Person</span> <span class="Comment"># a student is a person</span>
    <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="Identifier">int</span>                  <span class="Comment"># with an id field</span>

<span class="Keyword">var</span>
  <span class="Identifier">student</span><span class="Punctuation">:</span> <span class="Identifier">Student</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">student</span> <span class="Keyword">of</span> <span class="Identifier">Student</span><span class="Punctuation">)</span> <span class="Comment"># is true</span></pre><p>Object fields that should be visible from outside the defining module, have to be marked by <tt class="docutils literal"><span class="pre">*</span></tt>. In contrast to tuples, different object types are never <em>equivalent</em>. Objects that have no ancestor are implicitly <tt class="docutils literal"><span class="pre">final</span></tt> and thus have no hidden type field. One can use the <tt class="docutils literal"><span class="pre">inheritable</span></tt> pragma to introduce new object roots apart from <tt class="docutils literal"><span class="pre">system.RootObj</span></tt>.</p>

<h2><a class="toc-backref" id="object-construction" href="#object-construction">Object construction</a></h2><p>Objects can also be created with an <span id="object-construction-expression_1">object construction expression</span> that has the syntax <tt class="docutils literal"><span class="pre">T(fieldA: valueA, fieldB: valueB, ...)</span></tt> where <tt class="docutils literal"><span class="pre">T</span></tt> is an <tt class="docutils literal"><span class="pre">object</span></tt> type or a <tt class="docutils literal"><span class="pre">ref object</span></tt> type:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">student</span> <span class="Operator">=</span> <span class="Identifier">Student</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Anton&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre><p>For a <tt class="docutils literal"><span class="pre">ref object</span></tt> type <tt class="docutils literal"><span class="pre">system.new</span></tt> is invoked implicitly.</p>

<h2><a class="toc-backref" id="object-variants" href="#object-variants">Object variants</a></h2><p>Often an object hierarchy is overkill in certain situations where simple variant types are needed.</p>
<p>An example:</p>
<pre><span class="Comment"># This is an example how an abstract syntax tree could be modelled in Nim</span>
<span class="Keyword">type</span>
  <span class="Identifier">NodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span>  <span class="Comment"># the different node types</span>
    <span class="Identifier">nkInt</span><span class="Punctuation">,</span>          <span class="Comment"># a leaf with an integer value</span>
    <span class="Identifier">nkFloat</span><span class="Punctuation">,</span>        <span class="Comment"># a leaf with a float value</span>
    <span class="Identifier">nkString</span><span class="Punctuation">,</span>       <span class="Comment"># a leaf with a string value</span>
    <span class="Identifier">nkAdd</span><span class="Punctuation">,</span>          <span class="Comment"># an addition</span>
    <span class="Identifier">nkSub</span><span class="Punctuation">,</span>          <span class="Comment"># a subtraction</span>
    <span class="Identifier">nkIf</span>            <span class="Comment"># an if statement</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">NodeKind</span>  <span class="Comment"># the ``kind`` field is the discriminator</span>
    <span class="Keyword">of</span> <span class="Identifier">nkInt</span><span class="Punctuation">:</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Keyword">of</span> <span class="Identifier">nkFloat</span><span class="Punctuation">:</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="Identifier">float</span>
    <span class="Keyword">of</span> <span class="Identifier">nkString</span><span class="Punctuation">:</span> <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">nkSub</span><span class="Punctuation">:</span>
      <span class="Identifier">leftOp</span><span class="Punctuation">,</span> <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Keyword">of</span> <span class="Identifier">nkIf</span><span class="Punctuation">:</span>
      <span class="Identifier">condition</span><span class="Punctuation">,</span> <span class="Identifier">thenPart</span><span class="Punctuation">,</span> <span class="Identifier">elsePart</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>

<span class="Comment"># create a new case object:</span>
<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkIf</span><span class="Punctuation">,</span> <span class="Identifier">condition</span><span class="Punctuation">:</span> <span class="Keyword">nil</span><span class="Punctuation">)</span>
<span class="Comment"># accessing n.thenPart is valid because the ``nkIf`` branch is active:</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">thenPart</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkFloat</span><span class="Punctuation">,</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="FloatNumber">2.0</span><span class="Punctuation">)</span>

<span class="Comment"># the following statement raises an `FieldError` exception, because</span>
<span class="Comment"># n.kind's value does not fit and the ``nkString`` branch is not active:</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">strVal</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span>

<span class="Comment"># invalid: would change the active object branch:</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">=</span> <span class="Identifier">nkInt</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">leftOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
                          <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># valid: does not change the active object branch:</span>
<span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">=</span> <span class="Identifier">nkSub</span></pre><p>As can been seen from the example, an advantage to an object hierarchy is that no casting between different object types is needed. Yet, access to invalid object fields raises an exception.</p>
<p>The syntax of <tt class="docutils literal"><span class="pre">case</span></tt> in an object declaration follows closely the syntax of the <tt class="docutils literal"><span class="pre">case</span></tt> statement: The branches in a <tt class="docutils literal"><span class="pre">case</span></tt> section may be indented too.</p>
<p>In the example the <tt class="docutils literal"><span class="pre">kind</span></tt> field is called the <span id="discriminator_1">discriminator</span>: For safety its address cannot be taken and assignments to it are restricted: The new value must not lead to a change of the active object branch. For an object branch switch <tt class="docutils literal"><span class="pre">system.reset</span></tt> has to be used.</p>

<h2><a class="toc-backref" id="set-type" href="#set-type">Set type</a></h2><p>The set type models the mathematical notion of a set. The set's basetype can only be an ordinal type. The reason is that sets are implemented as high performance bit vectors.</p>
<p>Sets can be constructed via the set constructor: <tt class="docutils literal"><span class="pre">{}</span></tt> is the empty set. The empty set is type compatible with any concrete set type. The constructor can also be used to include elements (and ranges of elements):</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">CharSet</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">CharSet</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">}</span> <span class="Comment"># This constructs a set that contains the</span>
                         <span class="Comment"># letters from 'a' to 'z' and the digits</span>
                         <span class="Comment"># from '0' to '9'</span></pre><p>These operations are supported by sets:</p>
<table border="1" class="docutils"><tr><th>operation</th><th>meaning</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">A + B</span></tt></td><td>union of two sets</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A * B</span></tt></td><td>intersection of two sets</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A - B</span></tt></td><td>difference of two sets (A without B's elements)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A == B</span></tt></td><td>set equality</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A &lt;= B</span></tt></td><td>subset relation (A is subset of B or equal to B)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">A &lt; B</span></tt></td><td>strong subset relation (A is a real subset of B)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">e in A</span></tt></td><td>set membership (A contains element e)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">e notin A</span></tt></td><td>A does not contain element e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">contains(A, e)</span></tt></td><td>A contains element e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">card(A)</span></tt></td><td>the cardinality of A (number of elements in A)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">incl(A, elem)</span></tt></td><td>same as <tt class="docutils literal"><span class="pre">A = A + {elem}</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">excl(A, elem)</span></tt></td><td>same as <tt class="docutils literal"><span class="pre">A = A - {elem}</span></tt></td></tr>
</table><p>Sets are often used to define a type for the <em>flags</em> of a procedure. This is a much cleaner (and type safe) solution than just defining integer constants that should be <tt class="docutils literal"><span class="pre">or</span></tt>'ed together. </p>

<h2><a class="toc-backref" id="reference-and-pointer-types" href="#reference-and-pointer-types">Reference and pointer types</a></h2><p>References (similar to pointers in other programming languages) are a way to introduce many-to-one relationships. This means different references can point to and modify the same location in memory (also called <span id="aliasing_1">aliasing</span>).</p>
<p>Nim distinguishes between <span id="traced_1">traced</span> and <span id="untraced_1">untraced</span> references. Untraced references are also called <em>pointers</em>. Traced references point to objects of a garbage collected heap, untraced references point to manually allocated objects or to objects somewhere else in memory. Thus untraced references are <em>unsafe</em>. However for certain low-level operations (accessing the hardware) untraced references are unavoidable.</p>
<p>Traced references are declared with the <strong>ref</strong> keyword, untraced references are declared with the <strong>ptr</strong> keyword.</p>
<p>An empty subscript <tt class="docutils literal"><span class="pre">[]</span></tt> notation can be used to derefer a reference, the <tt class="docutils literal"><span class="pre">addr</span></tt> procedure returns the address of an item. An address is always an untraced reference. Thus the usage of <tt class="docutils literal"><span class="pre">addr</span></tt> is an <em>unsafe</em> feature.</p>
<p>The <tt class="docutils literal"><span class="pre">.</span></tt> (access a tuple/object field operator) and <tt class="docutils literal"><span class="pre">[]</span></tt> (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">var</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="DecNumber">9</span>
<span class="Comment"># no need to write n[].data; in fact n[].data is highly discouraged!</span></pre><p>Automatic dereferencing is also performed for the first argument of a routine call. But currently this feature has to be only enabled via <tt class="docutils literal"><span class="pre">{.experimental.}</span></tt>:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">depth</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">NodeObj</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">depth</span>
<span class="Comment"># no need to write n[].depth either</span></pre><p>In order to simplify structural type checking, recursive tuples are not valid:</p>
<pre><span class="Comment"># invalid recursion</span>
<span class="Keyword">type</span> <span class="Identifier">MyTuple</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">MyTuple</span><span class="Punctuation">]</span></pre><p>Likewise <tt class="docutils literal"><span class="pre">T = ref T</span></tt> is an invalid type.</p>
<p>As a syntactical extension <tt class="docutils literal"><span class="pre">object</span></tt> types can be anonymous if declared in a type section via the <tt class="docutils literal"><span class="pre">ref object</span></tt> or <tt class="docutils literal"><span class="pre">ptr object</span></tt> notations. This feature is useful if an object should only gain reference semantics:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>To allocate a new traced object, the built-in procedure <tt class="docutils literal"><span class="pre">new</span></tt> has to be used. To deal with untraced memory, the procedures <tt class="docutils literal"><span class="pre">alloc</span></tt>, <tt class="docutils literal"><span class="pre">dealloc</span></tt> and <tt class="docutils literal"><span class="pre">realloc</span></tt> can be used. The documentation of the system module contains further information.</p>
<p>If a reference points to <em>nothing</em>, it has the value <tt class="docutils literal"><span class="pre">nil</span></tt>.</p>
<p>Special care has to be taken if an untraced object contains traced objects like traced references, strings or sequences: in order to free everything properly, the built-in procedure <tt class="docutils literal"><span class="pre">GCunref</span></tt> has to be called before freeing the untraced memory manually:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Data</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">]</span>

<span class="Comment"># allocate memory for Data on the heap:</span>
<span class="Keyword">var</span> <span class="Identifier">d</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Keyword">ptr</span> <span class="Identifier">Data</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">alloc0</span><span class="Punctuation">(</span><span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">Data</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Comment"># create a new string on the garbage collected heap:</span>
<span class="Identifier">d</span><span class="Operator">.</span><span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span>

<span class="Comment"># tell the GC that the string is not needed anymore:</span>
<span class="Identifier">GCunref</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Operator">.</span><span class="Identifier">s</span><span class="Punctuation">)</span>

<span class="Comment"># free the memory:</span>
<span class="Identifier">dealloc</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Punctuation">)</span></pre><p>Without the <tt class="docutils literal"><span class="pre">GCunref</span></tt> call the memory allocated for the <tt class="docutils literal"><span class="pre">d.s</span></tt> string would never be freed. The example also demonstrates two important features for low level programming: the <tt class="docutils literal"><span class="pre">sizeof</span></tt> proc returns the size of a type or value in bytes. The <tt class="docutils literal"><span class="pre">cast</span></tt> operator can circumvent the type system: the compiler is forced to treat the result of the <tt class="docutils literal"><span class="pre">alloc0</span></tt> call (which returns an untyped pointer) as if it would have the type <tt class="docutils literal"><span class="pre">ptr Data</span></tt>. Casting should only be done if it is unavoidable: it breaks type safety and bugs can lead to mysterious crashes.</p>
<p><strong>Note</strong>: The example only works because the memory is initialized to zero (<tt class="docutils literal"><span class="pre">alloc0</span></tt> instead of <tt class="docutils literal"><span class="pre">alloc</span></tt> does this): <tt class="docutils literal"><span class="pre">d.s</span></tt> is thus initialized to <tt class="docutils literal"><span class="pre">nil</span></tt> which the string assignment can handle. One needs to know low level details like this when mixing garbage collected data with unmanaged memory.</p>

<h2><a class="toc-backref" id="not-nil-annotation" href="#not-nil-annotation">Not nil annotation</a></h2><p>All types for that <tt class="docutils literal"><span class="pre">nil</span></tt> is a valid value can be annotated to exclude <tt class="docutils literal"><span class="pre">nil</span></tt> as a valid value with the <tt class="docutils literal"><span class="pre">not nil</span></tt> annotation:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">PObject</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">TObj</span> <span class="Keyword">not</span> <span class="Keyword">nil</span>
  <span class="Identifier">TProc</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Keyword">not</span> <span class="Keyword">nil</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PObject</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;not nil&quot;</span>

<span class="Comment"># compiler catches this:</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Keyword">nil</span><span class="Punctuation">)</span>

<span class="Comment"># and also this:</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PObject</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>The compiler ensures that every code path initializes variables which contain not nilable pointers. The details of this analysis are still to be specified here.</p>

<h2><a class="toc-backref" id="memory-regions" href="#memory-regions">Memory regions</a></h2><p>The types <tt class="docutils literal"><span class="pre">ref</span></tt> and <tt class="docutils literal"><span class="pre">ptr</span></tt> can get an optional <tt class="docutils literal"><span class="pre">region</span></tt> annotation. A region has to be an object type.</p>
<p>Regions are very useful to separate user space and kernel memory in the development of OS kernels:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Kernel</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">Userspace</span> <span class="Operator">=</span> <span class="Keyword">object</span>

<span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Kernel</span> <span class="Keyword">ptr</span> <span class="Identifier">Stat</span>
<span class="Keyword">var</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Userspace</span> <span class="Keyword">ptr</span> <span class="Identifier">Stat</span>

<span class="Comment"># the following does not compile as the pointer types are incompatible:</span>
<span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">b</span></pre><p>As the example shows <tt class="docutils literal"><span class="pre">ptr</span></tt> can also be used as a binary operator, <tt class="docutils literal"><span class="pre">region ptr T</span></tt> is a shortcut for <tt class="docutils literal"><span class="pre">ptr[region, T]</span></tt>.</p>
<p>In order to make generic code easier to write <tt class="docutils literal"><span class="pre">ptr T</span></tt> is a subtype of <tt class="docutils literal"><span class="pre">ptr[R, T]</span></tt> for any <tt class="docutils literal"><span class="pre">R</span></tt>.</p>
<p>Furthermore the subtype relation of the region object types is lifted to the pointer types: If <tt class="docutils literal"><span class="pre">A &lt;: B</span></tt> then <tt class="docutils literal"><span class="pre">ptr[A, T] &lt;: ptr[B, T]</span></tt>. This can be used to model subregions of memory. As a special typing rule <tt class="docutils literal"><span class="pre">ptr[R, T]</span></tt> is not compatible to <tt class="docutils literal"><span class="pre">pointer</span></tt> to prevent the following from compiling:</p>
<pre><span class="Comment"># from system</span>
<span class="Keyword">proc</span> <span class="Identifier">dealloc</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Identifier">pointer</span><span class="Punctuation">)</span>

<span class="Comment"># wrap some scripting language</span>
<span class="Keyword">type</span>
  <span class="Identifier">PythonsHeap</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">PyObjectHeader</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">rc</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">pointer</span>
  <span class="Identifier">PyObject</span> <span class="Operator">=</span> <span class="Keyword">ptr</span><span class="Punctuation">[</span><span class="Identifier">PythonsHeap</span><span class="Punctuation">,</span> <span class="Identifier">PyObjectHeader</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">createPyObject</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PyObject</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;...&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">destroyPyObject</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PyObject</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;...&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">var</span> <span class="Identifier">foo</span> <span class="Operator">=</span> <span class="Identifier">createPyObject</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Comment"># type error here, how convenient:</span>
<span class="Identifier">dealloc</span><span class="Punctuation">(</span><span class="Identifier">foo</span><span class="Punctuation">)</span></pre><p>Future directions:</p>
<ul class="simple"><li>Memory regions might become available for  <tt class="docutils literal"><span class="pre">string</span></tt> and <tt class="docutils literal"><span class="pre">seq</span></tt> too.</li>
<li>Builtin regions like <tt class="docutils literal"><span class="pre">private</span></tt>, <tt class="docutils literal"><span class="pre">global</span></tt> and <tt class="docutils literal"><span class="pre">local</span></tt> will prove very useful for the upcoming OpenCL target.</li>
<li>Builtin &quot;regions&quot; can model <tt class="docutils literal"><span class="pre">lent</span></tt> and <tt class="docutils literal"><span class="pre">unique</span></tt> pointers.</li>
</ul>

<h2><a class="toc-backref" id="procedural-type" href="#procedural-type">Procedural type</a></h2><p>A procedural type is internally a pointer to a procedure. <tt class="docutils literal"><span class="pre">nil</span></tt> is an allowed value for variables of a procedural type. Nim uses procedural types to achieve <span id="functional_1">functional</span> programming techniques.</p>
<p>Examples:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">printItem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Operator">...</span>

<span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">printItem</span><span class="Punctuation">)</span>  <span class="Comment"># this will NOT compile because calling conventions differ</span></pre><pre><span class="Keyword">type</span>
  <span class="Identifier">OnMouseMove</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">onMouseMove</span><span class="Punctuation">(</span><span class="Identifier">mouseX</span><span class="Punctuation">,</span> <span class="Identifier">mouseY</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># has default calling convention</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;x: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">mouseX</span><span class="Punctuation">,</span> <span class="StringLit">&quot; y: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">mouseY</span>

<span class="Keyword">proc</span> <span class="Identifier">setOnMouseMove</span><span class="Punctuation">(</span><span class="Identifier">mouseMoveEvent</span><span class="Punctuation">:</span> <span class="Identifier">OnMouseMove</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Comment"># ok, 'onMouseMove' has the default calling convention, which is compatible</span>
<span class="Comment"># to 'closure':</span>
<span class="Identifier">setOnMouseMove</span><span class="Punctuation">(</span><span class="Identifier">onMouseMove</span><span class="Punctuation">)</span></pre><p>A subtle issue with procedural types is that the calling convention of the procedure influences the type compatibility: procedural types are only compatible if they have the same calling convention. As a special extension, a procedure of the calling convention <tt class="docutils literal"><span class="pre">nimcall</span></tt> can be passed to a parameter that expects a proc of the calling convention <tt class="docutils literal"><span class="pre">closure</span></tt>.</p>
<p>Nim supports these <span id="calling-conventions_1">calling conventions</span>:</p>
<dl class="docutils"><dt><span id="nimcall_1">nimcall</span></dt>
<dd>is the default convention used for a Nim <strong>proc</strong>. It is the same as <tt class="docutils literal"><span class="pre">fastcall</span></tt>, but only for C compilers that support <tt class="docutils literal"><span class="pre">fastcall</span></tt>.</dd>
<dt><span id="closure_1">closure</span></dt>
<dd>is the default calling convention for a <strong>procedural type</strong> that lacks any pragma annotations. It indicates that the procedure has a hidden implicit parameter (an <em>environment</em>). Proc vars that have the calling convention <tt class="docutils literal"><span class="pre">closure</span></tt> take up two machine words: One for the proc pointer and another one for the pointer to implicitly passed environment.</dd>
<dt><span id="stdcall_1">stdcall</span></dt>
<dd>This the stdcall convention as specified by Microsoft. The generated C procedure is declared with the <tt class="docutils literal"><span class="pre">__stdcall</span></tt> keyword.</dd>
<dt><span id="cdecl_1">cdecl</span></dt>
<dd>The cdecl convention means that a procedure shall use the same convention as the C compiler. Under windows the generated C procedure is declared with the <tt class="docutils literal"><span class="pre">__cdecl</span></tt> keyword.</dd>
<dt><span id="safecall_1">safecall</span></dt>
<dd>This is the safecall convention as specified by Microsoft. The generated C procedure is declared with the <tt class="docutils literal"><span class="pre">__safecall</span></tt> keyword. The word <em>safe</em> refers to the fact that all hardware registers shall be pushed to the hardware stack.</dd>
<dt><span id="inline_1">inline</span></dt>
<dd>The inline convention means the the caller should not call the procedure, but inline its code directly. Note that Nim does not inline, but leaves this to the C compiler; it generates <tt class="docutils literal"><span class="pre">__inline</span></tt> procedures. This is only a hint for the compiler: it may completely ignore it and it may inline procedures that are not marked as <tt class="docutils literal"><span class="pre">inline</span></tt>.</dd>
<dt><span id="fastcall_1">fastcall</span></dt>
<dd>Fastcall means different things to different C compilers. One gets whatever the C <tt class="docutils literal"><span class="pre">__fastcall</span></tt> means.</dd>
<dt><span id="syscall_1">syscall</span></dt>
<dd>The syscall convention is the same as <tt class="docutils literal"><span class="pre">__syscall</span></tt> in C. It is used for interrupts.</dd>
<dt><span id="noconv_1">noconv</span></dt>
<dd>The generated C code will not have any explicit calling convention and thus use the C compiler's default calling convention. This is needed because Nim's default calling convention for procedures is <tt class="docutils literal"><span class="pre">fastcall</span></tt> to improve speed.</dd>
</dl>
<p>Most calling conventions exist only for the Windows 32-bit platform.</p>
<p>Assigning/passing a procedure to a procedural variable is only allowed if one of the following conditions hold:</p>
<ol class="simple"><li>The procedure that is accessed resides in the current module.</li>
<li>The procedure is marked with the <tt class="docutils literal"><span class="pre">procvar</span></tt> pragma (see <a class="reference external" href="#procvar-pragma">procvar pragma</a>).</li>
<li>The procedure has a calling convention that differs from <tt class="docutils literal"><span class="pre">nimcall</span></tt>.</li>
<li>The procedure is anonymous.</li>
</ol>
<p>The rules' purpose is to prevent the case that extending a non-<tt class="docutils literal"><span class="pre">procvar</span></tt> procedure with default parameters breaks client code.</p>
<p>The default calling convention is <tt class="docutils literal"><span class="pre">nimcall</span></tt>, unless it is an inner proc (a proc inside of a proc). For an inner proc an analysis is performed whether it accesses its environment. If it does so, it has the calling convention <tt class="docutils literal"><span class="pre">closure</span></tt>, otherwise it has the calling convention <tt class="docutils literal"><span class="pre">nimcall</span></tt>.</p>

<h2><a class="toc-backref" id="distinct-type" href="#distinct-type">Distinct type</a></h2><p>A <tt class="docutils literal"><span class="pre">distinct</span></tt> type is new type derived from a <span id="base-type_1">base type</span> that is incompatible with its base type. In particular, it is an essential property of a distinct type that it <strong>does not</strong> imply a subtype relation between it and its base type. Explicit type conversions from a distinct type to its base type and vice versa are allowed.</p>

<h3><a class="toc-backref" id="modelling-currencies" href="#modelling-currencies">Modelling currencies</a></h3><p>A distinct type can be used to model different physical <span id="units_1">units</span> with a numerical base type, for example. The following example models currencies.</p>
<p>Different currencies should not be mixed in monetary calculations. Distinct types are a perfect tool to model different currencies:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Dollar</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>
  <span class="Identifier">Euro</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>

<span class="Keyword">var</span>
  <span class="Identifier">d</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span>
  <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Euro</span>

<span class="Identifier">echo</span> <span class="Identifier">d</span> <span class="Operator">+</span> <span class="DecNumber">12</span>
<span class="Comment"># Error: cannot add a number with no unit and a ``Dollar``</span></pre><p>Unfortunately, <tt class="docutils literal"><span class="pre">d + 12.Dollar</span></tt> is not allowed either, because <tt class="docutils literal"><span class="pre">+</span></tt> is defined for <tt class="docutils literal"><span class="pre">int</span></tt> (among others), not for <tt class="docutils literal"><span class="pre">Dollar</span></tt>. So a <tt class="docutils literal"><span class="pre">+</span></tt> for dollars needs to be defined:</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Dollar</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>It does not make sense to multiply a dollar with a dollar, but with a number without unit; and the same holds for division:</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Dollar</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="Identifier">y</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Dollar</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">*</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span> <span class="Operator">...</span></pre><p>This quickly gets tedious. The implementations are trivial and the compiler should not generate all this code only to optimize it away later - after all <tt class="docutils literal"><span class="pre">+</span></tt> for dollars should produce the same binary code as <tt class="docutils literal"><span class="pre">+</span></tt> for ints. The pragma <span id="borrow_1">borrow</span> has been designed to solve this problem; in principle it generates the above trivial implementations:</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>The <tt class="docutils literal"><span class="pre">borrow</span></tt> pragma makes the compiler use the same implementation as the proc that deals with the distinct type's base type, so no code is generated.</p>
<p>But it seems all this boilerplate code needs to be repeated for the <tt class="docutils literal"><span class="pre">Euro</span></tt> currency. This can be solved with <a class="reference external" href="#templates">templates</a>.</p>
<pre><span class="Keyword">template</span> <span class="Identifier">additive</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  
  <span class="Comment"># unary operators:</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">multiplicative</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">base</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">mod</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">comparable</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&lt;</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&lt;=</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">defineCurrency</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">base</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Keyword">type</span>
    <span class="Identifier">typ</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">base</span>
  <span class="Identifier">additive</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">)</span>
  <span class="Identifier">multiplicative</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">base</span><span class="Punctuation">)</span>
  <span class="Identifier">comparable</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">)</span>

<span class="Identifier">defineCurrency</span><span class="Punctuation">(</span><span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Identifier">defineCurrency</span><span class="Punctuation">(</span><span class="Identifier">Euro</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span></pre><p>The borrow pragma can also be used to annotate the distinct type to allow certain builtin operations to be lifted:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Foo</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
  
  <span class="Identifier">Bar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Punctuation">:</span> <span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">Foo</span>

<span class="Keyword">var</span> <span class="Identifier">bb</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Bar</span>
<span class="Identifier">new</span> <span class="Identifier">bb</span>
<span class="Comment"># field access now valid</span>
<span class="Identifier">bb</span><span class="Operator">.</span><span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">90</span>
<span class="Identifier">bb</span><span class="Operator">.</span><span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span></pre><p>Currently only the dot accessor can be borrowed in this way.</p>

<h3><a class="toc-backref" id="avoiding-sql-injection-attacks" href="#avoiding-sql-injection-attacks">Avoiding SQL injection attacks</a></h3><p>An SQL statement that is passed from Nim to an SQL database might be modelled as a string. However, using string templates and filling in the values is vulnerable to the famous <span id="sql-injection-attack_1">SQL injection attack</span>:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">strutils</span>

<span class="Keyword">proc</span> <span class="Identifier">query</span><span class="Punctuation">(</span><span class="Identifier">db</span><span class="Punctuation">:</span> <span class="Identifier">DbHandle</span><span class="Punctuation">,</span> <span class="Identifier">statement</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span>
  <span class="Identifier">username</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Identifier">db</span><span class="Operator">.</span><span class="Identifier">query</span><span class="Punctuation">(</span><span class="StringLit">&quot;SELECT FROM users WHERE name = '$1'&quot;</span> <span class="Operator">%</span> <span class="Identifier">username</span><span class="Punctuation">)</span>
<span class="Comment"># Horrible security hole, but the compiler does not mind!</span></pre><p>This can be avoided by distinguishing strings that contain SQL from strings that don't. Distinct types provide a means to introduce a new string type <tt class="docutils literal"><span class="pre">SQL</span></tt> that is incompatible with <tt class="docutils literal"><span class="pre">string</span></tt>:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">SQL</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">string</span>

<span class="Keyword">proc</span> <span class="Identifier">query</span><span class="Punctuation">(</span><span class="Identifier">db</span><span class="Punctuation">:</span> <span class="Identifier">DbHandle</span><span class="Punctuation">,</span> <span class="Identifier">statement</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span>
  <span class="Identifier">username</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Identifier">db</span><span class="Operator">.</span><span class="Identifier">query</span><span class="Punctuation">(</span><span class="StringLit">&quot;SELECT FROM users WHERE name = '$1'&quot;</span> <span class="Operator">%</span> <span class="Identifier">username</span><span class="Punctuation">)</span>
<span class="Comment"># Error at compile time: `query` expects an SQL string!</span></pre><p>It is an essential property of abstract types that they <strong>do not</strong> imply a subtype relation between the abtract type and its base type. Explict type conversions from <tt class="docutils literal"><span class="pre">string</span></tt> to <tt class="docutils literal"><span class="pre">SQL</span></tt> are allowed:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">strutils</span><span class="Punctuation">,</span> <span class="Identifier">sequtils</span>

<span class="Keyword">proc</span> <span class="Identifier">properQuote</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span> <span class="Operator">=</span>
  <span class="Comment"># quotes a string properly for an SQL statement</span>
  <span class="Keyword">return</span> <span class="Identifier">SQL</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">%</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">frmt</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span><span class="Punctuation">,</span> <span class="Identifier">values</span><span class="Punctuation">:</span> <span class="Identifier">openarray</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span> <span class="Operator">=</span>
  <span class="Comment"># quote each argument:</span>
  <span class="Keyword">let</span> <span class="Identifier">v</span> <span class="Operator">=</span> <span class="Identifier">values</span><span class="Operator">.</span><span class="Identifier">mapIt</span><span class="Punctuation">(</span><span class="Identifier">SQL</span><span class="Punctuation">,</span> <span class="Identifier">properQuote</span><span class="Punctuation">(</span><span class="Identifier">it</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Comment"># we need a temporary type for the type conversion :-(</span>
  <span class="Keyword">type</span> <span class="Identifier">StrSeq</span> <span class="Operator">=</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span>
  <span class="Comment"># call strutils.`%`:</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">SQL</span><span class="Punctuation">(</span><span class="Identifier">string</span><span class="Punctuation">(</span><span class="Identifier">frmt</span><span class="Punctuation">)</span> <span class="Operator">%</span> <span class="Identifier">StrSeq</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Identifier">db</span><span class="Operator">.</span><span class="Identifier">query</span><span class="Punctuation">(</span><span class="StringLit">&quot;SELECT FROM users WHERE name = '$1'&quot;</span><span class="Operator">.</span><span class="Identifier">SQL</span> <span class="Operator">%</span> <span class="Punctuation">[</span><span class="Identifier">username</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>Now we have compile-time checking against SQL injection attacks.  Since <tt class="docutils literal"><span class="pre">&quot;&quot;.SQL</span></tt> is transformed to <tt class="docutils literal"><span class="pre">SQL(&quot;&quot;)</span></tt> no new syntax is needed for nice looking <tt class="docutils literal"><span class="pre">SQL</span></tt> string literals. The hypothetical <tt class="docutils literal"><span class="pre">SQL</span></tt> type actually exists in the library as the <a class="reference external" href="db_sqlite.html#TSqlQuery">TSqlQuery type</a> of modules like <a class="reference external" href="db_sqlite.html">db_sqlite</a>.</p>

<h2><a class="toc-backref" id="void-type" href="#void-type">Void type</a></h2><p>The <tt class="docutils literal"><span class="pre">void</span></tt> type denotes the absence of any type. Parameters of type <tt class="docutils literal"><span class="pre">void</span></tt> are treated as non-existent, <tt class="docutils literal"><span class="pre">void</span></tt> as a return type means that the procedure does not return a value:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">nothing</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">void</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">void</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;ha&quot;</span>

<span class="Identifier">nothing</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># writes &quot;ha&quot; to stdout</span></pre><p>The <tt class="docutils literal"><span class="pre">void</span></tt> type is particularly useful for generic code:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">callProc</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">when</span> <span class="Identifier">T</span> <span class="Keyword">is</span> <span class="Identifier">void</span><span class="Punctuation">:</span>
    <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">intProc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Identifier">emptyProc</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">callProc</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">intProc</span><span class="Punctuation">,</span> <span class="DecNumber">12</span><span class="Punctuation">)</span>
<span class="Identifier">callProc</span><span class="Punctuation">[</span><span class="Identifier">void</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">emptyProc</span><span class="Punctuation">)</span></pre><p>However, a <tt class="docutils literal"><span class="pre">void</span></tt> type cannot be inferred in generic code:</p>
<pre><span class="Identifier">callProc</span><span class="Punctuation">(</span><span class="Identifier">emptyProc</span><span class="Punctuation">)</span>
<span class="Comment"># Error: type mismatch: got (proc ())</span>
<span class="Comment"># but expected one of:</span>
<span class="Comment"># callProc(p: proc (T), x: T)</span></pre><p>The <tt class="docutils literal"><span class="pre">void</span></tt> type is only valid for parameters and return types; other symbols cannot have the type <tt class="docutils literal"><span class="pre">void</span></tt>. </p>

<h1><a class="toc-backref" id="type-relations" href="#type-relations">Type relations</a></h1><p>The following section defines several relations on types that are needed to describe the type checking done by the compiler.</p>

<h2><a class="toc-backref" id="type-equality" href="#type-equality">Type equality</a></h2><p>Nim uses structural type equivalence for most types. Only for objects, enumerations and distinct types name equivalence is used. The following algorithm (in pseudo-code) determines type equality:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">,</span>
                   <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">PType</span> <span class="Operator">*</span> <span class="Identifier">PType</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span><span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Keyword">in</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
    <span class="Keyword">of</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">intXX</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">floatXX</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">cstring</span><span class="Punctuation">,</span> <span class="Identifier">pointer</span><span class="Punctuation">,</span>
        <span class="Identifier">bool</span><span class="Punctuation">,</span> <span class="Keyword">nil</span><span class="Punctuation">,</span> <span class="Identifier">void</span><span class="Punctuation">:</span>
      <span class="Comment"># leaf type: kinds identical; nothing more to check</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">ref</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">,</span> <span class="Keyword">var</span><span class="Punctuation">,</span> <span class="Identifier">set</span><span class="Punctuation">,</span> <span class="Identifier">seq</span><span class="Punctuation">,</span> <span class="Identifier">openarray</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">range</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
        <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeA</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeA</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeB</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeB</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">array</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Keyword">tuple</span><span class="Punctuation">:</span>
      <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Punctuation">:</span>
        <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span>
          <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">false</span>
        <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">object</span><span class="Punctuation">,</span> <span class="Keyword">enum</span><span class="Punctuation">,</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span>
    <span class="Keyword">of</span> <span class="Keyword">proc</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">callingConvention</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">callingConvention</span>

<span class="Keyword">proc</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">PType</span> <span class="Operator">*</span> <span class="Identifier">PType</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="Punctuation">}</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsAux</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span></pre><p>Since types are graphs which can have cycles, the above algorithm needs an auxiliary set <tt class="docutils literal"><span class="pre">s</span></tt> to detect this case.</p>

<h2><a class="toc-backref" id="type-equality-modulo-type-distinction" href="#type-equality-modulo-type-distinction">Type equality modulo type distinction</a></h2><p>The following algorithm (in pseudo-code) determines whether two types are equal with no respect to <tt class="docutils literal"><span class="pre">distinct</span></tt> types. For brevity the cycle check with an auxiliary set <tt class="docutils literal"><span class="pre">s</span></tt> is omitted:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
    <span class="Keyword">of</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">intXX</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">floatXX</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">cstring</span><span class="Punctuation">,</span> <span class="Identifier">pointer</span><span class="Punctuation">,</span>
        <span class="Identifier">bool</span><span class="Punctuation">,</span> <span class="Keyword">nil</span><span class="Punctuation">,</span> <span class="Identifier">void</span><span class="Punctuation">:</span>
      <span class="Comment"># leaf type: kinds identical; nothing more to check</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">ref</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">,</span> <span class="Keyword">var</span><span class="Punctuation">,</span> <span class="Identifier">set</span><span class="Punctuation">,</span> <span class="Identifier">seq</span><span class="Punctuation">,</span> <span class="Identifier">openarray</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">range</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
        <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeA</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeA</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">rangeB</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">rangeB</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Identifier">array</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Keyword">tuple</span><span class="Punctuation">:</span>
      <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Punctuation">:</span>
        <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">tupleLen</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span>
          <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">false</span>
        <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="Keyword">object</span><span class="Punctuation">,</span> <span class="Keyword">enum</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span>
    <span class="Keyword">of</span> <span class="Keyword">proc</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">parameterTuple</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">resultType</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
               <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">callingConvention</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">callingConvention</span>
  <span class="Keyword">elif</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">elif</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Keyword">distinct</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="subtype-relation" href="#subtype-relation">Subtype relation</a></h2><p>If object <tt class="docutils literal"><span class="pre">a</span></tt> inherits from <tt class="docutils literal"><span class="pre">b</span></tt>, <tt class="docutils literal"><span class="pre">a</span></tt> is a subtype of <tt class="docutils literal"><span class="pre">b</span></tt>. This subtype relation is extended to the types <tt class="docutils literal"><span class="pre">var</span></tt>, <tt class="docutils literal"><span class="pre">ref</span></tt>, <tt class="docutils literal"><span class="pre">ptr</span></tt>:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">kind</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
    <span class="Keyword">of</span> <span class="Keyword">object</span><span class="Punctuation">:</span>
      <span class="Keyword">var</span> <span class="Identifier">aa</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span>
      <span class="Keyword">while</span> <span class="Identifier">aa</span> <span class="Operator">!=</span> <span class="Keyword">nil</span> <span class="Keyword">and</span> <span class="Identifier">aa</span> <span class="Operator">!=</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">aa</span> <span class="Operator">=</span> <span class="Identifier">aa</span><span class="Operator">.</span><span class="Identifier">baseType</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">aa</span> <span class="Operator">==</span> <span class="Identifier">b</span>
    <span class="Keyword">of</span> <span class="Keyword">var</span><span class="Punctuation">,</span> <span class="Keyword">ref</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="convertible-relation" href="#convertible-relation">Convertible relation</a></h2><p>A type <tt class="docutils literal"><span class="pre">a</span></tt> is <strong>implicitly</strong> convertible to type <tt class="docutils literal"><span class="pre">b</span></tt> iff the following algorithm returns true:</p>
<pre><span class="Comment"># XXX range types?</span>
<span class="Keyword">proc</span> <span class="Identifier">isImplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
  <span class="Keyword">of</span> <span class="Identifier">int</span><span class="Punctuation">:</span>     <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int8</span><span class="Punctuation">,</span> <span class="Identifier">int16</span><span class="Punctuation">,</span> <span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">uint</span><span class="Punctuation">,</span> <span class="Identifier">uint8</span><span class="Punctuation">,</span> <span class="Identifier">uint16</span><span class="Punctuation">,</span>
                             <span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">int8</span><span class="Punctuation">:</span>    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int16</span><span class="Punctuation">,</span> <span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">int16</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">int32</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint</span><span class="Punctuation">:</span>    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint8</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint16</span><span class="Punctuation">,</span> <span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint16</span><span class="Punctuation">:</span>  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint32</span><span class="Punctuation">:</span>  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">float</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">float32</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float64</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">float64</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">seq</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">openArray</span> <span class="Keyword">and</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
  <span class="Keyword">of</span> <span class="Identifier">array</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">openArray</span> <span class="Keyword">and</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
    <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span> <span class="Operator">==</span> <span class="Identifier">char</span> <span class="Keyword">and</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Operator">.</span><span class="Identifier">rangeA</span> <span class="Operator">==</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">cstring</span>
  <span class="Keyword">of</span> <span class="Identifier">cstring</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">pointer</span>
  <span class="Keyword">of</span> <span class="Identifier">string</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">cstring</span></pre><p>A type <tt class="docutils literal"><span class="pre">a</span></tt> is <strong>explicitly</strong> convertible to type <tt class="docutils literal"><span class="pre">b</span></tt> iff the following algorithm returns true:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">isIntegralType</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">isOrdinal</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">)</span> <span class="Keyword">or</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float64</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">isExplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Keyword">if</span> <span class="Identifier">isImplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">isIntegralType</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="Identifier">isIntegralType</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Keyword">or</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span></pre><p>The convertible relation can be relaxed by a user-defined type <span id="converter_1">converter</span>.</p>
<pre><span class="Keyword">converter</span> <span class="Identifier">toInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">chr</span><span class="Punctuation">:</span> <span class="Identifier">char</span> <span class="Operator">=</span> <span class="CharLit">'a'</span>

<span class="Comment"># implicit conversion magic happens here</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">chr</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># =&gt; 97</span>
<span class="Comment"># you can use the explicit form too</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">chr</span><span class="Operator">.</span><span class="Identifier">toInt</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># =&gt; 97</span></pre><p>The type conversion <tt class="docutils literal"><span class="pre">T(a)</span></tt> is an L-value if <tt class="docutils literal"><span class="pre">a</span></tt> is an L-value and <tt class="docutils literal"><span class="pre">typeEqualsOrDistinct(T, type(a))</span></tt> holds.</p>

<h2><a class="toc-backref" id="assignment-compatibility" href="#assignment-compatibility">Assignment compatibility</a></h2><p>An expression <tt class="docutils literal"><span class="pre">b</span></tt> can be assigned to an expression <tt class="docutils literal"><span class="pre">a</span></tt> iff <tt class="docutils literal"><span class="pre">a</span></tt> is an <cite>l-value</cite> and <tt class="docutils literal"><span class="pre">isImplicitlyConvertible(b.typ, a.typ)</span></tt> holds.</p>

<h2><a class="toc-backref" id="overloading-resolution" href="#overloading-resolution">Overloading resolution</a></h2><p>To be written. </p>

<h1><a class="toc-backref" id="statements-and-expressions" href="#statements-and-expressions">Statements and expressions</a></h1><p>Nim uses the common statement/expression paradigm: Statements do not produce a value in contrast to expressions. However, some expressions are statements.</p>
<p>Statements are separated into <span id="simple-statements_1">simple statements</span> and <span id="complex-statements_1">complex statements</span>. Simple statements are statements that cannot contain other statements like assignments, calls or the <tt class="docutils literal"><span class="pre">return</span></tt> statement; complex statements can contain other statements. To avoid the <span id="dangling-else-problem_1">dangling else problem</span>, complex statements always have to be intended. The details can be found in the grammar.</p>

<h2><a class="toc-backref" id="statement-list-expression" href="#statement-list-expression">Statement list expression</a></h2><p>Statements can also occur in an expression context that looks like <tt class="docutils literal"><span class="pre">(stmt1; stmt2; ...; ex)</span></tt>. This is called an statement list expression or <tt class="docutils literal"><span class="pre">(;)</span></tt>. The type of <tt class="docutils literal"><span class="pre">(stmt1; stmt2; ...; ex)</span></tt> is the type of <tt class="docutils literal"><span class="pre">ex</span></tt>. All the other statements must be of type <tt class="docutils literal"><span class="pre">void</span></tt>. (One can use <tt class="docutils literal"><span class="pre">discard</span></tt> to produce a <tt class="docutils literal"><span class="pre">void</span></tt> type.) <tt class="docutils literal"><span class="pre">(;)</span></tt> does not introduce a new scope.</p>

<h2><a class="toc-backref" id="discard-statement" href="#discard-statement">Discard statement</a></h2><p>Example:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Keyword">discard</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># discard the return value of `p`</span></pre><p>The <tt class="docutils literal"><span class="pre">discard</span></tt> statement evaluates its expression for side-effects and throws the expression's resulting value away.</p>
<p>Ignoring the return value of a procedure without using a discard statement is a static error.</p>
<p>The return value can be ignored implicitly if the called proc/iterator has been declared with the <span id="discardable_1">discardable</span> pragma:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">discardable</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># now valid</span></pre><p>An empty <tt class="docutils literal"><span class="pre">discard</span></tt> statement is often used as a null statement:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">classify</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">of</span> <span class="Identifier">SymChars</span><span class="Punctuation">,</span> <span class="CharLit">'_'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;an identifier&quot;</span>
  <span class="Keyword">of</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;a number&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">discard</span></pre>
<h2><a class="toc-backref" id="var-statement" href="#var-statement">Var statement</a></h2><p>Var statements declare new local and global variables and initialize them. A comma separated list of variables can be used to specify variables of the same type:</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>If an initializer is given the type can be omitted: the variable is then of the same type as the initializing expression. Variables are always initialized with a default value if there is no initializing expression. The default value depends on the type and is always a zero in binary.</p>
<table border="1" class="docutils"><tr><th>Type</th><th>default value</th></tr>
<tr><td>any integer type</td><td>0</td></tr>
<tr><td>any float</td><td>0.0</td></tr>
<tr><td>char</td><td>'\0'</td></tr>
<tr><td>bool</td><td>false</td></tr>
<tr><td>ref or pointer type</td><td>nil</td></tr>
<tr><td>procedural type</td><td>nil</td></tr>
<tr><td>sequence</td><td>nil (<em>not</em> <tt class="docutils literal"><span class="pre">@[]</span></tt>)</td></tr>
<tr><td>string</td><td>nil (<em>not</em> &quot;&quot;)</td></tr>
<tr><td>tuple[x: A, y: B, ...]</td><td>(default(A), default(B), ...) (analogous for objects)</td></tr>
<tr><td>array[0..., T]</td><td>[default(T), ...]</td></tr>
<tr><td>range[T]</td><td>default(T); this may be out of the valid range</td></tr>
<tr><td>T = enum</td><td>cast[T](0); this may be an invalid value</td></tr>
</table><p>The implicit initialization can be avoided for optimization reasons with the <span id="noinit_1">noinit</span> pragma:</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noInit</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">array</span> <span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">1023</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">]</span></pre><p>If a proc is annotated with the <tt class="docutils literal"><span class="pre">noinit</span></tt> pragma this refers to its implicit <tt class="docutils literal"><span class="pre">result</span></tt> variable:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">returnUndefinedValue</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noinit</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre><p>The implicit initialization can be also prevented by the <span id="requiresinit_1">requiresInit</span> type pragma. The compiler requires an explicit initialization then. However it does a <span id="control-flow-analysis_1">control flow analysis</span> to prove the variable has been initialized and does not rely on syntactic properties:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">MyObject</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">requiresInit</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># the following is valid:</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span>
  <span class="Keyword">if</span> <span class="Identifier">someCondition</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Identifier">use</span> <span class="Identifier">x</span></pre>
<h2><a class="toc-backref" id="let-statement" href="#let-statement">let statement</a></h2><p>A <tt class="docutils literal"><span class="pre">let</span></tt> statement declares new local and global <span id="single-assignment_1">single assignment</span> variables and binds a value to them. The syntax is the same as that of the <tt class="docutils literal"><span class="pre">var</span></tt> statement, except that the keyword <tt class="docutils literal"><span class="pre">var</span></tt> is replaced by the keyword <tt class="docutils literal"><span class="pre">let</span></tt>. Let variables are not l-values and can thus not be passed to <tt class="docutils literal"><span class="pre">var</span></tt> parameters nor can their address be taken. They cannot be assigned new values.</p>
<p>For let variables the same pragmas are available as for ordinary variables.</p>

<h2><a class="toc-backref" id="const-section" href="#const-section">Const section</a></h2><p><span id="constants_1">Constants</span> are symbols which are bound to a value. The constant's value cannot change. The compiler must be able to evaluate the expression in a constant declaration at compile time.</p>
<p>Nim contains a sophisticated compile-time evaluator, so procedures which have no side-effect can be used in constant expressions too:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">strutils</span>
<span class="Keyword">const</span>
  <span class="Identifier">constEval</span> <span class="Operator">=</span> <span class="Identifier">contains</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">)</span> <span class="Comment"># computed at compile time!</span></pre><p>The rules for compile-time computability are:</p>
<ol class="simple"><li>Literals are compile-time computable.</li>
<li>Type conversions are compile-time computable.</li>
<li>Procedure calls of the form <tt class="docutils literal"><span class="pre">p(X)</span></tt> are compile-time computable if <tt class="docutils literal"><span class="pre">p</span></tt> is a proc without side-effects (see the <a class="reference external" href="#nosideeffect-pragma">noSideEffect pragma</a> for details) and if <tt class="docutils literal"><span class="pre">X</span></tt> is a (possibly empty) list of compile-time computable arguments.</li>
</ol>
<p>Constants cannot be of type <tt class="docutils literal"><span class="pre">ptr</span></tt>, <tt class="docutils literal"><span class="pre">ref</span></tt>, <tt class="docutils literal"><span class="pre">var</span></tt> or <tt class="docutils literal"><span class="pre">object</span></tt>, nor can they contain such a type.</p>

<h2><a class="toc-backref" id="static-statement-expression" href="#static-statement-expression">Static statement/expression</a></h2><p>A static statement/expression can be used to enforce compile time evaluation explicitly. Enforced compile time evaluation can even evaluate code that has side effects:</p>
<pre><span class="Keyword">static</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;echo at compile time&quot;</span></pre><p>It's a static error if the compiler cannot perform the evaluation at compile time.</p>
<p>The current implementation poses some restrictions for compile time evaluation: Code which contains <tt class="docutils literal"><span class="pre">cast</span></tt> or makes use of the foreign function interface cannot be evaluated at compile time. Later versions of Nim will support the FFI at compile time.</p>

<h2><a class="toc-backref" id="if-statement" href="#if-statement">If statement</a></h2><p>Example:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>

<span class="Keyword">if</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;Andreas&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;What a nice name!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">elif</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Don't you have a name?&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Boring name...&quot;</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">if</span></tt> statement is a simple way to make a branch in the control flow: The expression after the keyword <tt class="docutils literal"><span class="pre">if</span></tt> is evaluated, if it is true the corresponding statements after the <tt class="docutils literal"><span class="pre">:</span></tt> are executed. Otherwise the expression after the <tt class="docutils literal"><span class="pre">elif</span></tt> is evaluated (if there is an <tt class="docutils literal"><span class="pre">elif</span></tt> branch), if it is true the corresponding statements after the <tt class="docutils literal"><span class="pre">:</span></tt> are executed. This goes on until the last <tt class="docutils literal"><span class="pre">elif</span></tt>. If all conditions fail, the <tt class="docutils literal"><span class="pre">else</span></tt> part is executed. If there is no <tt class="docutils literal"><span class="pre">else</span></tt> part, execution continues with the statement after the <tt class="docutils literal"><span class="pre">if</span></tt> statement.</p>
<p>The scoping for an <tt class="docutils literal"><span class="pre">if</span></tt> statement is slightly subtle to support an important use case. A new scope starts for the <tt class="docutils literal"><span class="pre">if</span></tt>/<tt class="docutils literal"><span class="pre">elif</span></tt> condition and ends after the corresponding <em>then</em> block:</p>
<pre><span class="Keyword">if</span> <span class="Punctuation">{</span><span class="Operator">|</span> <span class="Punctuation">(</span><span class="Keyword">let</span> <span class="Identifier">m</span> <span class="Operator">=</span> <span class="Identifier">input</span> <span class="Operator">=~</span> <span class="RawData">re&quot;(\w+)=\w+&quot;</span><span class="Punctuation">;</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">isMatch</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;key &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="StringLit">&quot; value &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span>  <span class="Operator">|</span><span class="Punctuation">}</span>
<span class="Keyword">elif</span> <span class="Punctuation">{</span><span class="Operator">|</span> <span class="Punctuation">(</span><span class="Keyword">let</span> <span class="Identifier">m</span> <span class="Operator">=</span> <span class="Identifier">input</span> <span class="Operator">=~</span> <span class="RawData">re&quot;&quot;</span><span class="Punctuation">;</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">isMatch</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;new m in this scope&quot;</span> <span class="Operator">|</span><span class="Punctuation">}</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Comment"># 'm' not declared here</span></pre><p>In the example the scopes have been enclosed in <tt class="docutils literal"><span class="pre">{| |}</span></tt>.</p>

<h2><a class="toc-backref" id="case-statement" href="#case-statement">Case statement</a></h2><p>Example:</p>
<pre><span class="Keyword">case</span> <span class="Identifier">readline</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;delete-everything&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;restart-computer&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;permission denied&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;go-for-a-walk&quot;</span><span class="Punctuation">:</span>     <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;please yourself&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>                   <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;unknown command&quot;</span><span class="Punctuation">)</span>

<span class="Comment"># indentation of the branches is also allowed; and so is an optional colon</span>
<span class="Comment"># after the selecting expression:</span>
<span class="Keyword">case</span> <span class="Identifier">readline</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;delete-everything&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;restart-computer&quot;</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;permission denied&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;go-for-a-walk&quot;</span><span class="Punctuation">:</span>     <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;please yourself&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>                   <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;unknown command&quot;</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">case</span></tt> statement is similar to the if statement, but it represents a multi-branch selection. The expression after the keyword <tt class="docutils literal"><span class="pre">case</span></tt> is evaluated and if its value is in a <em>slicelist</em> the corresponding statements (after the <tt class="docutils literal"><span class="pre">of</span></tt> keyword) are executed. If the value is not in any given <em>slicelist</em> the <tt class="docutils literal"><span class="pre">else</span></tt> part is executed. If there is no <tt class="docutils literal"><span class="pre">else</span></tt> part and not all possible values that <tt class="docutils literal"><span class="pre">expr</span></tt> can hold occur in a <tt class="docutils literal"><span class="pre">slicelist</span></tt>, a static error occurs. This holds only for expressions of ordinal types. &quot;All possible values&quot; of <tt class="docutils literal"><span class="pre">expr</span></tt> are determined by <tt class="docutils literal"><span class="pre">expr</span></tt>'s type. To suppress the static error an <tt class="docutils literal"><span class="pre">else</span></tt> part with an empty <tt class="docutils literal"><span class="pre">discard</span></tt> statement should be used.</p>
<p>For non ordinal types it is not possible to list every possible value and so these always require an <tt class="docutils literal"><span class="pre">else</span></tt> part.</p>
<p>As a special semantic extension, an expression in an <tt class="docutils literal"><span class="pre">of</span></tt> branch of a case statement may evaluate to a set or array constructor; the set or array is then expanded into a list of its elements:</p>
<pre><span class="Keyword">const</span>
  <span class="Identifier">SymChars</span><span class="Punctuation">:</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'A'</span><span class="Operator">..</span><span class="CharLit">'Z'</span><span class="Punctuation">,</span> <span class="CharLit">'\x80'</span><span class="Operator">..</span><span class="CharLit">'\xFF'</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">classify</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">of</span> <span class="Identifier">SymChars</span><span class="Punctuation">,</span> <span class="CharLit">'_'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;an identifier&quot;</span>
  <span class="Keyword">of</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;a number&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;other&quot;</span>

<span class="Comment"># is equivalent to:</span>
<span class="Keyword">proc</span> <span class="Identifier">classify</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">of</span> <span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'A'</span><span class="Operator">..</span><span class="CharLit">'Z'</span><span class="Punctuation">,</span> <span class="CharLit">'\x80'</span><span class="Operator">..</span><span class="CharLit">'\xFF'</span><span class="Punctuation">,</span> <span class="CharLit">'_'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;an identifier&quot;</span>
  <span class="Keyword">of</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;a number&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;other&quot;</span></pre>
<h2><a class="toc-backref" id="when-statement" href="#when-statement">When statement</a></h2><p>Example:</p>
<pre><span class="Keyword">when</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;running on a 16 bit system!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">elif</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">4</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;running on a 32 bit system!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">elif</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">8</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;running on a 64 bit system!&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;cannot happen!&quot;</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">when</span></tt> statement is almost identical to the <tt class="docutils literal"><span class="pre">if</span></tt> statement with some exceptions:</p>
<ul class="simple"><li>Each condition (<tt class="docutils literal"><span class="pre">expr</span></tt>) has to be a constant expression (of type <tt class="docutils literal"><span class="pre">bool</span></tt>).</li>
<li>The statements do not open a new scope.</li>
<li>The statements that belong to the expression that evaluated to true are translated by the compiler, the other statements are not checked for semantics! However, each condition is checked for semantics.</li>
</ul>
<p>The <tt class="docutils literal"><span class="pre">when</span></tt> statement enables conditional compilation techniques. As a special syntactic extension, the <tt class="docutils literal"><span class="pre">when</span></tt> construct is also available within <tt class="docutils literal"><span class="pre">object</span></tt> definitions.</p>

<h2><a class="toc-backref" id="return-statement" href="#return-statement">Return statement</a></h2><p>Example:</p>
<pre><span class="Keyword">return</span> <span class="DecNumber">40</span><span class="Operator">+</span><span class="DecNumber">2</span></pre><p>The <tt class="docutils literal"><span class="pre">return</span></tt> statement ends the execution of the current procedure. It is only allowed in procedures. If there is an <tt class="docutils literal"><span class="pre">expr</span></tt>, this is syntactic sugar for:</p>
<pre><span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">expr</span>
<span class="Keyword">return</span> <span class="Identifier">result</span></pre><p><tt class="docutils literal"><span class="pre">return</span></tt> without an expression is a short notation for <tt class="docutils literal"><span class="pre">return result</span></tt> if the proc has a return type. The <span id="result_1">result</span> variable is always the return value of the procedure. It is automatically declared by the compiler. As all variables, <tt class="docutils literal"><span class="pre">result</span></tt> is initialized to (binary) zero:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">returnZero</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># implicitly returns 0</span></pre>
<h2><a class="toc-backref" id="yield-statement" href="#yield-statement">Yield statement</a></h2><p>Example:</p>
<pre><span class="Keyword">yield</span> <span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">yield</span></tt> statement is used instead of the <tt class="docutils literal"><span class="pre">return</span></tt> statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but execution is passed back to the iterator if the next iteration starts. See the section about iterators (<a class="reference external" href="#iterators-and-the-for-statement">Iterators and the for statement</a>) for further information.</p>

<h2><a class="toc-backref" id="block-statement" href="#block-statement">Block statement</a></h2><p>Example:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">found</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Keyword">block</span> <span class="Identifier">myblock</span><span class="Punctuation">:</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">3</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">j</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">3</span><span class="Punctuation">:</span>
      <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">j</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="DecNumber">7</span><span class="Punctuation">:</span>
        <span class="Identifier">found</span> <span class="Operator">=</span> <span class="Identifier">true</span>
        <span class="Keyword">break</span> <span class="Identifier">myblock</span> <span class="Comment"># leave the block, in this case both for-loops</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">found</span><span class="Punctuation">)</span></pre><p>The block statement is a means to group statements to a (named) <tt class="docutils literal"><span class="pre">block</span></tt>. Inside the block, the <tt class="docutils literal"><span class="pre">break</span></tt> statement is allowed to leave the block immediately. A <tt class="docutils literal"><span class="pre">break</span></tt> statement can contain a name of a surrounding block to specify which block is to leave.</p>

<h2><a class="toc-backref" id="break-statement" href="#break-statement">Break statement</a></h2><p>Example:</p>
<pre><span class="Keyword">break</span></pre><p>The <tt class="docutils literal"><span class="pre">break</span></tt> statement is used to leave a block immediately. If <tt class="docutils literal"><span class="pre">symbol</span></tt> is given, it is the name of the enclosing block that is to leave. If it is absent, the innermost block is left.</p>

<h2><a class="toc-backref" id="while-statement" href="#while-statement">While statement</a></h2><p>Example:</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Please tell me your password: </span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">pw</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">while</span> <span class="Identifier">pw</span> <span class="Operator">!=</span> <span class="StringLit">&quot;12345&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Wrong password! Next try: </span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">pw</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">while</span></tt> statement is executed until the <tt class="docutils literal"><span class="pre">expr</span></tt> evaluates to false. Endless loops are no error. <tt class="docutils literal"><span class="pre">while</span></tt> statements open an <cite>implicit block</cite>, so that they can be left with a <tt class="docutils literal"><span class="pre">break</span></tt> statement.</p>

<h2><a class="toc-backref" id="continue-statement" href="#continue-statement">Continue statement</a></h2><p>A <tt class="docutils literal"><span class="pre">continue</span></tt> statement leads to the immediate next iteration of the surrounding loop construct. It is only allowed within a loop. A continue statement is syntactic sugar for a nested block:</p>
<pre><span class="Keyword">while</span> <span class="Identifier">expr1</span><span class="Punctuation">:</span>
  <span class="Identifier">stmt1</span>
  <span class="Keyword">continue</span>
  <span class="Identifier">stmt2</span></pre><p>Is equivalent to:</p>
<pre><span class="Keyword">while</span> <span class="Identifier">expr1</span><span class="Punctuation">:</span>
  <span class="Keyword">block</span> <span class="Identifier">myBlockName</span><span class="Punctuation">:</span>
    <span class="Identifier">stmt1</span>
    <span class="Keyword">break</span> <span class="Identifier">myBlockName</span>
    <span class="Identifier">stmt2</span></pre>
<h2><a class="toc-backref" id="assembler-statement" href="#assembler-statement">Assembler statement</a></h2><p>The direct embedding of assembler code into Nim code is supported by the unsafe <tt class="docutils literal"><span class="pre">asm</span></tt> statement. Identifiers in the assembler code that refer to Nim identifiers shall be enclosed in a special character which can be specified in the statement's pragmas. The default special character is <tt class="docutils literal"><span class="pre">'`'</span></tt>:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">stackTrace</span><span class="Punctuation">:</span><span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">addInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># a in eax, and b in edx</span>
  <span class="Keyword">asm</span> <span class="LongStringLit">&quot;&quot;&quot;
      mov eax, `a`
      add eax, `b`
      jno theEnd
      call `raiseOverflow`
    theEnd:
  &quot;&quot;&quot;</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>If the GNU assembler is used, quotes and newlines are inserted automatically:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">addInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">asm</span> <span class="LongStringLit">&quot;&quot;&quot;
    addl %%ecx, %%eax
    jno 1
    call `raiseOverflow`
    1:
    :&quot;=a&quot;(`result`)
    :&quot;a&quot;(`a`), &quot;c&quot;(`b`)
  &quot;&quot;&quot;</span></pre><p>Instead of:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">addInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">asm</span> <span class="LongStringLit">&quot;&quot;&quot;
    &quot;addl %%ecx, %%eax\n&quot;
    &quot;jno 1\n&quot;
    &quot;call `raiseOverflow`\n&quot;
    &quot;1: \n&quot;
    :&quot;=a&quot;(`result`)
    :&quot;a&quot;(`a`), &quot;c&quot;(`b`)
  &quot;&quot;&quot;</span></pre>
<h2><a class="toc-backref" id="using-statement" href="#using-statement">Using statement</a></h2><p><strong>Warning</strong>: The <tt class="docutils literal"><span class="pre">using</span></tt> statement is highly experimental and has to be explicitly enabled with the <span id="experimental_1">experimental</span> pragma or command line option!</p>
<p>The using statement provides syntactic convenience for procs that heavily use a single contextual parameter. When applied to a variable or a constant, it will instruct Nim to automatically consider the used symbol as a hidden leading parameter for any procedure calls, following the using statement in the current scope. Thus, it behaves much like the hidden <cite>this</cite> parameter available in some object-oriented programming languages.</p>
<pre><span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="Identifier">socket</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">using</span> <span class="Identifier">s</span>

<span class="Identifier">connect</span><span class="Punctuation">(</span><span class="Identifier">host</span><span class="Punctuation">,</span> <span class="Identifier">port</span><span class="Punctuation">)</span>
<span class="Identifier">send</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">)</span>

<span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">line</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">timeout</span><span class="Punctuation">)</span>
  <span class="Operator">...</span></pre><p>When applied to a callable symbol, it brings the designated symbol in the current scope. Thus, it can be used to disambiguate between imported symbols from different modules having the same name.</p>
<pre><span class="Keyword">import</span> <span class="Identifier">windows</span><span class="Punctuation">,</span> <span class="Identifier">sdl</span>
<span class="Keyword">using</span> <span class="Identifier">sdl</span><span class="Operator">.</span><span class="Identifier">SetTimer</span></pre><p>Note that <tt class="docutils literal"><span class="pre">using</span></tt> only <em>adds</em> to the current context, it doesn't remove or replace, <strong>neither</strong> does it create a new scope. What this means is that if one applies this to multiple variables the compiler will find conflicts in what variable to use:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="StringLit">&quot;kill it&quot;</span>
<span class="Keyword">using</span> <span class="Identifier">a</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="StringLit">&quot; with fire&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">using</span> <span class="Identifier">b</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="StringLit">&quot; with water&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span>
<span class="Identifier">echo</span> <span class="Identifier">b</span></pre><p>When the compiler reaches the second <tt class="docutils literal"><span class="pre">add</span></tt> call, both <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> could be used with the proc, so one gets <tt class="docutils literal"><span class="pre">Error: expression '(a|b)' has no type (or is ambiguous)</span></tt>. To solve this one would need to nest <tt class="docutils literal"><span class="pre">using</span></tt> with a <tt class="docutils literal"><span class="pre">block</span></tt> statement so as to control the reach of the <tt class="docutils literal"><span class="pre">using</span></tt> statement.</p>

<h2><a class="toc-backref" id="if-expression" href="#if-expression">If expression</a></h2><p>An <cite>if expression</cite> is almost like an if statement, but it is an expression. Example:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Operator">&gt;</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="DecNumber">9</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="DecNumber">10</span></pre><p>An if expression always results in a value, so the <tt class="docutils literal"><span class="pre">else</span></tt> part is required. <tt class="docutils literal"><span class="pre">Elif</span></tt> parts are also allowed.</p>

<h2><a class="toc-backref" id="when-expression" href="#when-expression">When expression</a></h2><p>Just like an <cite>if expression</cite>, but corresponding to the when statement.</p>

<h2><a class="toc-backref" id="case-expression" href="#case-expression">Case expression</a></h2><p>The <cite>case expression</cite> is again very similar to the case statement:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">favoriteFood</span> <span class="Operator">=</span> <span class="Keyword">case</span> <span class="Identifier">animal</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;dog&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;bones&quot;</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;cat&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;mice&quot;</span>
  <span class="Keyword">elif</span> <span class="Identifier">animal</span><span class="Operator">.</span><span class="RawData">endsWith&quot;whale&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;plankton&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;I'm not sure what to serve, but everybody loves ice cream&quot;</span>
    <span class="StringLit">&quot;ice cream&quot;</span></pre><p>As seen in the above example, the case expression can also introduce side effects. When multiple statements are given for a branch, Nim will use the last expression as the result value, much like in an <cite>expr</cite> template.</p>

<h2><a class="toc-backref" id="table-constructor" href="#table-constructor">Table constructor</a></h2><p>A table constructor is syntactic sugar for an array constructor:</p>
<pre><span class="Punctuation">{</span><span class="StringLit">&quot;key1&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;value1&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;key2&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;key3&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;value2&quot;</span><span class="Punctuation">}</span>

<span class="Comment"># is the same as:</span>
<span class="Punctuation">[</span><span class="Punctuation">(</span><span class="StringLit">&quot;key1&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value1&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="StringLit">&quot;key2&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value2&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="StringLit">&quot;key3&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value2&quot;</span><span class="Punctuation">)</span><span class="Punctuation">]</span></pre><p>The empty table can be written <tt class="docutils literal"><span class="pre">{:}</span></tt> (in contrast to the empty set which is <tt class="docutils literal"><span class="pre">{}</span></tt>) which is thus another way to write as the empty array constructor <tt class="docutils literal"><span class="pre">[]</span></tt>. This slightly unusal way of supporting tables has lots of advantages:</p>
<ul class="simple"><li>The order of the (key,value)-pairs is preserved, thus it is easy to support ordered dicts with for example <tt class="docutils literal"><span class="pre">{key: val}.newOrderedTable</span></tt>.</li>
<li>A table literal can be put into a <tt class="docutils literal"><span class="pre">const</span></tt> section and the compiler can easily put it into the executable's data section just like it can for arrays and the generated data section requires a minimal amount of memory.</li>
<li>Every table implementation is treated equal syntactically.</li>
<li>Apart from the minimal syntactic sugar the language core does not need to know about tables.</li>
</ul>

<h2><a class="toc-backref" id="type-conversions" href="#type-conversions">Type conversions</a></h2><p>Syntactically a <cite>type conversion</cite> is like a procedure call, but a type name replaces the procedure name. A type conversion is always safe in the sense that a failure to convert a type to another results in an exception (if it cannot be determined statically).</p>
<p>Ordinary procs are often preferred over type conversions in Nim: For instance, <tt class="docutils literal"><span class="pre">$</span></tt> is the <tt class="docutils literal"><span class="pre">toString</span></tt> operator by convention and <tt class="docutils literal"><span class="pre">toFloat</span></tt> and <tt class="docutils literal"><span class="pre">toInt</span></tt> can be used to convert from floating point to integer or vice versa.</p>

<h2><a class="toc-backref" id="type-casts" href="#type-casts">Type casts</a></h2><p>Example:</p>
<pre><span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>Type casts are a crude mechanism to interpret the bit pattern of an expression as if it would be of another type. Type casts are only needed for low-level programming and are inherently unsafe.</p>

<h2><a class="toc-backref" id="the-addr-operator" href="#the-addr-operator">The addr operator</a></h2><p>The <tt class="docutils literal"><span class="pre">addr</span></tt> operator returns the address of an l-value. If the type of the location is <tt class="docutils literal"><span class="pre">T</span></tt>, the <cite>addr</cite> operator result is of the type <tt class="docutils literal"><span class="pre">ptr T</span></tt>. An address is always an untraced reference. Taking the address of an object that resides on the stack is <strong>unsafe</strong>, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through <tt class="docutils literal"><span class="pre">let</span></tt> statements:</p>
<pre><span class="Keyword">let</span> <span class="Identifier">t1</span> <span class="Operator">=</span> <span class="StringLit">&quot;Hello&quot;</span>
<span class="Keyword">var</span>
  <span class="Identifier">t2</span> <span class="Operator">=</span> <span class="Identifier">t1</span>
  <span class="Identifier">t3</span> <span class="Punctuation">:</span> <span class="Identifier">pointer</span> <span class="Operator">=</span> <span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">t2</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">t2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; ref 0x7fff6b71b670 --&gt; 0x10bb81050&quot;Hello&quot;</span>
<span class="Identifier">echo</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Keyword">ptr</span> <span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">t3</span><span class="Punctuation">)</span><span class="Punctuation">[</span><span class="Punctuation">]</span>
<span class="Comment"># --&gt; Hello</span>
<span class="Comment"># The following line doesn't compile:</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">t1</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># Error: expression has no address</span></pre>
<h1><a class="toc-backref" id="procedures" href="#procedures">Procedures</a></h1><p>What most programming languages call <span id="methods_1">methods</span> or <span id="functions_1">functions</span> are called <span id="procedures_1">procedures</span> in Nim (which is the correct terminology). A procedure declaration defines an identifier and associates it with a block of code. A procedure may call itself recursively. A parameter may be given a default value that is used if the caller does not provide a value for this parameter.</p>
<p>If the proc declaration has no body, it is a <span id="forward_1">forward</span> declaration. If the proc returns a value, the procedure body can access an implicitly declared variable named <span id="result_2">result</span> that represents the return value. Procs can be overloaded. The overloading resolution algorithm tries to find the proc that is the best match for the arguments. Example:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">toLower</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">char</span> <span class="Operator">=</span> <span class="Comment"># toLower for characters</span>
  <span class="Keyword">if</span> <span class="Identifier">c</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="CharLit">'A'</span><span class="Operator">..</span><span class="CharLit">'Z'</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">chr</span><span class="Punctuation">(</span><span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Punctuation">(</span><span class="Identifier">ord</span><span class="Punctuation">(</span><span class="CharLit">'a'</span><span class="Punctuation">)</span> <span class="Operator">-</span> <span class="Identifier">ord</span><span class="Punctuation">(</span><span class="CharLit">'A'</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">c</span>

<span class="Keyword">proc</span> <span class="Identifier">toLower</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Comment"># toLower for strings</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newString</span><span class="Punctuation">(</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">toLower</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># calls toLower for characters; no recursion!</span></pre><p>Calling a procedure can be done in many different ways:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">false</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Comment"># call with positional arguments # parameter bindings:</span>
<span class="Identifier">callme</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span><span class="Punctuation">,</span> <span class="Identifier">true</span><span class="Punctuation">)</span>  <span class="Comment"># (x=0, y=1, s=&quot;abc&quot;, c='\t', b=true)</span>
<span class="Comment"># call with named and positional arguments:</span>
<span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Operator">=</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Operator">=</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abd&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span><span class="Punctuation">)</span>    <span class="Comment"># (x=0, y=1, s=&quot;abd&quot;, c='\t', b=false)</span>
<span class="Comment"># call with named arguments (order is not relevant):</span>
<span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Operator">=</span><span class="CharLit">'\t'</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Operator">=</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Operator">=</span><span class="DecNumber">0</span><span class="Punctuation">)</span>         <span class="Comment"># (x=0, y=1, s=&quot;&quot;, c='\t', b=false)</span>
<span class="Comment"># call as a command statement: no () needed:</span>
<span class="Identifier">callme</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span></pre><p>A procedure cannot modify its parameters (unless the parameters have the type <cite>var</cite>).</p>
<p><span id="operators_1">Operators</span> are procedures with a special operator symbol as identifier:</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Comment"># converts an integer to a string; this is a prefix operator.</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">intToStr</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>Operators with one parameter are prefix operators, operators with two parameters are infix operators. (However, the parser distinguishes these from the operator's position within an expression.) There is no way to declare postfix operators: all postfix operators are built-in and handled by the grammar explicitly.</p>
<p>Any operator can be called like an ordinary proc with the '<cite>opr</cite>' notation. (Thus an operator can have more than two parameters):</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># Multiply and add</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">*</span> <span class="Identifier">b</span> <span class="Operator">+</span> <span class="Identifier">c</span>

<span class="Identifier">assert</span> <span class="Punctuation">`</span><span class="Operator">*+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="export-marker" href="#export-marker">Export marker</a></h2><p>If a declared symbol is marked with an <span id="asterisk_1">asterisk</span> it is exported from the current module:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">exportedEcho</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="Identifier">s</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">;</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newStringOfCap</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">*</span> <span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">a</span>

<span class="Keyword">var</span> <span class="Identifier">exportedVar</span><span class="Operator">*:</span> <span class="Identifier">int</span>
<span class="Keyword">const</span> <span class="Identifier">exportedConst</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="DecNumber">78</span>
<span class="Keyword">type</span>
  <span class="Identifier">ExportedType</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">exportedField</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre>
<h2><a class="toc-backref" id="method-call-syntax" href="#method-call-syntax">Method call syntax</a></h2><p>For object oriented programming, the syntax <tt class="docutils literal"><span class="pre">obj.method(args)</span></tt> can be used instead of <tt class="docutils literal"><span class="pre">method(obj, args)</span></tt>. The parentheses can be omitted if there are no remaining arguments: <tt class="docutils literal"><span class="pre">obj.len</span></tt> (instead of <tt class="docutils literal"><span class="pre">len(obj)</span></tt>).</p>
<p>This method call syntax is not restricted to objects, it can be used to supply any type of first argument for procedures:</p>
<pre><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span> <span class="Comment"># is the same as echo(len(&quot;abc&quot;))</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">toUpper</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">,</span> <span class="CharLit">'c'</span><span class="Punctuation">}</span><span class="Operator">.</span><span class="Identifier">card</span><span class="Punctuation">)</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hallo&quot;</span><span class="Punctuation">)</span> <span class="Comment"># the same as writeln(stdout, &quot;Hallo&quot;)</span></pre><p>Another way to look at the method call syntax is that it provides the missing postfix notation.</p>
<p>See also: <a class="reference external" href="#limitations-of-the-method-call-syntax">Limitations of the method call syntax</a>.</p>

<h2><a class="toc-backref" id="properties" href="#properties">Properties</a></h2><p>Nim has no need for <em>get-properties</em>: Ordinary get-procedures that are called with the <em>method call syntax</em> achieve the same. But setting a value is different; for this a special setter syntax is needed:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Socket</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">FHost</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># cannot be accessed from the outside of the module</span>
               <span class="Comment"># the `F` prefix is a convention to avoid clashes since</span>
               <span class="Comment"># the accessors are named `host`</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Identifier">host</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Socket</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## setter of hostAddr</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">FHost</span> <span class="Operator">=</span> <span class="Identifier">value</span>

<span class="Keyword">proc</span> <span class="Identifier">host</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## getter of hostAddr</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">FHost</span>

<span class="Keyword">var</span>
  <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span>
<span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">host</span> <span class="Operator">=</span> <span class="DecNumber">34</span>  <span class="Comment"># same as `host=`(s, 34)</span></pre>
<h2><a class="toc-backref" id="command-invocation-syntax" href="#command-invocation-syntax">Command invocation syntax</a></h2><p>Routines can be invoked without the <tt class="docutils literal"><span class="pre">()</span></tt> if the call is syntatically a statement. This command invocation syntax also works for expressions, but then only a single argument may follow. This restriction means <tt class="docutils literal"><span class="pre">echo f 1, f 2</span></tt> is parsed as <tt class="docutils literal"><span class="pre">echo(f(1), f(2))</span></tt> and not as <tt class="docutils literal"><span class="pre">echo(f(1, f(2)))</span></tt>. The method call syntax may be used to provide one more argument in this case:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">optarg</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>
<span class="Keyword">proc</span> <span class="Identifier">singlearg</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">20</span><span class="Operator">*</span><span class="Identifier">x</span>

<span class="Identifier">echo</span> <span class="Identifier">optarg</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">singlearg</span> <span class="DecNumber">2</span>  <span class="Comment"># prints &quot;1 40&quot;</span>

<span class="Keyword">let</span> <span class="Identifier">fail</span> <span class="Operator">=</span> <span class="Identifier">optarg</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">optarg</span> <span class="DecNumber">8</span>   <span class="Comment"># Wrong. Too many arguments for a command call</span>
<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">optarg</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">optarg</span> <span class="DecNumber">8</span><span class="Punctuation">)</span>  <span class="Comment"># traditional procedure call with 2 arguments</span>
<span class="Keyword">let</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="FloatNumber">1.</span><span class="Identifier">optarg</span> <span class="Identifier">optarg</span> <span class="DecNumber">8</span>    <span class="Comment"># same thing as above, w/o the parenthesis</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="Identifier">y</span></pre><p>The command invocation syntax also can't have complex expressions as arguments. For example: (<a class="reference external" href="#anonymous-procs">anonymous procs</a>), <tt class="docutils literal"><span class="pre">if</span></tt>, <tt class="docutils literal"><span class="pre">case</span></tt> or <tt class="docutils literal"><span class="pre">try</span></tt>. The (<a class="reference external" href="#do-notation">do notation</a>) is limited, but usable for a single proc (see the example in the corresponding section). Function calls with no arguments still needs () to distinguish between a call and the function itself as a first class value.</p>

<h2><a class="toc-backref" id="closures" href="#closures">Closures</a></h2><p>Procedures can appear at the top level in a module as well as inside other scopes, in which case they are called nested procs. A nested proc can access local variables from its enclosing scope and if it does so it becomes a closure. Any captured variables are stored in a hidden additional argument to the closure (its environment) and they are accessed by reference by both the closure and its enclosing scope (i.e. any modifications made to them are visible in both places). The closure environment may be allocated on the heap or on the stack if the compiler determines that this would be safe.</p>

<h2><a class="toc-backref" id="anonymous-procs" href="#anonymous-procs">Anonymous Procs</a></h2><p>Procs can also be treated as expressions, in which case it's allowed to omit the proc's name.</p>
<pre><span class="Keyword">var</span> <span class="Identifier">cities</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="StringLit">&quot;Frankfurt&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Tokyo&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;New York&quot;</span><span class="Punctuation">]</span>

<span class="Identifier">cities</span><span class="Operator">.</span><span class="Identifier">sort</span><span class="Punctuation">(</span><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>Procs as expressions can appear both as nested procs and inside top level executable code.</p>

<h2><a class="toc-backref" id="do-notation" href="#do-notation">Do notation</a></h2><p><strong>Note:</strong> The future of the <tt class="docutils literal"><span class="pre">do</span></tt> notation is uncertain.</p>
<p>As a special more convenient notation, proc expressions involved in procedure calls can use the <tt class="docutils literal"><span class="pre">do</span></tt> keyword:</p>
<pre><span class="Identifier">sort</span><span class="Punctuation">(</span><span class="Identifier">cities</span><span class="Punctuation">)</span> <span class="Keyword">do</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">int</span><span class="Punctuation">:</span>
  <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span>
<span class="Comment"># Less parenthesis using the method plus command syntax:</span>
<span class="Identifier">cities</span> <span class="Operator">=</span> <span class="Identifier">cities</span><span class="Operator">.</span><span class="Identifier">map</span> <span class="Keyword">do</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span><span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">string</span><span class="Punctuation">:</span>
  <span class="StringLit">&quot;City of &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">x</span></pre><p><tt class="docutils literal"><span class="pre">do</span></tt> is written after the parentheses enclosing the regular proc params. The proc expression represented by the do block is appended to them.</p>
<p>More than one <tt class="docutils literal"><span class="pre">do</span></tt> block can appear in a single call:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">performWithUndo</span><span class="Punctuation">(</span><span class="Identifier">task</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">undo</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Identifier">performWithUndo</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
  <span class="Comment"># multiple-line block of code</span>
  <span class="Comment"># to perform the task</span>
<span class="Keyword">do</span><span class="Punctuation">:</span>
  <span class="Comment"># code to undo it</span></pre>
<h2><a class="toc-backref" id="nonoverloadable-builtins" href="#nonoverloadable-builtins">Nonoverloadable builtins</a></h2><p>The following builtin procs cannot be overloaded for reasons of implementation simplicity (they require specialized semantic checking):<pre>
declared, defined, definedInScope, compiles, low, high, sizeOf,
is, of, shallowCopy, getAst, astToStr, spawn, procCall</pre>
</p>
<p>Thus they act more like keywords than like ordinary identifiers; unlike a keyword however, a redefinition may <span id="shadow_1">shadow</span> the definition in the <tt class="docutils literal"><span class="pre">system</span></tt> module. From this list the following should not be written in dot notation <tt class="docutils literal"><span class="pre">x.f</span></tt> since <tt class="docutils literal"><span class="pre">x</span></tt> cannot be type checked before it gets passed to <tt class="docutils literal"><span class="pre">f</span></tt>:<pre>
declared, defined, definedInScope, compiles, getAst, astToStr</pre>
</p>

<h2><a class="toc-backref" id="var-parameters" href="#var-parameters">Var parameters</a></h2><p>The type of a parameter may be prefixed with the <tt class="docutils literal"><span class="pre">var</span></tt> keyword:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span>
  <span class="Identifier">remainder</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Comment"># modifies x and y</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">y</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre><p>In the example, <tt class="docutils literal"><span class="pre">res</span></tt> and <tt class="docutils literal"><span class="pre">remainder</span></tt> are <cite>var parameters</cite>. Var parameters can be modified by the procedure and the changes are visible to the caller. The argument passed to a var parameter has to be an l-value. Var parameters are implemented as hidden pointers. The above example is equivalent to:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">res</span><span class="Punctuation">[</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span>
  <span class="Identifier">remainder</span><span class="Punctuation">[</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">y</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre><p>In the examples, var parameters or pointers are used to provide two return values. This can be done in a cleaner way by returning a tuple:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">t</span> <span class="Operator">=</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">res</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">remainder</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre><p>One can use <span id="tuple-unpacking_1">tuple unpacking</span> to access the tuple's fields:</p>
<pre><span class="Keyword">var</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment"># tuple unpacking</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">y</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre><p><strong>Note</strong>: <tt class="docutils literal"><span class="pre">var</span></tt> parameters are never necessary for efficient parameter passing. Since non-var parameters cannot be modified the compiler is always free to pass arguments by reference if it considers it can speed up execution.</p>

<h2><a class="toc-backref" id="var-return-type" href="#var-return-type">Var return type</a></h2><p>A proc, converter or iterator may return a <tt class="docutils literal"><span class="pre">var</span></tt> type which means that the returned value is an l-value and can be modified by the caller:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">g</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">proc</span> <span class="Identifier">WriteAccessToG</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">g</span>

<span class="Identifier">WriteAccessToG</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="DecNumber">6</span>
<span class="Identifier">assert</span> <span class="Identifier">g</span> <span class="Operator">==</span> <span class="DecNumber">6</span></pre><p>It is a compile time error if the implicitly introduced pointer could be used to access a location beyond its lifetime:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">WriteAccessToG</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">g</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">g</span> <span class="Comment"># Error!</span></pre><p>For iterators, a component of a tuple return type can have a <tt class="docutils literal"><span class="pre">var</span></tt> type too:</p>
<pre><span class="Keyword">iterator</span> <span class="Identifier">mpairs</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">key</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">val</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>In the standard library every name of a routine that returns a <tt class="docutils literal"><span class="pre">var</span></tt> type starts with the prefix <tt class="docutils literal"><span class="pre">m</span></tt> per convention.</p>

<h2><a class="toc-backref" id="overloading-of-the-subscript-operator" href="#overloading-of-the-subscript-operator">Overloading of the subscript operator</a></h2><p>The <tt class="docutils literal"><span class="pre">[]</span></tt> subscript operator for arrays/openarrays/sequences can be overloaded.</p>

<h1><a class="toc-backref" id="multi-methods" href="#multi-methods">Multi-methods</a></h1><p>Procedures always use static dispatch. Multi-methods use dynamic dispatch.</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Expression</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Comment">## abstract base class for an expression</span>
  <span class="Identifier">Literal</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Expression</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">PlusExpr</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Expression</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Expression</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Expression</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># override this base method</span>
  <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Literal</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Keyword">return</span> <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">x</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">PlusExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># watch out: relies on dynamic binding</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Literal</span> <span class="Operator">=</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">x</span>

<span class="Keyword">proc</span> <span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Expression</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">PlusExpr</span> <span class="Operator">=</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">b</span>

<span class="Identifier">echo</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>In the example the constructors <tt class="docutils literal"><span class="pre">newLit</span></tt> and <tt class="docutils literal"><span class="pre">newPlus</span></tt> are procs because they should use static binding, but <tt class="docutils literal"><span class="pre">eval</span></tt> is a method because it requires dynamic binding.</p>
<p>In a multi-method all parameters that have an object type are used for the dispatching:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Thing</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">Unit</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Thing</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;1&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;2&quot;</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span>
<span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Comment"># output: 2</span></pre><p>Invocation of a multi-method cannot be ambiguous: collide 2 is preferred over collide 1 because the resolution works from left to right. In the example <tt class="docutils literal"><span class="pre">Unit, Thing</span></tt> is preferred over <tt class="docutils literal"><span class="pre">Thing, Unit</span></tt>.</p>
<p><strong>Performance note</strong>: Nim does not produce a virtual method table, but generates dispatch trees. This avoids the expensive indirect branch for method calls and enables inlining. However, other optimizations like compile time evaluation or dead code elimination do not work with methods.</p>

<h1><a class="toc-backref" id="iterators-and-the-for-statement" href="#iterators-and-the-for-statement">Iterators and the for statement</a></h1><p>The <span id="for_1">for</span> statement is an abstract mechanism to iterate over the elements of a container. It relies on an <span id="iterator_1">iterator</span> to do so. Like <tt class="docutils literal"><span class="pre">while</span></tt> statements, <tt class="docutils literal"><span class="pre">for</span></tt> statements open an <span id="implicit-block_1">implicit block</span>, so that they can be left with a <tt class="docutils literal"><span class="pre">break</span></tt> statement.</p>
<p>The <tt class="docutils literal"><span class="pre">for</span></tt> loop declares iteration variables - their scope reaches until the end of the loop body. The iteration variables' types are inferred by the return type of the iterator.</p>
<p>An iterator is similar to a procedure, except that it can be called in the context of a <tt class="docutils literal"><span class="pre">for</span></tt> loop. Iterators provide a way to specify the iteration over an abstract type. A key role in the execution of a <tt class="docutils literal"><span class="pre">for</span></tt> loop plays the <tt class="docutils literal"><span class="pre">yield</span></tt> statement in the called iterator. Whenever a <tt class="docutils literal"><span class="pre">yield</span></tt> statement is reached the data is bound to the <tt class="docutils literal"><span class="pre">for</span></tt> loop variables and control continues in the body of the <tt class="docutils literal"><span class="pre">for</span></tt> loop. The iterator's local variables and execution state are automatically saved between calls. Example:</p>
<pre><span class="Comment"># this definition exists in the system module</span>
<span class="Keyword">iterator</span> <span class="Identifier">items</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">char</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span>

<span class="Keyword">for</span> <span class="Identifier">ch</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="StringLit">&quot;hello world&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Comment"># `ch` is an iteration variable</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">ch</span><span class="Punctuation">)</span></pre><p>The compiler generates code as if the programmer would have written this:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Keyword">while</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">ch</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">ch</span><span class="Punctuation">)</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span></pre><p>If the iterator yields a tuple, there can be as many iteration variables as there are components in the tuple. The i'th iteration variable's type is the type of the i'th component. In other words, implicit tuple unpacking in a for loop context is supported.</p>

<h2><a class="toc-backref" id="implict-items-pairs-invocations" href="#implict-items-pairs-invocations">Implict items/pairs invocations</a></h2><p>If the for loop expression <tt class="docutils literal"><span class="pre">e</span></tt> does not denote an iterator and the for loop has exactly 1 variable, the for loop expression is rewritten to <tt class="docutils literal"><span class="pre">items(e)</span></tt>; ie. an <tt class="docutils literal"><span class="pre">items</span></tt> iterator is implicitly invoked:</p>
<pre><span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">,</span><span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="Identifier">x</span></pre><p>If the for loop has exactly 2 variables, a <tt class="docutils literal"><span class="pre">pairs</span></tt> iterator is implicitly invoked.</p>
<p>Symbol lookup of the identifiers <tt class="docutils literal"><span class="pre">items</span></tt>/<tt class="docutils literal"><span class="pre">pairs</span></tt> is performed after the rewriting step, so that all overloadings of <tt class="docutils literal"><span class="pre">items</span></tt>/<tt class="docutils literal"><span class="pre">pairs</span></tt> are taken into account.</p>

<h2><a class="toc-backref" id="first-class-iterators" href="#first-class-iterators">First class iterators</a></h2><p>There are 2 kinds of iterators in Nim: <em>inline</em> and <em>closure</em> iterators. An <span id="inline-iterator_1">inline iterator</span> is an iterator that's always inlined by the compiler leading to zero overhead for the abstraction, but may result in a heavy increase in code size. Inline iterators are second class citizens; They can be passed as parameters only to other inlining code facilities like templates, macros and other inline iterators.</p>
<p>In contrast to that, a <span id="closure-iterator_1">closure iterator</span> can be passed around more freely:</p>
<pre><span class="Keyword">iterator</span> <span class="Identifier">count0</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">yield</span> <span class="DecNumber">0</span>

<span class="Keyword">iterator</span> <span class="Identifier">count2</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Keyword">yield</span> <span class="Identifier">x</span>
  <span class="Identifier">inc</span> <span class="Identifier">x</span>
  <span class="Keyword">yield</span> <span class="Identifier">x</span>

<span class="Keyword">proc</span> <span class="Identifier">invoke</span><span class="Punctuation">(</span><span class="Identifier">iter</span><span class="Punctuation">:</span> <span class="Keyword">iterator</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Identifier">iter</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="Identifier">x</span>

<span class="Identifier">invoke</span><span class="Punctuation">(</span><span class="Identifier">count0</span><span class="Punctuation">)</span>
<span class="Identifier">invoke</span><span class="Punctuation">(</span><span class="Identifier">count2</span><span class="Punctuation">)</span></pre><p>Closure iterators have other restrictions than inline iterators:</p>
<ol class="simple"><li><tt class="docutils literal"><span class="pre">yield</span></tt> in a closure iterator can not occur in a <tt class="docutils literal"><span class="pre">try</span></tt> statement.</li>
<li>For now, a closure iterator cannot be evaluated at compile time.</li>
<li><tt class="docutils literal"><span class="pre">return</span></tt> is allowed in a closure iterator (but rarely useful).</li>
<li>Both inline and closure iterators cannot be recursive.</li>
</ol>
<p>Iterators that are neither marked <tt class="docutils literal"><span class="pre">{.closure.}</span></tt> nor <tt class="docutils literal"><span class="pre">{.inline.}</span></tt> explicitly default to being inline, but that this may change in future versions of the implementation.</p>
<p>The <tt class="docutils literal"><span class="pre">iterator</span></tt> type is always of the calling convention <tt class="docutils literal"><span class="pre">closure</span></tt> implicitly; the following example shows how to use iterators to implement a <span id="collaborative-tasking_1">collaborative tasking</span> system:</p>
<pre><span class="Comment"># simple tasking:</span>
<span class="Keyword">type</span>
  <span class="Identifier">Task</span> <span class="Operator">=</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span>

<span class="Keyword">iterator</span> <span class="Identifier">a1</span><span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: A&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: B&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: C&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: D&quot;</span>

<span class="Keyword">iterator</span> <span class="Identifier">a2</span><span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a2: A&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a2: B&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a2: C&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">runTasks</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">Task</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">ticker</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">ticker</span> <span class="Keyword">mod</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">]</span>
    <span class="Keyword">if</span> <span class="Identifier">finished</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">break</span>
    <span class="Identifier">x</span><span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">)</span>
    <span class="Identifier">inc</span> <span class="Identifier">ticker</span>

<span class="Identifier">runTasks</span><span class="Punctuation">(</span><span class="Identifier">a1</span><span class="Punctuation">,</span> <span class="Identifier">a2</span><span class="Punctuation">)</span></pre><p>The builtin <tt class="docutils literal"><span class="pre">system.finished</span></tt> can be used to determine if an iterator has finished its operation; no exception is raised on an attempt to invoke an iterator that has already finished its work.</p>
<p>Note that <tt class="docutils literal"><span class="pre">system.finished</span></tt> is error prone to use because it only returns <tt class="docutils literal"><span class="pre">true</span></tt> one iteration after the iterator has finished:</p>
<pre><span class="Keyword">iterator</span> <span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Keyword">while</span> <span class="Identifier">x</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Identifier">x</span>
    <span class="Identifier">inc</span> <span class="Identifier">x</span>

<span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">mycount</span> <span class="Comment"># instantiate the iterator</span>
<span class="Keyword">while</span> <span class="Keyword">not</span> <span class="Identifier">finished</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">c</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>

<span class="Comment"># Produces</span>
<span class="DecNumber">1</span>
<span class="DecNumber">2</span>
<span class="DecNumber">3</span>
<span class="DecNumber">0</span></pre><p>Instead this code has be used:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">mycount</span> <span class="Comment"># instantiate the iterator</span>
<span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">value</span> <span class="Operator">=</span> <span class="Identifier">c</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>
  <span class="Keyword">if</span> <span class="Identifier">finished</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">break</span> <span class="Comment"># and discard 'value'!</span>
  <span class="Identifier">echo</span> <span class="Identifier">value</span></pre><p>It helps to think that the iterator actually returns a pair <tt class="docutils literal"><span class="pre">(value, done)</span></tt> and <tt class="docutils literal"><span class="pre">finished</span></tt> is used to access the hidden <tt class="docutils literal"><span class="pre">done</span></tt> field.</p>
<p>Closure iterators are <em>resumable functions</em> and so one has to provide the arguments to every call. To get around this limitation one can capture parameters of an outer factory proc:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span>
    <span class="Keyword">while</span> <span class="Identifier">x</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
      <span class="Keyword">yield</span> <span class="Identifier">x</span>
      <span class="Identifier">inc</span> <span class="Identifier">x</span>

<span class="Keyword">let</span> <span class="Identifier">foo</span> <span class="Operator">=</span> <span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span>

<span class="Keyword">for</span> <span class="Identifier">f</span> <span class="Keyword">in</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">f</span></pre>
<h1><a class="toc-backref" id="converters" href="#converters">Converters</a></h1><p>A converter is like an ordinary proc except that it enhances the &quot;implicitly convertible&quot; type relation (see <a class="reference external" href="#convertible-relation">Convertible relation</a>):</p>
<pre><span class="Comment"># bad style ahead: Nim is not C.</span>
<span class="Keyword">converter</span> <span class="Identifier">toBool</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">!=</span> <span class="DecNumber">0</span>

<span class="Keyword">if</span> <span class="DecNumber">4</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;compiles&quot;</span></pre><p>A converter can also be explicitly invoked for improved readability. Note that implicit converter chaining is not supported: If there is a converter from type A to type B and from type B to type C the implicit conversion from A to C is not provided. </p>

<h1><a class="toc-backref" id="type-sections" href="#type-sections">Type sections</a></h1><p>Example:</p>
<pre><span class="Keyword">type</span> <span class="Comment"># example demonstrating mutually recursive types</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span> <span class="Comment"># a traced pointer to a NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>     <span class="Comment"># left and right subtrees</span>
    <span class="Identifier">sym</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Sym</span>     <span class="Comment"># leaves contain a reference to a Sym</span>
  
  <span class="Identifier">Sym</span> <span class="Operator">=</span> <span class="Keyword">object</span>       <span class="Comment"># a symbol</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>     <span class="Comment"># the symbol's name</span>
    <span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">int</span>        <span class="Comment"># the line the symbol was declared in</span>
    <span class="Identifier">code</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>      <span class="Comment"># the symbol's abstract syntax tree</span></pre><p>A type section begins with the <tt class="docutils literal"><span class="pre">type</span></tt> keyword. It contains multiple type definitions. A type definition binds a type to a name. Type definitions can be recursive or even mutually recursive. Mutually recursive types are only possible within a single <tt class="docutils literal"><span class="pre">type</span></tt> section. Nominal types like <tt class="docutils literal"><span class="pre">objects</span></tt> or <tt class="docutils literal"><span class="pre">enums</span></tt> can only be defined in a <tt class="docutils literal"><span class="pre">type</span></tt> section.</p>

<h1><a class="toc-backref" id="exception-handling" href="#exception-handling">Exception handling</a></h1>
<h2><a class="toc-backref" id="try-statement" href="#try-statement">Try statement</a></h2><p>Example:</p>
<pre><span class="Comment"># read the first two lines of a text file that should contain numbers</span>
<span class="Comment"># and tries to add them</span>
<span class="Keyword">var</span>
  <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
<span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;sum: &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Punctuation">(</span><span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">OverflowError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;overflow!&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">ValueError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;could not convert string to integer&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;IO error!&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Unknown exception!&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span>
    <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span></pre><p>The statements after the <tt class="docutils literal"><span class="pre">try</span></tt> are executed in sequential order unless an exception <tt class="docutils literal"><span class="pre">e</span></tt> is raised. If the exception type of <tt class="docutils literal"><span class="pre">e</span></tt> matches any listed in an <tt class="docutils literal"><span class="pre">except</span></tt> clause the corresponding statements are executed. The statements following the <tt class="docutils literal"><span class="pre">except</span></tt> clauses are called <span id="exception-handlers_1">exception handlers</span>.</p>
<p>The empty <span id="except_1">except</span> clause is executed if there is an exception that is not listed otherwise. It is similar to an <tt class="docutils literal"><span class="pre">else</span></tt> clause in <tt class="docutils literal"><span class="pre">if</span></tt> statements.</p>
<p>If there is a <span id="finally_1">finally</span> clause, it is always executed after the exception handlers.</p>
<p>The exception is <em>consumed</em> in an exception handler. However, an exception handler may raise another exception. If the exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a <tt class="docutils literal"><span class="pre">finally</span></tt> clause - is not executed (if an exception occurs).</p>

<h2><a class="toc-backref" id="try-expression" href="#try-expression">Try expression</a></h2><p>Try can also be used as an expression; the type of the <tt class="docutils literal"><span class="pre">try</span></tt> branch then needs to fit the types of <tt class="docutils literal"><span class="pre">except</span></tt> branches, but the type of the <tt class="docutils literal"><span class="pre">finally</span></tt> branch always has to be <tt class="docutils literal"><span class="pre">void</span></tt>:</p>
<pre><span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Keyword">try</span><span class="Punctuation">:</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="StringLit">&quot;133a&quot;</span><span class="Punctuation">)</span>
        <span class="Keyword">except</span><span class="Punctuation">:</span> <span class="Operator">-</span><span class="DecNumber">1</span>
        <span class="Keyword">finally</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;hi&quot;</span></pre><p>To prevent confusing code there is a parsing limitation; if the <tt class="docutils literal"><span class="pre">try</span></tt> follows a <tt class="docutils literal"><span class="pre">(</span></tt> it has to be written as a one liner:</p>
<pre><span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">try</span><span class="Punctuation">:</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="StringLit">&quot;133a&quot;</span><span class="Punctuation">)</span> <span class="Keyword">except</span><span class="Punctuation">:</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="except-clauses" href="#except-clauses">Except clauses</a></h2><p>Within an <tt class="docutils literal"><span class="pre">except</span></tt> clause, it is possible to use <tt class="docutils literal"><span class="pre">getCurrentException</span></tt> to retrieve the exception that has been raised:</p>
<pre><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">e</span> <span class="Operator">=</span> <span class="Identifier">getCurrentException</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Comment"># Now use &quot;e&quot;</span></pre><p>Note that <tt class="docutils literal"><span class="pre">getCurrentException</span></tt> always returns a <tt class="docutils literal"><span class="pre">ref Exception</span></tt> type. If a variable of the proper type is needed (in the example above, <tt class="docutils literal"><span class="pre">IOError</span></tt>), one must convert it explicitly:</p>
<pre><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">e</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">ref</span> <span class="Identifier">IOError</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="Identifier">getCurrentException</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Comment"># &quot;e&quot; is now of the proper type</span></pre><p>However, this is seldom needed. The most common case is to extract an error message from <tt class="docutils literal"><span class="pre">e</span></tt>, and for such situations it is enough to use <tt class="docutils literal"><span class="pre">getCurrentExceptionMsg</span></tt>:</p>
<pre><span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;I/O error: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">getCurrentExceptionMsg</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="defer-statement" href="#defer-statement">Defer statement</a></h2><p>Instead of a <tt class="docutils literal"><span class="pre">try finally</span></tt> statement a <tt class="docutils literal"><span class="pre">defer</span></tt> statement can be used.</p>
<p>Any statements following the <tt class="docutils literal"><span class="pre">defer</span></tt> in the current block will be considered to be in an implicit try block:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">defer</span><span class="Punctuation">:</span> <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
<span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;abc&quot;</span>
<span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;def&quot;</span></pre><p>Is rewritten to:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;abc&quot;</span>
  <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;def&quot;</span>
<span class="Keyword">finally</span><span class="Punctuation">:</span>
  <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span></pre><p>Top level <tt class="docutils literal"><span class="pre">defer</span></tt> statements are not supported since it's unclear what such a statement should refer to.</p>

<h2><a class="toc-backref" id="raise-statement" href="#raise-statement">Raise statement</a></h2><p>Example:</p>
<pre><span class="Keyword">raise</span> <span class="Identifier">newEOS</span><span class="Punctuation">(</span><span class="StringLit">&quot;operating system failed&quot;</span><span class="Punctuation">)</span></pre><p>Apart from built-in operations like array indexing, memory allocation, etc. the <tt class="docutils literal"><span class="pre">raise</span></tt> statement is the only way to raise an exception.</p>
<p>If no exception name is given, the current exception is <span id="re-raised_1">re-raised</span>. The <span id="reraiseerror_1">ReraiseError</span> exception is raised if there is no exception to re-raise. It follows that the <tt class="docutils literal"><span class="pre">raise</span></tt> statement <em>always</em> raises an exception (unless a raise hook has been provided).</p>

<h2><a class="toc-backref" id="exception-hierarchy" href="#exception-hierarchy">Exception hierarchy</a></h2><p>The exception tree is defined in the <a class="reference external" href="system.html">system</a> module:</p>
<ul class="simple"><li><a class="reference external" href="system.html#Exception">Exception</a><ul class="simple"><li><a class="reference external" href="system.html#AccessViolationError">AccessViolationError</a></li>
<li><a class="reference external" href="system.html#ArithmeticError">ArithmeticError</a><ul class="simple"><li><a class="reference external" href="system.html#DivByZeroError">DivByZeroError</a></li>
<li><a class="reference external" href="system.html#OverflowError">OverflowError</a></li>
</ul>
</li>
<li><a class="reference external" href="system.html#AssertionError">AssertionError</a></li>
<li><a class="reference external" href="system.html#DeadThreadError">DeadThreadError</a></li>
<li><a class="reference external" href="system.html#FloatingPointError">FloatingPointError</a><ul class="simple"><li><a class="reference external" href="system.html#FloatDivByZeroError">FloatDivByZeroError</a></li>
<li><a class="reference external" href="system.html#FloatInexactError">FloatInexactError</a></li>
<li><a class="reference external" href="system.html#FloatInvalidOpError">FloatInvalidOpError</a></li>
<li><a class="reference external" href="system.html#FloatOverflowError">FloatOverflowError</a></li>
<li><a class="reference external" href="system.html#FloatUnderflowError">FloatUnderflowError</a></li>
</ul>
</li>
<li><a class="reference external" href="system.html#InvalidFieldError">FieldError</a></li>
<li><a class="reference external" href="system.html#InvalidIndexError">IndexError</a></li>
<li><a class="reference external" href="system.html#ObjectAssignmentError">ObjectAssignmentError</a></li>
<li><a class="reference external" href="system.html#ObjectConversionError">ObjectConversionError</a></li>
<li><a class="reference external" href="system.html#ValueError">ValueError</a><ul class="simple"><li><a class="reference external" href="system.html#KeyError">KeyError</a></li>
</ul>
</li>
<li><a class="reference external" href="system.html#ReraiseError">ReraiseError</a></li>
<li><a class="reference external" href="system.html#RangeError">RangeError</a></li>
<li><a class="reference external" href="system.html#OutOfMemoryError">OutOfMemoryError</a></li>
<li><a class="reference external" href="system.html#ResourceExhaustedError">ResourceExhaustedError</a></li>
<li><a class="reference external" href="system.html#StackOverflowError">StackOverflowError</a></li>
<li><a class="reference external" href="system.html#SystemError">SystemError</a><ul class="simple"><li><a class="reference external" href="system.html#IOError">IOError</a></li>
<li><a class="reference external" href="system.html#OSError">OSError</a><ul class="simple"><li><a class="reference external" href="system.html#LibraryError">LibraryError</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

<h1><a class="toc-backref" id="effect-system" href="#effect-system">Effect system</a></h1>
<h2><a class="toc-backref" id="exception-tracking" href="#exception-tracking">Exception tracking</a></h2><p>Nim supports exception tracking. The <span id="raises_1">raises</span> pragma can be used to explicitly define which exceptions a proc/iterator/method/converter is allowed to raise. The compiler verifies this:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">what</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="Identifier">OSError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">what</span><span class="Punctuation">:</span> <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;OS&quot;</span><span class="Punctuation">)</span></pre><p>An empty <tt class="docutils literal"><span class="pre">raises</span></tt> list (<tt class="docutils literal"><span class="pre">raises: []</span></tt>) means that no exception may be raised:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Identifier">unsafeCall</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Keyword">except</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span></pre><p>A <tt class="docutils literal"><span class="pre">raises</span></tt> list can also be attached to a proc type. This affects type compatibility:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Callback</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span>
  <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Callback</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;OS&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">p</span> <span class="Comment"># type error</span></pre><p>For a routine <tt class="docutils literal"><span class="pre">p</span></tt> the compiler uses inference rules to determine the set of possibly raised exceptions; the algorithm operates on <tt class="docutils literal"><span class="pre">p</span></tt>'s call graph:</p>
<ol class="simple"><li>Every indirect call via some proc type <tt class="docutils literal"><span class="pre">T</span></tt> is assumed to raise <tt class="docutils literal"><span class="pre">system.Exception</span></tt> (the base type of the exception hierarchy) and thus any exception unless <tt class="docutils literal"><span class="pre">T</span></tt> has an explicit <tt class="docutils literal"><span class="pre">raises</span></tt> list. However if the call is of the form <tt class="docutils literal"><span class="pre">f(...)</span></tt> where <tt class="docutils literal"><span class="pre">f</span></tt> is a parameter of the currently analysed routine it is ignored. The call is optimistically assumed to have no effect. Rule 2 compensates for this case.</li>
<li>Every expression of some proc type wihtin a call that is not a call itself (and not nil) is assumed to be called indirectly somehow and thus its raises list is added to <tt class="docutils literal"><span class="pre">p</span></tt>'s raises list.</li>
<li>Every call to a proc <tt class="docutils literal"><span class="pre">q</span></tt> which has an unknown body (due to a forward declaration or an <tt class="docutils literal"><span class="pre">importc</span></tt> pragma) is assumed to raise <tt class="docutils literal"><span class="pre">system.Exception</span></tt> unless <tt class="docutils literal"><span class="pre">q</span></tt> has an explicit <tt class="docutils literal"><span class="pre">raises</span></tt> list.</li>
<li>Every call to a method <tt class="docutils literal"><span class="pre">m</span></tt> is assumed to raise <tt class="docutils literal"><span class="pre">system.Exception</span></tt> unless <tt class="docutils literal"><span class="pre">m</span></tt> has an explicit <tt class="docutils literal"><span class="pre">raises</span></tt> list.</li>
<li>For every other call the analysis can determine an exact <tt class="docutils literal"><span class="pre">raises</span></tt> list.</li>
<li>For determining a <tt class="docutils literal"><span class="pre">raises</span></tt> list, the <tt class="docutils literal"><span class="pre">raise</span></tt> and <tt class="docutils literal"><span class="pre">try</span></tt> statements of <tt class="docutils literal"><span class="pre">p</span></tt> are taken into consideration.</li>
</ol>
<p>Rules 1-2 ensure the following works:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">noRaise</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># unknown call that might raise anything, but valid:</span>
  <span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">doRaise</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">use</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># doesn't compile! Can raise IOError!</span>
  <span class="Identifier">noRaise</span><span class="Punctuation">(</span><span class="Identifier">doRaise</span><span class="Punctuation">)</span></pre><p>So in many cases a callback does not cause the compiler to be overly conservative in its effect analysis.</p>

<h2><a class="toc-backref" id="tag-tracking" href="#tag-tracking">Tag tracking</a></h2><p>The exception tracking is part of Nim's <span id="effect-system_1">effect system</span>. Raising an exception is an <em>effect</em>. Other effects can also be defined. A user defined effect is a means to <em>tag</em> a routine and to perform checks against this tag:</p>
<pre><span class="Keyword">type</span> <span class="Identifier">IO</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Comment">## input/output effect</span>
<span class="Keyword">proc</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">tags</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IO</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">no_IO_please</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">tags</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># the compiler prevents this:</span>
  <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>A tag has to be a type name. A <tt class="docutils literal"><span class="pre">tags</span></tt> list - like a <tt class="docutils literal"><span class="pre">raises</span></tt> list - can also be attached to a proc type. This affects type compatibility.</p>
<p>The inference for tag tracking is analogous to the inference for exception tracking.</p>

<h2><a class="toc-backref" id="read-write-tracking" href="#read-write-tracking">Read/Write tracking</a></h2><p><strong>Note</strong>: Read/write tracking is not yet implemented!</p>
<p>The inference for read/write tracking is analogous to the inference for exception tracking.</p>

<h2><a class="toc-backref" id="effects-pragma" href="#effects-pragma">Effects pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">effects</span></tt> pragma has been designed to assist the programmer with the effects analysis. It is a statement that makes the compiler output all inferred effects up to the <tt class="docutils literal"><span class="pre">effects</span></tt>'s position:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">what</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">what</span><span class="Punctuation">:</span>
    <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">effects</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;OS&quot;</span><span class="Punctuation">)</span></pre><p>The compiler produces a hint message that <tt class="docutils literal"><span class="pre">IOError</span></tt> can be raised. <tt class="docutils literal"><span class="pre">OSError</span></tt> is not listed as it cannot be raised in the branch the <tt class="docutils literal"><span class="pre">effects</span></tt> pragma appears in. </p>

<h1><a class="toc-backref" id="generics" href="#generics">Generics</a></h1><p>Generics are Nim's means to parametrize procs, iterators or types with <span id="type-parameters_1">type parameters</span>. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type.</p>
<p>The following example shows a generic binary tree can be modelled:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">BinaryTreeObj</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>    <span class="Comment"># BinaryTreeObj is a generic type with</span>
                               <span class="Comment"># with generic param ``T``</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span>      <span class="Comment"># left and right subtrees; may be nil</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span>                    <span class="Comment"># the data stored in a node</span>
  <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">BinaryTreeObj</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Comment"># a shorthand for notational convenience</span>

<span class="Keyword">proc</span> <span class="Identifier">newNode</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Comment"># constructor for a node</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="Identifier">data</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">root</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Identifier">root</span> <span class="Operator">=</span> <span class="Identifier">n</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">root</span>
    <span class="Keyword">while</span> <span class="Identifier">it</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span> <span class="Comment"># compare the data items; uses</span>
                                   <span class="Comment"># the generic ``cmp`` proc that works for</span>
                                   <span class="Comment"># any type that has a ``==`` and ``&lt;``</span>
                                   <span class="Comment"># operator</span>
      <span class="Keyword">if</span> <span class="Identifier">c</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span>
      <span class="Keyword">else</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span>

<span class="Keyword">iterator</span> <span class="Identifier">inorder</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Comment"># inorder traversal of a binary tree</span>
  <span class="Comment"># recursive iterators are not yet implemented, so this does not work in</span>
  <span class="Comment"># the current compiler!</span>
  <span class="Keyword">if</span> <span class="Identifier">root</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span> <span class="Keyword">yield</span> <span class="Identifier">inorder</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Operator">.</span><span class="Identifier">le</span><span class="Punctuation">)</span>
  <span class="Keyword">yield</span> <span class="Identifier">root</span><span class="Operator">.</span><span class="Identifier">data</span>
  <span class="Keyword">if</span> <span class="Identifier">root</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span> <span class="Keyword">yield</span> <span class="Identifier">inorder</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Operator">.</span><span class="Identifier">ri</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span>  <span class="Comment"># instantiate a BinaryTree with the type string</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;hallo&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># instantiates generic procs ``newNode`` and</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;world&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># ``add``</span>
<span class="Keyword">for</span> <span class="Identifier">str</span> <span class="Keyword">in</span> <span class="Identifier">inorder</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">str</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="is-operator" href="#is-operator">Is operator</a></h2><p>The <tt class="docutils literal"><span class="pre">is</span></tt> operator checks for type equivalence at compile time. It is therefore very useful for type specialization within generic code:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">,</span> <span class="Identifier">Value</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">keys</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">]</span>
    <span class="Identifier">values</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Value</span><span class="Punctuation">]</span>
    <span class="Keyword">when</span> <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">Key</span> <span class="Keyword">is</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Comment"># nil value for strings used for optimization</span>
      <span class="Identifier">deletedKeys</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">bool</span><span class="Punctuation">]</span></pre>
<h2><a class="toc-backref" id="type-operator" href="#type-operator">Type operator</a></h2><p>The <tt class="docutils literal"><span class="pre">type</span></tt> (in many other languages called <span id="typeof_1">typeof</span>) operator can be used to get the type of an expression:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Keyword">var</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">type</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># y has type int</span></pre><p>If <tt class="docutils literal"><span class="pre">type</span></tt> is used to determine the result type of a proc/iterator/converter call <tt class="docutils literal"><span class="pre">c(X)</span></tt> (where <tt class="docutils literal"><span class="pre">X</span></tt> stands for a possibly empty list of arguments), the interpretation where <tt class="docutils literal"><span class="pre">c</span></tt> is an iterator is preferred over the other interpretations:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">strutils</span>

<span class="Comment"># strutils contains both a ``split`` proc and iterator, but since an</span>
<span class="Comment"># an iterator is the preferred interpretation, `y` has the type ``string``:</span>
<span class="Keyword">var</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">type</span><span class="Punctuation">(</span><span class="StringLit">&quot;a b c&quot;</span><span class="Operator">.</span><span class="Identifier">split</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="type-classes" href="#type-classes">Type Classes</a></h2><p>A type class is a special pseudo-type that can be used to match against types in the context of overload resolution or the <tt class="docutils literal"><span class="pre">is</span></tt> operator. Nim supports the following built-in type classes:</p>
<table border="1" class="docutils"><tr><th>type class</th><th>matches</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">object</span></tt></td><td>any object type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">tuple</span></tt></td><td>any tuple type</td></tr>
<tr><td></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">enum</span></tt></td><td>any enumeration</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">proc</span></tt></td><td>any proc type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">ref</span></tt></td><td>any <tt class="docutils literal"><span class="pre">ref</span></tt> type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">ptr</span></tt></td><td>any <tt class="docutils literal"><span class="pre">ptr</span></tt> type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">var</span></tt></td><td>any <tt class="docutils literal"><span class="pre">var</span></tt> type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">distinct</span></tt></td><td>any distinct type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">array</span></tt></td><td>any array type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">set</span></tt></td><td>any set type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">seq</span></tt></td><td>any seq type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">auto</span></tt></td><td>any type</td></tr>
</table><p>Furthermore, every generic type automatically creates a type class of the same name that will match any instantiation of the generic type.</p>
<p>Type classes can be combined using the standard boolean operators to form more complex type classes:</p>
<pre><span class="Comment"># create a type class that will match all tuple and object types</span>
<span class="Keyword">type</span> <span class="Identifier">RecordType</span> <span class="Operator">=</span> <span class="Keyword">tuple</span> <span class="Keyword">or</span> <span class="Keyword">object</span>

<span class="Keyword">proc</span> <span class="Identifier">printFields</span><span class="Punctuation">(</span><span class="Identifier">rec</span><span class="Punctuation">:</span> <span class="Identifier">RecordType</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">key</span><span class="Punctuation">,</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Identifier">fieldPairs</span><span class="Punctuation">(</span><span class="Identifier">rec</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">key</span><span class="Punctuation">,</span> <span class="StringLit">&quot; = &quot;</span><span class="Punctuation">,</span> <span class="Identifier">value</span></pre><p>Procedures utilizing type classes in such manner are considered to be <span id="implicitly-generic_1">implicitly generic</span>. They will be instantiated once for each unique combination of param types used within the program.</p>
<p>Nim also allows for type classes and regular types to be specified as <span id="type-constraints_1">type constraints</span> of the generic type parameter:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">onlyIntOrString</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Operator">|</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">onlyIntOrString</span><span class="Punctuation">(</span><span class="DecNumber">450</span><span class="Punctuation">,</span> <span class="DecNumber">616</span><span class="Punctuation">)</span> <span class="Comment"># valid</span>
<span class="Identifier">onlyIntOrString</span><span class="Punctuation">(</span><span class="FloatNumber">5.0</span><span class="Punctuation">,</span> <span class="FloatNumber">0.0</span><span class="Punctuation">)</span> <span class="Comment"># type mismatch</span>
<span class="Identifier">onlyIntOrString</span><span class="Punctuation">(</span><span class="StringLit">&quot;xy&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">50</span><span class="Punctuation">)</span> <span class="Comment"># invalid as 'T' cannot be both at the same time</span></pre><p>By default, during overload resolution each named type class will bind to exactly one concrete type. Here is an example taken directly from the system module to illustrate this:</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Comment">## requires `x` and `y` to be of the same tuple type</span>
  <span class="Comment">## generic ``==`` operator for tuples that is lifted from the components</span>
  <span class="Comment">## of `x` and `y`.</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Keyword">for</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Identifier">fields</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">if</span> <span class="Identifier">a</span> <span class="Operator">!=</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span></pre><p>Alternatively, the <tt class="docutils literal"><span class="pre">distinct</span></tt> type modifier can be applied to the type class to allow each param matching the type class to bind to a different type.</p>
<p>If a proc param doesn't have a type specified, Nim will use the <tt class="docutils literal"><span class="pre">distinct auto</span></tt> type class (also known as <tt class="docutils literal"><span class="pre">any</span></tt>):</p>
<pre><span class="Comment"># allow any combination of param types</span>
<span class="Keyword">proc</span> <span class="Identifier">concat</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">a</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Identifier">b</span></pre><p>Procs written with the implicitly generic style will often need to refer to the type parameters of the matched generic type. They can be easily accessed using the dot syntax:</p>
<pre><span class="Keyword">type</span> <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">,</span> <span class="Identifier">Rows</span><span class="Punctuation">,</span> <span class="Identifier">Columns</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">m</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">,</span> <span class="Identifier">row</span><span class="Punctuation">,</span> <span class="Identifier">col</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Operator">.</span><span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">[</span><span class="Identifier">col</span> <span class="Operator">*</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">Matrix</span><span class="Operator">.</span><span class="Identifier">Columns</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">row</span><span class="Punctuation">]</span></pre><p>Alternatively, the <cite>type</cite> operator can be used over the proc params for similar effect when anonymous or distinct type classes are used.</p>
<p>When a generic type is instantiated with a type class instead of a concrete type, this results in another more specific type class:</p>
<pre><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Keyword">ref</span> <span class="Keyword">object</span><span class="Punctuation">]</span>  <span class="Comment"># Any sequence storing references to any object type</span>

<span class="Keyword">type</span> <span class="Identifier">T1</span> <span class="Operator">=</span> <span class="Identifier">auto</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">T1</span><span class="Punctuation">)</span>
  <span class="Comment"># seq[T1] is the same as just `seq`, but T1 will be allowed to bind</span>
  <span class="Comment"># to a single type, while the signature is being matched</span>

<span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="Identifier">Ordinal</span><span class="Punctuation">]</span> <span class="Comment"># Any Matrix instantiation using integer values</span></pre><p>As seen in the previous example, in such instantiations, it's not necessary to supply all type parameters of the generic type, because any missing ones will be inferred to have the equivalent of the <cite>any</cite> type class and thus they will match anything without discrimination.</p>

<h2><a class="toc-backref" id="user-defined-type-classes" href="#user-defined-type-classes">User defined type classes</a></h2><p><strong>Note</strong>: User defined type classes are still in development.</p>
<p>The user-defined type classes are available in two flavours - declarative and imperative. Both are used to specify an arbitrary set of requirements that the matched type must satisfy.</p>
<p>Declarative type classes are written in the following form:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Comparable</span> <span class="Operator">=</span> <span class="Keyword">generic</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span>
    <span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">&lt;</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">bool</span>
  
  <span class="Identifier">Container</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">generic</span> <span class="Identifier">c</span>
    <span class="Identifier">c</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Keyword">is</span> <span class="Identifier">ordinal</span>
    <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Keyword">iterator</span>
    <span class="Keyword">for</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Identifier">c</span><span class="Punctuation">:</span>
      <span class="Keyword">type</span><span class="Punctuation">(</span><span class="Identifier">value</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">T</span></pre><p>The type class will be matched if:</p>
<ol class="simple"><li>all of the expressions within the body can be compiled for the tested type</li>
<li>all statically evaluatable boolean expressions in the body must be true</li>
</ol>
<p>The identifiers following the <cite>generic</cite> keyword represent instances of the currently matched type. These instances can act both as variables of the type, when used in contexts where a value is expected, and as the type itself when used in contexts where a type is expected.</p>
<p>Please note that the <tt class="docutils literal"><span class="pre">is</span></tt> operator allows one to easily verify the precise type signatures of the required operations, but since type inference and default parameters are still applied in the provided block, it's also possible to encode usage protocols that do not reveal implementation details.</p>
<p>As a special rule providing further convenience when writing type classes, any type value appearing in a callable expression will be treated as a variable of the designated type for overload resolution purposes, unless the type value was passed in its explicit <tt class="docutils literal"><span class="pre">typedesc[T]</span></tt> form:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">OutputStream</span> <span class="Operator">=</span> <span class="Keyword">generic</span> <span class="Identifier">S</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Keyword">var</span> <span class="Identifier">S</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">)</span></pre><p>Much like generics, the user defined type classes will be instantiated exactly once for each tested type and any static code included within them will also be executed once.</p>

<h2><a class="toc-backref" id="type-inference-with-type-classes" href="#type-inference-with-type-classes">Type inference with type classes</a></h2><p>If a type class is used as the return type of a proc and it won't be bound to a concrete type by some of the proc params, Nim will infer the return type from the proc body. This is usually used with the <tt class="docutils literal"><span class="pre">auto</span></tt> type class:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">makePair</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">auto</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">first</span><span class="Punctuation">:</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">second</span><span class="Punctuation">:</span> <span class="Identifier">b</span><span class="Punctuation">)</span></pre><p>The return type will be treated as an additional generic param and can be explicitly specified at call sites as any other generic param.</p>
<p>Future versions of Nim may also support overloading based on the return type of the overloads. In such settings, the expected result type at call sites may also influence the inferred return type.</p>

<h2><a class="toc-backref" id="symbol-lookup-in-generics" href="#symbol-lookup-in-generics">Symbol lookup in generics</a></h2><p>The symbol binding rules in generics are slightly subtle: There are &quot;open&quot; and &quot;closed&quot; symbols. A &quot;closed&quot; symbol cannot be re-bound in the instantiation context, an &quot;open&quot; symbol can. Per default overloaded symbols are open and every other symbol is closed.</p>
<p>Open symbols are looked up in two different contexts: Both the context at definition and the context at instantiation are considered:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Index</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Index</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="FloatNumber">0.</span><span class="Identifier">Index</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="FloatNumber">0.</span><span class="Identifier">Index</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span> <span class="Comment"># works!</span></pre><p>In the example the generic <tt class="docutils literal"><span class="pre">==</span></tt> for tuples (as defined in the system module) uses the <tt class="docutils literal"><span class="pre">==</span></tt> operators of the tuple's components. However, the <tt class="docutils literal"><span class="pre">==</span></tt> for the <tt class="docutils literal"><span class="pre">Index</span></tt> type is defined <em>after</em> the <tt class="docutils literal"><span class="pre">==</span></tt> for tuples; yet the example compiles as the instantiation takes the currently defined symbols into account too.</p>
<p>A symbol can be forced to be open by a <span id="mixin_1">mixin</span> declaration:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">create</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Comment"># there is no overloaded 'init' here, so we need to state that it's an</span>
  <span class="Comment"># open symbol explicitly:</span>
  <span class="Keyword">mixin</span> <span class="Identifier">init</span>
  <span class="Identifier">new</span> <span class="Identifier">result</span>
  <span class="Identifier">init</span> <span class="Identifier">result</span></pre>
<h2><a class="toc-backref" id="bind-statement" href="#bind-statement">Bind statement</a></h2><p>The <tt class="docutils literal"><span class="pre">bind</span></tt> statement is the counterpart to the <tt class="docutils literal"><span class="pre">mixin</span></tt> statement. It can be used to explicitly declare identifiers that should be bound early (i.e. the identifiers should be looked up in the scope of the template/generic definition):</p>
<pre><span class="Comment"># Module A</span>
<span class="Keyword">var</span>
  <span class="Identifier">lastId</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">template</span> <span class="Identifier">genId</span><span class="Operator">*:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Keyword">bind</span> <span class="Identifier">lastId</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">lastId</span><span class="Punctuation">)</span>
  <span class="Identifier">lastId</span></pre><pre><span class="Comment"># Module B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>

<span class="Identifier">echo</span> <span class="Identifier">genId</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>But a <tt class="docutils literal"><span class="pre">bind</span></tt> is rarely useful because symbol binding from the definition scope is the default. </p>

<h1><a class="toc-backref" id="templates" href="#templates">Templates</a></h1><p>A template is a simple form of a macro: It is a simple substitution mechanism that operates on Nim's abstract syntax trees. It is processed in the semantic pass of the compiler.</p>
<p>The syntax to <em>invoke</em> a template is the same as calling a procedure.</p>
<p>Example:</p>
<pre><span class="Keyword">template</span> <span class="Punctuation">`</span><span class="Operator">!=</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Comment"># this definition exists in the System module</span>
  <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="DecNumber">5</span> <span class="Operator">!=</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># the compiler rewrites that to: assert(not (5 == 6))</span></pre><p>The <tt class="docutils literal"><span class="pre">!=</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;=</span></tt>, <tt class="docutils literal"><span class="pre">in</span></tt>, <tt class="docutils literal"><span class="pre">notin</span></tt>, <tt class="docutils literal"><span class="pre">isnot</span></tt> operators are in fact templates:</p>
<p><tt class="docutils literal"><span class="pre">a &gt; b</span></tt> is transformed into <tt class="docutils literal"><span class="pre">b &lt; a</span></tt>.<br /><tt class="docutils literal"><span class="pre">a in b</span></tt> is transformed into <tt class="docutils literal"><span class="pre">contains(b, a)</span></tt>.<br /><tt class="docutils literal"><span class="pre">notin</span></tt> and <tt class="docutils literal"><span class="pre">isnot</span></tt> have the obvious meanings.<br /></p><p>The &quot;types&quot; of templates can be the symbols <tt class="docutils literal"><span class="pre">expr</span></tt> (stands for <em>expression</em>), <tt class="docutils literal"><span class="pre">stmt</span></tt> (stands for <em>statement</em>) or <tt class="docutils literal"><span class="pre">typedesc</span></tt> (stands for <em>type description</em>). These are &quot;meta types&quot;, they can only be used in certain contexts. Real types can be used too; this implies that expressions are expected.</p>

<h2><a class="toc-backref" id="ordinary-vs-immediate-templates" href="#ordinary-vs-immediate-templates">Ordinary vs immediate templates</a></h2><p>There are two different kinds of templates: immediate templates and ordinary templates. Ordinary templates take part in overloading resolution. As such their arguments need to be type checked before the template is invoked. So ordinary templates cannot receive undeclared identifiers:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># error: unknown identifier: 'x'</span></pre><p>An <tt class="docutils literal"><span class="pre">immediate</span></tt> template does not participate in overload resolution and so its arguments are not checked for semantics before invocation. So they can receive undeclared identifiers:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">immediate</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># valid</span></pre>
<h2><a class="toc-backref" id="passing-a-code-block-to-a-template" href="#passing-a-code-block-to-a-template">Passing a code block to a template</a></h2><p>If there is a <tt class="docutils literal"><span class="pre">stmt</span></tt> parameter it should be the last in the template declaration, because statements are passed to a template via a special <tt class="docutils literal"><span class="pre">:</span></tt> syntax:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">,</span> <span class="Identifier">actions</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">immediate</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
  <span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">actions</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;cannot open: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">fn</span><span class="Punctuation">)</span>

<span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">txt</span><span class="Punctuation">,</span> <span class="StringLit">&quot;ttempl3.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 1&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 2&quot;</span><span class="Punctuation">)</span></pre><p>In the example the two <tt class="docutils literal"><span class="pre">writeln</span></tt> statements are bound to the <tt class="docutils literal"><span class="pre">actions</span></tt> parameter.</p>

<h2><a class="toc-backref" id="symbol-binding-in-templates" href="#symbol-binding-in-templates">Symbol binding in templates</a></h2><p>A template is a <span id="hygienic_1">hygienic</span> macro and so opens a new scope. Most symbols are bound from the definition scope of the template:</p>
<pre><span class="Comment"># Module A</span>
<span class="Keyword">var</span>
  <span class="Identifier">lastId</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">template</span> <span class="Identifier">genId</span><span class="Operator">*:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">lastId</span><span class="Punctuation">)</span>
  <span class="Identifier">lastId</span></pre><pre><span class="Comment"># Module B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>

<span class="Identifier">echo</span> <span class="Identifier">genId</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># Works as 'lastId' has been bound in 'genId's defining scope</span></pre><p>As in generics symbol binding can be influenced via <tt class="docutils literal"><span class="pre">mixin</span></tt> or <tt class="docutils literal"><span class="pre">bind</span></tt> statements.</p>

<h2><a class="toc-backref" id="identifier-construction" href="#identifier-construction">Identifier construction</a></h2><p>In templates identifiers can be constructed with the backticks notation:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">typedef</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">,</span> <span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">immediate</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">type</span>
    <span class="Punctuation">`</span><span class="Identifier">T</span> <span class="Identifier">name</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">typ</span>
    <span class="Punctuation">`</span><span class="Identifier">P</span> <span class="Identifier">name</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Punctuation">`</span><span class="Identifier">T</span> <span class="Identifier">name</span><span class="Punctuation">`</span>

<span class="Identifier">typedef</span><span class="Punctuation">(</span><span class="Identifier">myint</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PMyInt</span></pre><p>In the example <tt class="docutils literal"><span class="pre">name</span></tt> is instantiated with <tt class="docutils literal"><span class="pre">myint</span></tt>, so `T name` becomes <tt class="docutils literal"><span class="pre">Tmyint</span></tt>.</p>

<h2><a class="toc-backref" id="lookup-rules-for-template-parameters" href="#lookup-rules-for-template-parameters">Lookup rules for template parameters</a></h2><p>A parameter <tt class="docutils literal"><span class="pre">p</span></tt> in a template is even substituted in the expression <tt class="docutils literal"><span class="pre">x.p</span></tt>. Thus template arguments can be used as field names and a global symbol can be shadowed by the same argument name even when fully qualified:</p>
<pre><span class="Comment"># module 'm'</span>

<span class="Keyword">type</span>
  <span class="Identifier">Lev</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">levA</span><span class="Punctuation">,</span> <span class="Identifier">levB</span>

<span class="Keyword">var</span> <span class="Identifier">abclev</span> <span class="Operator">=</span> <span class="Identifier">levB</span>

<span class="Keyword">template</span> <span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">abclev</span><span class="Punctuation">:</span> <span class="Identifier">Lev</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">abclev</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">abclev</span>

<span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">levA</span><span class="Punctuation">)</span>
<span class="Comment"># produces: 'levA levA'</span></pre><p>But the global symbol can properly be captured by a <tt class="docutils literal"><span class="pre">bind</span></tt> statement:</p>
<pre><span class="Comment"># module 'm'</span>

<span class="Keyword">type</span>
  <span class="Identifier">Lev</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">levA</span><span class="Punctuation">,</span> <span class="Identifier">levB</span>

<span class="Keyword">var</span> <span class="Identifier">abclev</span> <span class="Operator">=</span> <span class="Identifier">levB</span>

<span class="Keyword">template</span> <span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">abclev</span><span class="Punctuation">:</span> <span class="Identifier">Lev</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">bind</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">abclev</span>
  <span class="Identifier">echo</span> <span class="Identifier">abclev</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">abclev</span>

<span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">levA</span><span class="Punctuation">)</span>
<span class="Comment"># produces: 'levA levB'</span></pre>
<h2><a class="toc-backref" id="hygiene-in-templates" href="#hygiene-in-templates">Hygiene in templates</a></h2><p>Per default templates are <span id="hygienic_2">hygienic</span>: Local identifiers declared in a template cannot be accessed in the instantiation context:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">newException</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">exceptn</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">,</span> <span class="Identifier">message</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Keyword">var</span>
    <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">exceptn</span>  <span class="Comment"># e is implicitly gensym'ed here</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">)</span>
  <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">msg</span> <span class="Operator">=</span> <span class="Identifier">message</span>
  <span class="Identifier">e</span>

<span class="Comment"># so this works:</span>
<span class="Keyword">let</span> <span class="Identifier">e</span> <span class="Operator">=</span> <span class="StringLit">&quot;message&quot;</span>
<span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">EIO</span><span class="Punctuation">,</span> <span class="Identifier">e</span><span class="Punctuation">)</span></pre><p>Whether a symbol that is declared in a template is exposed to the instantiation scope is controlled by the <span id="inject_1">inject</span> and <span id="gensym_1">gensym</span> pragmas: gensym'ed symbols are not exposed but inject'ed are.</p>
<p>The default for symbols of entity <tt class="docutils literal"><span class="pre">type</span></tt>, <tt class="docutils literal"><span class="pre">var</span></tt>, <tt class="docutils literal"><span class="pre">let</span></tt> and <tt class="docutils literal"><span class="pre">const</span></tt> is <tt class="docutils literal"><span class="pre">gensym</span></tt> and for <tt class="docutils literal"><span class="pre">proc</span></tt>, <tt class="docutils literal"><span class="pre">iterator</span></tt>, <tt class="docutils literal"><span class="pre">converter</span></tt>, <tt class="docutils literal"><span class="pre">template</span></tt>, <tt class="docutils literal"><span class="pre">macro</span></tt> is <tt class="docutils literal"><span class="pre">inject</span></tt>. However, if the name of the entity is passed as a template parameter, it is an inject'ed symbol:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">,</span> <span class="Identifier">actions</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">immediate</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">block</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>  <span class="Comment"># since 'f' is a template param, it's injected implicitly</span>
    <span class="Operator">...</span>

<span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">txt</span><span class="Punctuation">,</span> <span class="StringLit">&quot;ttempl3.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 1&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 2&quot;</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">inject</span></tt> and <tt class="docutils literal"><span class="pre">gensym</span></tt> pragmas are second class annotations; they have no semantics outside of a template definition and cannot be abstracted over:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span> <span class="Identifier">myInject</span><span class="Punctuation">:</span> <span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">myInject</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># does NOT work</span></pre><p>To get rid of hygiene in templates, one can use the <span id="dirty_1">dirty</span> pragma for a template. <tt class="docutils literal"><span class="pre">inject</span></tt> and <tt class="docutils literal"><span class="pre">gensym</span></tt> have no effect in <tt class="docutils literal"><span class="pre">dirty</span></tt> templates.</p>

<h2><a class="toc-backref" id="limitations-of-the-method-call-syntax" href="#limitations-of-the-method-call-syntax">Limitations of the method call syntax</a></h2><p>The expression <tt class="docutils literal"><span class="pre">x</span></tt> in <tt class="docutils literal"><span class="pre">x.f</span></tt> needs to be semantically checked (that means symbol lookup and type checking) before it can be decided that it needs to be rewritten to <tt class="docutils literal"><span class="pre">f(x)</span></tt>. Therefore the dot syntax has some limiations when it is used to invoke templates/macros:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">declareVar</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Keyword">const</span> <span class="Identifier">name</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Comment"># Doesn't compile:</span>
<span class="Identifier">unknownIdentifier</span><span class="Operator">.</span><span class="Identifier">declareVar</span></pre><p>Another common example is this:</p>
<pre><span class="Keyword">from</span> <span class="Identifier">sequtils</span> <span class="Keyword">import</span> <span class="Identifier">toSeq</span>

<span class="Keyword">iterator</span> <span class="Identifier">something</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Keyword">yield</span> <span class="StringLit">&quot;Hello&quot;</span>
  <span class="Keyword">yield</span> <span class="StringLit">&quot;World&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">info</span> <span class="Operator">=</span> <span class="Identifier">toSeq</span><span class="Punctuation">(</span><span class="Identifier">something</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>The problem here is that the compiler already decided that <tt class="docutils literal"><span class="pre">something()</span></tt> as an iterator is not callable in this context before <tt class="docutils literal"><span class="pre">toSeq</span></tt> gets its chance to convert it into a sequence.</p>

<h1><a class="toc-backref" id="macros" href="#macros">Macros</a></h1><p>A macro is a special kind of low level template. Macros can be used to implement <span id="domain-specific-languages_1">domain specific languages</span>. Like templates, macros come in the 2 flavors <em>immediate</em> and <em>ordinary</em>.</p>
<p>While macros enable advanced compile-time code transformations, they cannot change Nim's syntax. However, this is no real restriction because Nim's syntax is flexible enough anyway.</p>
<p>To write macros, one needs to know how the Nim concrete syntax is converted to an abstract syntax tree.</p>
<p>There are two ways to invoke a macro:</p>
<ol class="simple"><li>invoking a macro like a procedure call (<cite>expression macros</cite>)</li>
<li>invoking a macro with the special <tt class="docutils literal"><span class="pre">macrostmt</span></tt> syntax (<cite>statement macros</cite>)</li>
</ol>

<h2><a class="toc-backref" id="expression-macros" href="#expression-macros">Expression Macros</a></h2><p>The following example implements a powerful <tt class="docutils literal"><span class="pre">debug</span></tt> command that accepts a variable number of arguments:</p>
<pre><span class="Comment"># to work with Nim syntax trees, we need an API that is defined in the</span>
<span class="Comment"># ``macros`` module:</span>
<span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">expr</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Comment"># `n` is a Nim AST that contains the whole macro invocation</span>
  <span class="Comment"># this macro returns a list of statements:</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newNimNode</span><span class="Punctuation">(</span><span class="Identifier">nnkStmtList</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span>
  <span class="Comment"># iterate over any argument that is passed to this macro:</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Comment"># add a call to the statement list that writes the expression;</span>
    <span class="Comment"># `toStrLit` converts an AST to its string representation:</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;write&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">toStrLit</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Comment"># add a call to the statement list that writes &quot;: &quot;</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;write&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newStrLitNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Comment"># add a call to the statement list that writes the expressions value:</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;writeln&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span> <span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>The macro call expands to:</p>
<pre><span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[0]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[1]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;x&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>Arguments that are passed to a <tt class="docutils literal"><span class="pre">varargs</span></tt> parameter are wrapped in an array constructor expression. This is why <tt class="docutils literal"><span class="pre">debug</span></tt> iterates over all of <tt class="docutils literal"><span class="pre">n</span></tt>'s children.</p>

<h2><a class="toc-backref" id="bindsym" href="#bindsym">BindSym</a></h2><p>The above <tt class="docutils literal"><span class="pre">debug</span></tt> macro relies on the fact that <tt class="docutils literal"><span class="pre">write</span></tt>, <tt class="docutils literal"><span class="pre">writeln</span></tt> and <tt class="docutils literal"><span class="pre">stdout</span></tt> are declared in the system module and thus visible in the instantiating context. There is a way to use bound identifiers (aka <span id="symbols_1">symbols</span>) instead of using unbound identifiers. The <tt class="docutils literal"><span class="pre">bindSym</span></tt> builtin can be used for that:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">expr</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newNimNode</span><span class="Punctuation">(</span><span class="Identifier">nnkStmtList</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Comment"># we can bind symbols in scope via 'bindSym':</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;write&quot;</span><span class="Punctuation">,</span> <span class="RawData">bindSym&quot;stdout&quot;</span><span class="Punctuation">,</span> <span class="Identifier">toStrLit</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;write&quot;</span><span class="Punctuation">,</span> <span class="RawData">bindSym&quot;stdout&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newStrLitNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;writeln&quot;</span><span class="Punctuation">,</span> <span class="RawData">bindSym&quot;stdout&quot;</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span> <span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>The macro call expands to:</p>
<pre><span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[0]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[1]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;x&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>However, the symbols <tt class="docutils literal"><span class="pre">write</span></tt>, <tt class="docutils literal"><span class="pre">writeln</span></tt> and <tt class="docutils literal"><span class="pre">stdout</span></tt> are already bound and are not looked up again. As the example shows, <tt class="docutils literal"><span class="pre">bindSym</span></tt> does work with overloaded symbols implicitly.</p>

<h2><a class="toc-backref" id="statement-macros" href="#statement-macros">Statement Macros</a></h2><p>Statement macros are defined just as expression macros. However, they are invoked by an expression following a colon.</p>
<p>The following example outlines a macro that generates a lexical analyzer from regular expressions:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">case_token</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Comment"># creates a lexical analyzer from regular expressions</span>
  <span class="Comment"># ... (implementation is an exercise for the reader :-)</span>
  <span class="Keyword">discard</span>

<span class="Identifier">case_token</span><span class="Punctuation">:</span> <span class="Comment"># this colon tells the parser it is a macro statement</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;[A-Za-z_]+[A-Za-z_0-9]*&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkIdentifier</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;0-9+&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkInteger</span>
<span class="Keyword">of</span> <span class="RawData">r&quot;[\+\-\*\?]+&quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkOperator</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Keyword">return</span> <span class="Identifier">tkUnknown</span></pre><p><strong>Style note</strong>: For code readability, it is the best idea to use the least powerful programming construct that still suffices. So the &quot;check list&quot; is:</p>
<ol class="simple"><li>Use an ordinary proc/iterator, if possible.</li>
<li>Else: Use a generic proc/iterator, if possible.</li>
<li>Else: Use a template, if possible.</li>
<li>Else: Use a macro.</li>
</ol>

<h2><a class="toc-backref" id="macros-as-pragmas" href="#macros-as-pragmas">Macros as pragmas</a></h2><p>Whole routines (procs, iterators etc.) can also be passed to a template or a macro via the pragma notation:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">m</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre><p>This is a simple syntactic transformation into:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">m</span><span class="Punctuation">:</span>
  <span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre>
<h1><a class="toc-backref" id="special-types" href="#special-types">Special Types</a></h1>
<h2><a class="toc-backref" id="static-t" href="#static-t">static[T]</a></h2><p><strong>Note</strong>: static[T] is still in development.</p>
<p>As their name suggests, static params must be known at compile-time:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">precompiledRegex</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">:</span> <span class="Keyword">static</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">RegEx</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">res</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">global</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">re</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span>
  <span class="Keyword">return</span> <span class="Identifier">res</span>

<span class="Identifier">precompiledRegex</span><span class="Punctuation">(</span><span class="StringLit">&quot;/d+&quot;</span><span class="Punctuation">)</span> <span class="Comment"># Replaces the call with a precompiled</span>
                        <span class="Comment"># regex, stored in a global variable</span>

<span class="Identifier">precompiledRegex</span><span class="Punctuation">(</span><span class="Identifier">paramStr</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># Error, command-line options</span>
                              <span class="Comment"># are not known at compile-time</span></pre><p>For the purposes of code generation, all static params are treated as generic params - the proc will be compiled separately for each unique supplied value (or combination of values).</p>
<p>Furthermore, the system module defines a <cite>semistatic[T]</cite> type that can be used to declare procs accepting both static and run-time values, which can optimize their body according to the supplied param using the <cite>isStatic(p)</cite> predicate:</p>
<pre><span class="Comment"># The following proc will be compiled once for each unique static</span>
<span class="Comment"># value and also once for the case handling all run-time values:</span>

<span class="Keyword">proc</span> <span class="Identifier">re</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">:</span> <span class="Identifier">semistatic</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">RegEx</span> <span class="Operator">=</span>
  <span class="Keyword">when</span> <span class="Identifier">isStatic</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">precompiledRegex</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">compile</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span></pre><p>Static params can also appear in the signatures of generic types:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="Identifier">M</span><span class="Punctuation">,</span><span class="Identifier">N</span><span class="Punctuation">:</span> <span class="Keyword">static</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">Number</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Punctuation">(</span><span class="Identifier">M</span><span class="Operator">*</span><span class="Identifier">N</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span>
    <span class="Comment"># Note how `Number` is just a type constraint here, while</span>
    <span class="Comment"># `static[int]` requires us to supply a compile-time int value</span>
  
  <span class="Identifier">AffineTransform2D</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span>
  <span class="Identifier">AffineTransform3D</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span>

<span class="Keyword">var</span> <span class="Identifier">m1</span><span class="Punctuation">:</span> <span class="Identifier">AffineTransform3D</span><span class="Punctuation">[</span><span class="Identifier">float</span><span class="Punctuation">]</span>  <span class="Comment"># OK</span>
<span class="Keyword">var</span> <span class="Identifier">m2</span><span class="Punctuation">:</span> <span class="Identifier">AffineTransform2D</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Comment"># Error, `string` is not a `Number`</span></pre>
<h2><a class="toc-backref" id="typedesc" href="#typedesc">typedesc</a></h2><p><cite>typedesc</cite> is a special type allowing one to treat types as compile-time values (i.e. if types are compile-time values and all values have a type, then typedesc must be their type).</p>
<p>When used as a regular proc param, typedesc acts as a type class. The proc will be instantiated for each unique type parameter and one can refer to the instantiation type using the param name:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;allocating &quot;</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Operator">.</span><span class="Identifier">name</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Operator">.</span><span class="Identifier">new</span>
<span class="Keyword">var</span> <span class="Identifier">tree</span> <span class="Operator">=</span> <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>When multiple typedesc params are present, they act like a distinct type class (i.e. they will bind freely to different types). To force a bind-once behavior one can use a named alias or an explicit <cite>typedesc</cite> generic param:</p>
<pre><span class="Comment"># `type1` and `type2` are aliases for typedesc available from system.nim</span>
<span class="Keyword">proc</span> <span class="Identifier">acceptOnlyTypePairs</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span><span class="Punctuation">:</span> <span class="Identifier">type1</span><span class="Punctuation">;</span> <span class="Identifier">C</span><span class="Punctuation">,</span> <span class="Identifier">D</span><span class="Punctuation">:</span> <span class="Identifier">type2</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">acceptOnlyTypePairs</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">,</span> <span class="Identifier">U</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">;</span> <span class="Identifier">C</span><span class="Punctuation">,</span> <span class="Identifier">D</span><span class="Punctuation">:</span> <span class="Identifier">U</span><span class="Punctuation">)</span></pre><p>Once bound, typedesc params can appear in the rest of the proc signature:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">declareVariableWithType</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Operator">=</span> <span class="Identifier">value</span>

<span class="Identifier">declareVariableWithType</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="DecNumber">42</span></pre><p>When used with macros and .compileTime. procs on the other hand, the compiler does not need to instantiate the code multiple times, because types then can be manipulated using the unified internal symbol representation. In such context typedesc acts as any other type. One can create variables, store typedesc values inside containers and so on. For example, here is how one can create a type-safe wrapper for the unsafe <cite>printf</cite> function from C:</p>
<pre><span class="Keyword">macro</span> <span class="Identifier">safePrintF</span><span class="Punctuation">(</span><span class="Identifier">formatString</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">{</span><span class="Identifier">lit</span><span class="Punctuation">}</span><span class="Punctuation">,</span> <span class="Identifier">args</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">expr</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">for</span> <span class="Identifier">c</span> <span class="Keyword">in</span> <span class="Identifier">formatChars</span><span class="Punctuation">(</span><span class="Identifier">formatString</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">expectedType</span> <span class="Operator">=</span> <span class="Keyword">case</span> <span class="Identifier">c</span>
      <span class="Keyword">of</span> <span class="CharLit">'c'</span><span class="Punctuation">:</span> <span class="Identifier">char</span>
      <span class="Keyword">of</span> <span class="CharLit">'d'</span><span class="Punctuation">,</span> <span class="CharLit">'i'</span><span class="Punctuation">,</span> <span class="CharLit">'x'</span><span class="Punctuation">,</span> <span class="CharLit">'X'</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
      <span class="Keyword">of</span> <span class="CharLit">'f'</span><span class="Punctuation">,</span> <span class="CharLit">'e'</span><span class="Punctuation">,</span> <span class="CharLit">'E'</span><span class="Punctuation">,</span> <span class="CharLit">'g'</span><span class="Punctuation">,</span> <span class="CharLit">'G'</span><span class="Punctuation">:</span> <span class="Identifier">float</span>
      <span class="Keyword">of</span> <span class="CharLit">'s'</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
      <span class="Keyword">of</span> <span class="CharLit">'p'</span><span class="Punctuation">:</span> <span class="Identifier">pointer</span>
      <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">EOutOfRange</span>
    
    <span class="Keyword">var</span> <span class="Identifier">actualType</span> <span class="Operator">=</span> <span class="Identifier">args</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">getType</span>
    <span class="Identifier">inc</span> <span class="Identifier">i</span>
    
    <span class="Keyword">if</span> <span class="Identifier">expectedType</span> <span class="Operator">==</span> <span class="Identifier">EOutOfRange</span><span class="Punctuation">:</span>
      <span class="Identifier">error</span> <span class="Identifier">c</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot; is not a valid format character&quot;</span>
    <span class="Keyword">elif</span> <span class="Identifier">expectedType</span> <span class="Operator">!=</span> <span class="Identifier">actualType</span><span class="Punctuation">:</span>
      <span class="Identifier">error</span> <span class="StringLit">&quot;type mismatch for argument &quot;</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">,</span> <span class="StringLit">&quot;. expected type: &quot;</span><span class="Punctuation">,</span>
            <span class="Identifier">expectedType</span><span class="Operator">.</span><span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;, actual type: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">actualType</span><span class="Operator">.</span><span class="Identifier">name</span>
  
  <span class="Comment"># keep the original callsite, but use cprintf instead</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">callsite</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="Operator">!</span><span class="StringLit">&quot;cprintf&quot;</span><span class="Punctuation">)</span></pre><p>Overload resolution can be further influenced by constraining the set of types that will match the typedesc param:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">maxval</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Keyword">template</span> <span class="Identifier">maxval</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">float</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span> <span class="Identifier">Inf</span>

<span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="Identifier">int</span><span class="Operator">.</span><span class="Identifier">maxval</span>
<span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">float</span><span class="Operator">.</span><span class="Identifier">maxval</span>
<span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="Identifier">string</span><span class="Operator">.</span><span class="Identifier">maxval</span> <span class="Comment"># error, maxval is not implemented for string</span></pre><p>The constraint can be a concrete type or a type class.</p>

<h1><a class="toc-backref" id="special-operators" href="#special-operators">Special Operators</a></h1>
<h2><a class="toc-backref" id="dot-operators" href="#dot-operators">dot operators</a></h2><p>Nim offers a special family of dot operators that can be used to intercept and rewrite proc call and field access attempts, referring to previously undeclared symbol names. They can be used to provide a fluent interface to objects lying outside the static confines of the type system such as values from dynamic scripting languages or dynamic file formats such as JSON or XML.</p>
<p>When Nim encounters an expression that cannot be resolved by the standard overload resolution rules, the current scope will be searched for a dot operator that can be matched against a re-written form of the expression, where the unknown field or proc name is converted to an additional static string parameter:</p>
<pre><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">b</span> <span class="Comment"># becomes `.`(a, &quot;b&quot;)</span>
<span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">d</span><span class="Punctuation">)</span> <span class="Comment"># becomes `.`(a, &quot;b&quot;, c, d)</span></pre><p>The matched dot operators can be symbols of any callable kind (procs, templates and macros), depending on the desired effect:</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">js</span><span class="Punctuation">:</span> <span class="Identifier">PJsonNode</span><span class="Punctuation">,</span> <span class="Identifier">field</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">JSON</span> <span class="Operator">=</span> <span class="Identifier">js</span><span class="Punctuation">[</span><span class="Identifier">field</span><span class="Punctuation">]</span>

<span class="Keyword">var</span> <span class="Identifier">js</span> <span class="Operator">=</span> <span class="Identifier">parseJson</span><span class="Punctuation">(</span><span class="StringLit">&quot;{ x: 1, y: 2}&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">js</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Comment"># outputs 1</span>
<span class="Identifier">echo</span> <span class="Identifier">js</span><span class="Operator">.</span><span class="Identifier">y</span> <span class="Comment"># outputs 2</span></pre><p>The following dot operators are available:</p>

<h2><a class="toc-backref" id="operator" href="#operator">operator <cite>.</cite></a></h2><p>This operator will be matched against both field accesses and method calls.</p>

<h2><a class="toc-backref" id="operator" href="#operator">operator <cite>.()</cite></a></h2><p>This operator will be matched exclusively against method calls. It has higher precedence than the <cite>.</cite> operator and this allows one to handle expressions like <cite>x.y</cite> and <cite>x.y()</cite> differently if one is interfacing with a scripting language for example.</p>

<h2><a class="toc-backref" id="operator" href="#operator">operator <cite>.=</cite></a></h2><p>This operator will be matched against assignments to missing fields.</p>
<pre><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">c</span> <span class="Comment"># becomes `.=`(a, &quot;b&quot;, c)</span></pre>
<h1><a class="toc-backref" id="type-bound-operations" href="#type-bound-operations">Type bound operations</a></h1><p>There are 3 operations that are bound to a type:</p>
<ol class="simple"><li>Assignment</li>
<li>Destruction</li>
<li>Deep copying for communication between threads</li>
</ol>
<p>These operations can be <em>overriden</em> instead of <em>overloaded</em>. This means the implementation is automatically lifted to structured types. For instance if type <tt class="docutils literal"><span class="pre">T</span></tt> has an overriden assignment operator <tt class="docutils literal"><span class="pre">=</span></tt> this operator is also used for assignments of the type <tt class="docutils literal"><span class="pre">seq[T]</span></tt>. Since these operations are bound to a type they have to be bound to a nominal type for reasons of simplicity of implementation: This means an overriden <tt class="docutils literal"><span class="pre">deepCopy</span></tt> for <tt class="docutils literal"><span class="pre">ref T</span></tt> is really bound to <tt class="docutils literal"><span class="pre">T</span></tt> and not to <tt class="docutils literal"><span class="pre">ref T</span></tt>. This also means that one cannot override <tt class="docutils literal"><span class="pre">deepCopy</span></tt> for both <tt class="docutils literal"><span class="pre">ptr T</span></tt> and <tt class="docutils literal"><span class="pre">ref T</span></tt> at the same time; instead a helper distinct or object type has to be used for one pointer type.</p>

<h2><a class="toc-backref" id="operator" href="#operator">operator <cite>=</cite></a></h2><p>This operator is the assignment operator. Note that in the contexts like <tt class="docutils literal"><span class="pre">let v = expr</span></tt>, <tt class="docutils literal"><span class="pre">var v = expr</span></tt>, <tt class="docutils literal"><span class="pre">parameter = defaultValue</span></tt> or for parameter passing no assignment is performed. The <tt class="docutils literal"><span class="pre">override</span></tt> pragma is optional for overriding <tt class="docutils literal"><span class="pre">=</span></tt>.</p>
<p><strong>Note</strong>: Overriding of operator <tt class="docutils literal"><span class="pre">=</span></tt> is not yet implemented.</p>

<h2><a class="toc-backref" id="destructors" href="#destructors">destructors</a></h2><p>A destructor must have a single parameter with a concrete type (the name of a generic type is allowed too). The name of the destructor has to be <tt class="docutils literal"><span class="pre">destroy</span></tt> and it need to be annotated with the <tt class="docutils literal"><span class="pre">override</span></tt> pragma.</p>
<p><tt class="docutils literal"><span class="pre">destroy(v)</span></tt> will be automatically invoked for every local stack variable <tt class="docutils literal"><span class="pre">v</span></tt> that goes out of scope.</p>
<p>If a structured type features a field with destructable type and the user has not provided an explicit implementation, a destructor for the structured type will be automatically generated. Calls to any base class destructors in both user-defined and generated destructors will be inserted.</p>
<p>A destructor is attached to the type it destructs; expressions of this type can then only be used in <em>destructible contexts</em> and as parameters:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">MyObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Identifier">pointer</span>

<span class="Keyword">proc</span> <span class="Identifier">destroy</span><span class="Punctuation">(</span><span class="Identifier">o</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">MyObj</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">override</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">o</span><span class="Operator">.</span><span class="Identifier">p</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span> <span class="Identifier">dealloc</span> <span class="Identifier">o</span><span class="Operator">.</span><span class="Identifier">p</span>

<span class="Keyword">proc</span> <span class="Identifier">open</span><span class="Punctuation">:</span> <span class="Identifier">MyObj</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">MyObj</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Identifier">alloc</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">work</span><span class="Punctuation">(</span><span class="Identifier">o</span><span class="Punctuation">:</span> <span class="Identifier">MyObj</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">o</span><span class="Operator">.</span><span class="Identifier">x</span>
  <span class="Comment"># No destructor invoked here for 'o' as 'o' is a parameter.</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># destructor automatically invoked at the end of the scope:</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Comment"># valid: pass 'x' to some other proc:</span>
  <span class="Identifier">work</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>
  
  <span class="Comment"># Error: usage of a type with a destructor in a non destructible context</span>
  <span class="Identifier">echo</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>A destructible context is currently only the following:</p>
<ol class="simple"><li>The <tt class="docutils literal"><span class="pre">expr</span></tt> in <tt class="docutils literal"><span class="pre">var x = expr</span></tt>.</li>
<li>The <tt class="docutils literal"><span class="pre">expr</span></tt> in <tt class="docutils literal"><span class="pre">let x = expr</span></tt>.</li>
<li>The <tt class="docutils literal"><span class="pre">expr</span></tt> in <tt class="docutils literal"><span class="pre">return expr</span></tt>.</li>
<li>The <tt class="docutils literal"><span class="pre">expr</span></tt> in <tt class="docutils literal"><span class="pre">result = expr</span></tt> where <tt class="docutils literal"><span class="pre">result</span></tt> is the special symbol introduced by the compiler.</li>
</ol>
<p>These rules ensure that the construction is tied to a variable and can easily be destructed at its scope exit. Later versions of the language will improve the support of destructors.</p>
<p>Be aware that destructors are not called for objects allocated with <tt class="docutils literal"><span class="pre">new</span></tt>. This may change in future versions of language, but for now the <tt class="docutils literal"><span class="pre">finalizer</span></tt> parameter to <tt class="docutils literal"><span class="pre">new</span></tt> has to be used.</p>
<p><strong>Note</strong>: Destructors are still experimental and the spec might change significantly in order to incorporate an escape analysis.</p>

<h2><a class="toc-backref" id="deepcopy" href="#deepcopy">deepCopy</a></h2><p><tt class="docutils literal"><span class="pre">deepCopy</span></tt> is a builtin that is invoked whenever data is passed to a <tt class="docutils literal"><span class="pre">spawn</span></tt>'ed proc to ensure memory safety. The programmer can override its behaviour for a specific <tt class="docutils literal"><span class="pre">ref</span></tt> or <tt class="docutils literal"><span class="pre">ptr</span></tt> type <tt class="docutils literal"><span class="pre">T</span></tt>. (Later versions of the language may weaken this restriction.)</p>
<p>The signature has to be:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">deepCopy</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">override</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>This mechanism is used by most data structures that support shared memory like channels to implement thread safe automatic memory management.</p>
<p>The builtin <tt class="docutils literal"><span class="pre">deepCopy</span></tt> can even clone closures and their environments. See the documentation of <a class="reference external" href="#spawn">spawn</a> for details. </p>

<h1><a class="toc-backref" id="term-rewriting-macros" href="#term-rewriting-macros">Term rewriting macros</a></h1><p>Term rewriting macros are macros or templates that have not only a <em>name</em> but also a <em>pattern</em> that is searched for after the semantic checking phase of the compiler: This means they provide an easy way to enhance the compilation pipeline with user defined optimizations:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">optMul</span><span class="Punctuation">{</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">+</span><span class="Identifier">a</span>

<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">3</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Operator">*</span> <span class="DecNumber">2</span></pre><p>The compiler now rewrites <tt class="docutils literal"><span class="pre">x * 2</span></tt> as <tt class="docutils literal"><span class="pre">x + x</span></tt>. The code inside the curlies is the pattern to match against. The operators <tt class="docutils literal"><span class="pre">*</span></tt>,  <tt class="docutils literal"><span class="pre">**</span></tt>, <tt class="docutils literal"><span class="pre">|</span></tt>, <tt class="docutils literal"><span class="pre">~</span></tt> have a special meaning in patterns if they are written in infix notation, so to match verbatim against <tt class="docutils literal"><span class="pre">*</span></tt> the ordinary function call syntax needs to be used.</p>
<p>Unfortunately optimizations are hard to get right and even the tiny example is <strong>wrong</strong>:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">optMul</span><span class="Punctuation">{</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">+</span><span class="Identifier">a</span>

<span class="Keyword">proc</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;side effect!&quot;</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="DecNumber">55</span>

<span class="Identifier">echo</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="DecNumber">2</span></pre><p>We cannot duplicate 'a' if it denotes an expression that has a side effect! Fortunately Nim supports side effect analysis:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">optMul</span><span class="Punctuation">{</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">{</span><span class="Identifier">noSideEffect</span><span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">+</span><span class="Identifier">a</span>

<span class="Keyword">proc</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;side effect!&quot;</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="DecNumber">55</span>

<span class="Identifier">echo</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="DecNumber">2</span> <span class="Comment"># not optimized ;-)</span></pre><p>So what about <tt class="docutils literal"><span class="pre">2 * a</span></tt>? We should tell the compiler <tt class="docutils literal"><span class="pre">*</span></tt> is commutative. We cannot really do that however as the following code only swaps arguments blindly:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">mulIsCommutative</span><span class="Punctuation">{</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">b</span><span class="Operator">*</span><span class="Identifier">a</span></pre><p>What optimizers really need to do is a <em>canonicalization</em>:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">canonMul</span><span class="Punctuation">{</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">{</span><span class="Identifier">lit</span><span class="Punctuation">}</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">b</span><span class="Operator">*</span><span class="Identifier">a</span></pre><p>The <tt class="docutils literal"><span class="pre">int{lit}</span></tt> parameter pattern matches against an expression of type <tt class="docutils literal"><span class="pre">int</span></tt>, but only if it's a literal.</p>

<h2><a class="toc-backref" id="parameter-constraints" href="#parameter-constraints">Parameter constraints</a></h2><p>The <span id="parameter-constraint_1">parameter constraint</span> expression can use the operators <tt class="docutils literal"><span class="pre">|</span></tt> (or), <tt class="docutils literal"><span class="pre">&amp;</span></tt> (and) and <tt class="docutils literal"><span class="pre">~</span></tt> (not) and the following predicates:</p>
<table border="1" class="docutils"><tr><th>Predicate</th><th>Meaning</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">atom</span></tt></td><td>The matching node has no children.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">lit</span></tt></td><td>The matching node is a literal like &quot;abc&quot;, 12.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">sym</span></tt></td><td>The matching node must be a symbol (a bound identifier).</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">ident</span></tt></td><td>The matching node must be an identifier (an unbound identifier).</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">call</span></tt></td><td>The matching AST must be a call/apply expression.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">lvalue</span></tt></td><td>The matching AST must be an lvalue.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">sideeffect</span></tt></td><td>The matching AST must have a side effect.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">nosideeffect</span></tt></td><td>The matching AST must have no side effect.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">param</span></tt></td><td>A symbol which is a parameter.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">genericparam</span></tt></td><td>A symbol which is a generic parameter.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">module</span></tt></td><td>A symbol which is a module.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">type</span></tt></td><td>A symbol which is a type.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">var</span></tt></td><td>A symbol which is a variable.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">let</span></tt></td><td>A symbol which is a <tt class="docutils literal"><span class="pre">let</span></tt> variable.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">const</span></tt></td><td>A symbol which is a constant.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">result</span></tt></td><td>The special <tt class="docutils literal"><span class="pre">result</span></tt> variable.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">proc</span></tt></td><td>A symbol which is a proc.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">method</span></tt></td><td>A symbol which is a method.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">iterator</span></tt></td><td>A symbol which is an iterator.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">converter</span></tt></td><td>A symbol which is a converter.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">macro</span></tt></td><td>A symbol which is a macro.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">template</span></tt></td><td>A symbol which is a template.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">field</span></tt></td><td>A symbol which is a field in a tuple or an object.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">enumfield</span></tt></td><td>A symbol which is a field in an enumeration.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">forvar</span></tt></td><td>A for loop variable.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">label</span></tt></td><td>A label (used in <tt class="docutils literal"><span class="pre">block</span></tt> statements).</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">nk*</span></tt></td><td>The matching AST must have the specified kind. (Example: <tt class="docutils literal"><span class="pre">nkIfStmt</span></tt> denotes an <tt class="docutils literal"><span class="pre">if</span></tt> statement.)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">alias</span></tt></td><td>States that the marked parameter needs to alias with <em>some</em> other parameter.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">noalias</span></tt></td><td>States that <em>every</em> other parameter must not alias with the marked parameter.</td></tr>
</table><p>The <tt class="docutils literal"><span class="pre">alias</span></tt> and <tt class="docutils literal"><span class="pre">noalias</span></tt> predicates refer not only to the matching AST, but also to every other bound parameter; syntactially they need to occur after the ordinary AST predicates:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">ex</span><span class="Punctuation">{</span><span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">+</span> <span class="Identifier">c</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">{</span><span class="Identifier">noalias</span><span class="Punctuation">}</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># this transformation is only valid if 'b' and 'c' do not alias 'a':</span>
  <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">b</span>
  <span class="Identifier">inc</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">c</span></pre>
<h2><a class="toc-backref" id="pattern-operators" href="#pattern-operators">Pattern operators</a></h2><p>The operators <tt class="docutils literal"><span class="pre">*</span></tt>,  <tt class="docutils literal"><span class="pre">**</span></tt>, <tt class="docutils literal"><span class="pre">|</span></tt>, <tt class="docutils literal"><span class="pre">~</span></tt> have a special meaning in patterns if they are written in infix notation.</p>

<h3><a class="toc-backref" id="the-operator" href="#the-operator">The <tt class="docutils literal"><span class="pre">|</span></tt> operator</a></h3><p>The <tt class="docutils literal"><span class="pre">|</span></tt> operator if used as infix operator creates an ordered choice:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">{</span><span class="DecNumber">0</span><span class="Operator">|</span><span class="DecNumber">1</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span> <span class="DecNumber">3</span>
<span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
<span class="Comment"># outputs 3:</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span></pre><p>The matching is performed after the compiler performed some optimizations like constant folding, so the following does not work:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">{</span><span class="DecNumber">0</span><span class="Operator">|</span><span class="DecNumber">1</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span> <span class="DecNumber">3</span>
<span class="Comment"># outputs 1:</span>
<span class="Identifier">echo</span> <span class="DecNumber">1</span></pre><p>The reason is that the compiler already transformed the 1 into &quot;1&quot; for the <tt class="docutils literal"><span class="pre">echo</span></tt> statement. However, a term rewriting macro should not change the semantics anyway. In fact they can be deactived with the <tt class="docutils literal"><span class="pre">--patterns:off</span></tt> command line option or temporarily with the <tt class="docutils literal"><span class="pre">patterns</span></tt> pragma.</p>

<h3><a class="toc-backref" id="the-operator" href="#the-operator">The <tt class="docutils literal"><span class="pre">{}</span></tt> operator</a></h3><p>A pattern expression can be bound to a pattern parameter via the <tt class="docutils literal"><span class="pre">expr{param}</span></tt> notation:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">{</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Operator">|</span><span class="DecNumber">1</span><span class="Operator">|</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">{</span><span class="Identifier">x</span><span class="Punctuation">}</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span> <span class="Identifier">x</span><span class="Operator">+</span><span class="DecNumber">1</span>
<span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
<span class="Comment"># outputs 2:</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span></pre>
<h3><a class="toc-backref" id="the-operator" href="#the-operator">The <tt class="docutils literal"><span class="pre">~</span></tt> operator</a></h3><p>The <tt class="docutils literal"><span class="pre">~</span></tt> operator is the <strong>not</strong> operator in patterns:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">{</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Operator">~</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">{</span><span class="Identifier">y</span><span class="Punctuation">}</span> <span class="Keyword">and</span> <span class="Punctuation">(</span><span class="Operator">~</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">{</span><span class="Identifier">z</span><span class="Punctuation">}</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span> <span class="Operator">=</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">y</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">z</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">and</span> <span class="Identifier">c</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span></pre>
<h3><a class="toc-backref" id="the-operator" href="#the-operator">The <tt class="docutils literal"><span class="pre">*</span></tt> operator</a></h3><p>The <tt class="docutils literal"><span class="pre">*</span></tt> operator can <em>flatten</em> a nested binary expression like <tt class="docutils literal"><span class="pre">a &amp; b &amp; c</span></tt> to <tt class="docutils literal"><span class="pre">&amp;(a, b, c)</span></tt>:</p>
<pre><span class="Keyword">var</span>
  <span class="Identifier">calls</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&amp;&amp;</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
  <span class="Identifier">inc</span> <span class="Identifier">calls</span>

<span class="Keyword">template</span> <span class="Identifier">optConc</span><span class="Punctuation">{</span> <span class="Punctuation">`</span><span class="Operator">&amp;&amp;</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Identifier">a</span> <span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span> <span class="Operator">&amp;&amp;</span><span class="Identifier">a</span>

<span class="Keyword">let</span> <span class="Identifier">space</span> <span class="Operator">=</span> <span class="StringLit">&quot; &quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;my&quot;</span> <span class="Operator">&amp;&amp;</span> <span class="Punctuation">(</span><span class="Identifier">space</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;awe&quot;</span> <span class="Operator">&amp;&amp;</span> <span class="StringLit">&quot;some &quot;</span> <span class="Punctuation">)</span> <span class="Operator">&amp;&amp;</span> <span class="StringLit">&quot;concat&quot;</span>

<span class="Comment"># check that it's been optimized properly:</span>
<span class="Identifier">doAssert</span> <span class="Identifier">calls</span> <span class="Operator">==</span> <span class="DecNumber">1</span></pre><p>The second operator of <cite>*</cite> must be a parameter; it is used to gather all the arguments. The expression <tt class="docutils literal"><span class="pre">&quot;my&quot; &amp;&amp; (space &amp; &quot;awe&quot; &amp;&amp; &quot;some &quot; ) &amp;&amp; &quot;concat&quot;</span></tt> is passed to <tt class="docutils literal"><span class="pre">optConc</span></tt> in <tt class="docutils literal"><span class="pre">a</span></tt> as a special list (of kind <tt class="docutils literal"><span class="pre">nkArgList</span></tt>) which is flattened into a call expression; thus the invocation of <tt class="docutils literal"><span class="pre">optConc</span></tt> produces:</p>
<pre><span class="Punctuation">`</span><span class="Operator">&amp;&amp;</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="StringLit">&quot;my&quot;</span><span class="Punctuation">,</span> <span class="Identifier">space</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;awe&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;some &quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;concat&quot;</span><span class="Punctuation">)</span></pre>
<h3><a class="toc-backref" id="the-operator" href="#the-operator">The <tt class="docutils literal"><span class="pre">**</span></tt> operator</a></h3><p>The <tt class="docutils literal"><span class="pre">**</span></tt> is much like the <tt class="docutils literal"><span class="pre">*</span></tt> operator, except that it gathers not only all the arguments, but also the matched operators in reverse polish notation:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">type</span>
  <span class="Identifier">Matrix</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">dummy</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">dummy</span>
<span class="Keyword">proc</span> <span class="Identifier">mat21</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span> <span class="Operator">=</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">dummy</span> <span class="Operator">=</span> <span class="DecNumber">21</span>

<span class="Keyword">macro</span> <span class="Identifier">optM</span><span class="Punctuation">{</span> <span class="Punctuation">(</span><span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Operator">|</span><span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span><span class="Operator">|</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">)</span> <span class="Operator">**</span> <span class="Identifier">a</span> <span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">treeRepr</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;mat21&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span>

<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span> <span class="Operator">*</span> <span class="Identifier">z</span> <span class="Operator">-</span> <span class="Identifier">x</span></pre><p>This passes the expression <tt class="docutils literal"><span class="pre">x + y * z - x</span></tt> to the <tt class="docutils literal"><span class="pre">optM</span></tt> macro as an <tt class="docutils literal"><span class="pre">nnkArgList</span></tt> node containing:<pre>
Arglist
  Sym &quot;x&quot;
  Sym &quot;y&quot;
  Sym &quot;z&quot;
  Sym &quot;*&quot;
  Sym &quot;+&quot;
  Sym &quot;x&quot;
  Sym &quot;-&quot;</pre>
</p>
<p>(Which is the reverse polish notation of <tt class="docutils literal"><span class="pre">x + y * z - x</span></tt>.)</p>

<h2><a class="toc-backref" id="parameters" href="#parameters">Parameters</a></h2><p>Parameters in a pattern are type checked in the matching process. If a parameter is of the type <tt class="docutils literal"><span class="pre">varargs</span></tt> it is treated specially and it can match 0 or more arguments in the AST to be matched against:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">optWrite</span><span class="Punctuation">{</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span>
  <span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">write</span><span class="Operator">|</span><span class="Identifier">writeln</span><span class="Punctuation">)</span><span class="Punctuation">{</span><span class="Identifier">w</span><span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span>
<span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">expr</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">w</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">w</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="example-partial-evaluation" href="#example-partial-evaluation">Example: Partial evaluation</a></h2><p>The following example shows how some simple partial evaluation can be implemented with term rewriting:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">-</span> <span class="Identifier">y</span>

<span class="Keyword">template</span> <span class="Identifier">optP1</span><span class="Punctuation">{</span><span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">true</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>
<span class="Keyword">template</span> <span class="Identifier">optP2</span><span class="Punctuation">{</span><span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">false</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">-</span> <span class="Identifier">y</span></pre>
<h2><a class="toc-backref" id="example-hoisting" href="#example-hoisting">Example: Hoisting</a></h2><p>The following example shows how some form of hoisting can be implemented:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">pegs</span>

<span class="Keyword">template</span> <span class="Identifier">optPeg</span><span class="Punctuation">{</span><span class="Identifier">peg</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">{</span><span class="Identifier">lit</span><span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Peg</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">gl</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">global</span><span class="Punctuation">,</span> <span class="Identifier">gensym</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">peg</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span>
  <span class="Identifier">gl</span>

<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..</span> <span class="DecNumber">3</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">match</span><span class="Punctuation">(</span><span class="StringLit">&quot;(a b c)&quot;</span><span class="Punctuation">,</span> <span class="RawData">peg&quot;'(' @ ')'&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">echo</span> <span class="Identifier">match</span><span class="Punctuation">(</span><span class="StringLit">&quot;W_HI_Le&quot;</span><span class="Punctuation">,</span> <span class="RawData">peg&quot;\y 'while'&quot;</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">optPeg</span></tt> template optimizes the case of a peg constructor with a string literal, so that the pattern will only be parsed once at program startup and stored in a global <tt class="docutils literal"><span class="pre">gl</span></tt> which is then re-used. This optimization is called hoisting because it is comparable to classical loop hoisting.</p>

<h1><a class="toc-backref" id="ast-based-overloading" href="#ast-based-overloading">AST based overloading</a></h1><p>Parameter constraints can also be used for ordinary routine parameters; these constraints affect ordinary overloading resolution then:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">optLit</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">{</span><span class="Identifier">lit</span><span class="Operator">|</span><span class="Punctuation">`</span><span class="Keyword">const</span><span class="Punctuation">`</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;string literal&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">optLit</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;no string literal&quot;</span>

<span class="Keyword">const</span>
  <span class="Identifier">constant</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span>

<span class="Keyword">var</span>
  <span class="Identifier">variable</span> <span class="Operator">=</span> <span class="StringLit">&quot;xyz&quot;</span>

<span class="Identifier">optLit</span><span class="Punctuation">(</span><span class="StringLit">&quot;literal&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">optLit</span><span class="Punctuation">(</span><span class="Identifier">constant</span><span class="Punctuation">)</span>
<span class="Identifier">optLit</span><span class="Punctuation">(</span><span class="Identifier">variable</span><span class="Punctuation">)</span></pre><p>However, the constraints <tt class="docutils literal"><span class="pre">alias</span></tt> and <tt class="docutils literal"><span class="pre">noalias</span></tt> are not available in ordinary routines.</p>

<h2><a class="toc-backref" id="move-optimization" href="#move-optimization">Move optimization</a></h2><p>The <tt class="docutils literal"><span class="pre">call</span></tt> constraint is particularly useful to implement a move optimization for types that have copying semantics:</p>
<pre><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Table</span><span class="Punctuation">,</span> <span class="Identifier">key</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">val</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment">## puts a (key, value)-pair into `t`. The semantics of string require</span>
  <span class="Comment">## a copy here:</span>
  <span class="Keyword">let</span> <span class="Identifier">idx</span> <span class="Operator">=</span> <span class="Identifier">findInsertionPosition</span><span class="Punctuation">(</span><span class="Identifier">key</span><span class="Punctuation">)</span>
  <span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">idx</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">key</span>
  <span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">idx</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">val</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Table</span><span class="Punctuation">,</span> <span class="Identifier">key</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">{</span><span class="Identifier">call</span><span class="Punctuation">}</span><span class="Punctuation">,</span> <span class="Identifier">val</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">{</span><span class="Identifier">call</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment">## puts a (key, value)-pair into `t`. Optimized version that knows that</span>
  <span class="Comment">## the strings are unique and thus don't need to be copied:</span>
  <span class="Keyword">let</span> <span class="Identifier">idx</span> <span class="Operator">=</span> <span class="Identifier">findInsertionPosition</span><span class="Punctuation">(</span><span class="Identifier">key</span><span class="Punctuation">)</span>
  <span class="Identifier">shallowCopy</span> <span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">idx</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">key</span>
  <span class="Identifier">shallowCopy</span> <span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">idx</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">val</span>

<span class="Keyword">var</span> <span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">Table</span>
<span class="Comment"># overloading resolution ensures that the optimized []= is called here:</span>
<span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">g</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h1><a class="toc-backref" id="modules" href="#modules">Modules</a></h1><p>Nim supports splitting a program into pieces by a module concept. Each module needs to be in its own file and has its own <span id="namespace_1">namespace</span>. Modules enable <span id="information-hiding_1">information hiding</span> and <span id="separate-compilation_1">separate compilation</span>. A module may gain access to symbols of another module by the <span id="import_1">import</span> statement. <span id="recursive-module-dependencies_1">Recursive module dependencies</span> are allowed, but slightly subtle. Only top-level symbols that are marked with an asterisk (<tt class="docutils literal"><span class="pre">*</span></tt>) are exported. A valid module name can only be a valid Nim identifier (and thus its filename is <tt class="docutils literal"><span class="pre">identifier.nim</span></tt>).</p>
<p>The algorithm for compiling modules is:</p>
<ul class="simple"><li>compile the whole module as usual, following import statements recursively</li>
<li>if there is a cycle only import the already parsed symbols (that are exported); if an unknown identifier occurs then abort</li>
</ul>
<p>This is best illustrated by an example:</p>
<pre><span class="Comment"># Module A</span>
<span class="Keyword">type</span>
  <span class="Identifier">T1</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Identifier">int</span>  <span class="Comment"># Module A exports the type ``T1``</span>
<span class="Keyword">import</span> <span class="Identifier">B</span>     <span class="Comment"># the compiler starts parsing B</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Comment"># works because B has been parsed completely here</span>

<span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><pre><span class="Comment"># Module B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>  <span class="Comment"># A is not parsed here! Only the already known symbols</span>
          <span class="Comment"># of A are imported.</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">T1</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">T1</span> <span class="Operator">=</span>
  <span class="Comment"># this works because the compiler has already</span>
  <span class="Comment"># added T1 to A's interface symbol table</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="DecNumber">1</span></pre>
<h3><a class="toc-backref" id="import-statement" href="#import-statement">Import statement</a></h3><p>After the <tt class="docutils literal"><span class="pre">import</span></tt> statement a list of module names can follow or a single module name followed by an <tt class="docutils literal"><span class="pre">except</span></tt> list to prevent some symbols to be imported:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">strutils</span> <span class="Keyword">except</span> <span class="Punctuation">`</span><span class="Operator">%</span><span class="Punctuation">`</span><span class="Punctuation">,</span> <span class="Identifier">toUpper</span>

<span class="Comment"># doesn't work then:</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;$1&quot;</span> <span class="Operator">%</span> <span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">toUpper</span></pre><p>It is not checked that the <tt class="docutils literal"><span class="pre">except</span></tt> list is really exported from the module. This feature allows to compile against an older version of the module that does not export these identifiers.</p>

<h3><a class="toc-backref" id="include-statement" href="#include-statement">Include statement</a></h3><p>The <tt class="docutils literal"><span class="pre">include</span></tt> statement does something fundamentally different than importing a module: it merely includes the contents of a file. The <tt class="docutils literal"><span class="pre">include</span></tt> statement is useful to split up a large module into several files:</p>
<pre><span class="Keyword">include</span> <span class="Identifier">fileA</span><span class="Punctuation">,</span> <span class="Identifier">fileB</span><span class="Punctuation">,</span> <span class="Identifier">fileC</span></pre>
<h3><a class="toc-backref" id="module-names-in-imports" href="#module-names-in-imports">Module names in imports</a></h3><p>A module alias can be introduced via the <tt class="docutils literal"><span class="pre">as</span></tt> keyword:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">strutils</span> <span class="Keyword">as</span> <span class="Identifier">su</span><span class="Punctuation">,</span> <span class="Identifier">sequtils</span> <span class="Keyword">as</span> <span class="Identifier">qu</span>

<span class="Identifier">echo</span> <span class="Identifier">su</span><span class="Operator">.</span><span class="Identifier">format</span><span class="Punctuation">(</span><span class="StringLit">&quot;$1&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;lalelu&quot;</span><span class="Punctuation">)</span></pre><p>The original module name is then not accessible. The notations <tt class="docutils literal"><span class="pre">path/to/module</span></tt> or <tt class="docutils literal"><span class="pre">path.to.module</span></tt> or <tt class="docutils literal"><span class="pre">&quot;path/to/module&quot;</span></tt> can be used to refer to a module in subdirectories:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">lib</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Identifier">strutils</span><span class="Punctuation">,</span> <span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">os</span><span class="Punctuation">,</span> <span class="StringLit">&quot;lib/pure/times&quot;</span></pre><p>Note that the module name is still <tt class="docutils literal"><span class="pre">strutils</span></tt> and not <tt class="docutils literal"><span class="pre">lib.pure.strutils</span></tt> and so one <strong>cannot</strong> do:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">lib</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Identifier">strutils</span>
<span class="Identifier">echo</span> <span class="Identifier">lib</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Identifier">strutils</span></pre><p>Likewise the following does not make sense as the name is <tt class="docutils literal"><span class="pre">strutils</span></tt> already:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">lib</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Identifier">strutils</span> <span class="Keyword">as</span> <span class="Identifier">strutils</span></pre>
<h3><a class="toc-backref" id="from-import-statement" href="#from-import-statement">From import statement</a></h3><p>After the <tt class="docutils literal"><span class="pre">from</span></tt> statement a module name follows followed by an <tt class="docutils literal"><span class="pre">import</span></tt> to list the symbols one likes to use without explict full qualification:</p>
<pre><span class="Keyword">from</span> <span class="Identifier">strutils</span> <span class="Keyword">import</span> <span class="Punctuation">`</span><span class="Operator">%</span><span class="Punctuation">`</span>

<span class="Identifier">echo</span> <span class="StringLit">&quot;$1&quot;</span> <span class="Operator">%</span> <span class="StringLit">&quot;abc&quot;</span>
<span class="Comment"># always possible: full qualification:</span>
<span class="Identifier">echo</span> <span class="Identifier">strutils</span><span class="Operator">.</span><span class="Identifier">replace</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;z&quot;</span><span class="Punctuation">)</span></pre><p>It's also possible to use <tt class="docutils literal"><span class="pre">from module import nil</span></tt> if one wants to import the module but wants to enforce fully qualified access to every symbol in <tt class="docutils literal"><span class="pre">module</span></tt>.</p>

<h3><a class="toc-backref" id="export-statement" href="#export-statement">Export statement</a></h3><p>An <tt class="docutils literal"><span class="pre">export</span></tt> statement can be used for symbol fowarding so that client modules don't need to import a module's dependencies:</p>
<pre><span class="Comment"># module B</span>
<span class="Keyword">type</span> <span class="Identifier">MyObject</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span></pre><pre><span class="Comment"># module A</span>
<span class="Keyword">import</span> <span class="Identifier">B</span>
<span class="Keyword">export</span> <span class="Identifier">B</span><span class="Operator">.</span><span class="Identifier">MyObject</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;my object&quot;</span></pre><pre><span class="Comment"># module C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>

<span class="Comment"># B.MyObject has been imported implicitly here:</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="scope-rules" href="#scope-rules">Scope rules</a></h2><p>Identifiers are valid from the point of their declaration until the end of the block in which the declaration occurred. The range where the identifier is known is the scope of the identifier. The exact scope of an identifier depends on the way it was declared.</p>

<h3><a class="toc-backref" id="block-scope" href="#block-scope">Block scope</a></h3><p>The <em>scope</em> of a variable declared in the declaration part of a block is valid from the point of declaration until the end of the block. If a block contains a second block, in which the identifier is redeclared, then inside this block, the second declaration will be valid. Upon leaving the inner block, the first declaration is valid again. An identifier cannot be redefined in the same block, except if valid for procedure or iterator overloading purposes.</p>

<h3><a class="toc-backref" id="tuple-or-object-scope" href="#tuple-or-object-scope">Tuple or object scope</a></h3><p>The field identifiers inside a tuple or object definition are valid in the following places:</p>
<ul class="simple"><li>To the end of the tuple/object definition.</li>
<li>Field designators of a variable of the given tuple/object type.</li>
<li>In all descendant types of the object type.</li>
</ul>

<h3><a class="toc-backref" id="module-scope" href="#module-scope">Module scope</a></h3><p>All identifiers of a module are valid from the point of declaration until the end of the module. Identifiers from indirectly dependent modules are <em>not</em> available. The <span id="system_1">system</span> module is automatically imported in every other module.</p>
<p>If a module imports an identifier by two different modules, each occurrence of the identifier has to be qualified, unless it is an overloaded procedure or iterator in which case the overloading resolution takes place:</p>
<pre><span class="Comment"># Module A</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">string</span></pre><pre><span class="Comment"># Module B</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre><pre><span class="Comment"># Module C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># error: x is ambiguous</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># no error: qualifier used</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># not ambiguous: uses the module C's x</span></pre>
<h1><a class="toc-backref" id="compiler-messages" href="#compiler-messages">Compiler Messages</a></h1><p>The Nim compiler emits different kinds of messages: <span id="hint_1">hint</span>, <span id="warning_1">warning</span>, and <span id="error_1">error</span> messages. An <em>error</em> message is emitted if the compiler encounters any static error.</p>

<h1><a class="toc-backref" id="pragmas" href="#pragmas">Pragmas</a></h1><p>Pragmas are Nim's method to give the compiler additional information / commands without introducing a massive number of new keywords. Pragmas are processed on the fly during semantic checking. Pragmas are enclosed in the special <tt class="docutils literal"><span class="pre">{.</span></tt> and <tt class="docutils literal"><span class="pre">.}</span></tt> curly brackets. Pragmas are also often used as a first implementation to play with a language feature before a nicer syntax to access the feature becomes available.</p>

<h2><a class="toc-backref" id="deprecated-pragma" href="#deprecated-pragma">deprecated pragma</a></h2><p>The deprecated pragma is used to mark a symbol as deprecated:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">char</span></pre><p>It can also be used as a statement. Then it takes a list of <em>renamings</em>. The upcoming <tt class="docutils literal"><span class="pre">nimfix</span></tt> tool can automatically update the code and perform these renamings:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">File</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">Stream</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">TFile</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">PStream</span><span class="Punctuation">:</span> <span class="Identifier">Stream</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="nosideeffect-pragma" href="#nosideeffect-pragma">noSideEffect pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">noSideEffect</span></tt> pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type <tt class="docutils literal"><span class="pre">var T</span></tt> or <tt class="docutils literal"><span class="pre">ref T</span></tt> or <tt class="docutils literal"><span class="pre">ptr T</span></tt> this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</p>
<p>As a special semantic rule, the built-in <a class="reference external" href="system.html#debugEcho">debugEcho</a> pretends to be free of side effects, so that it can be used for debugging routines marked as <tt class="docutils literal"><span class="pre">noSideEffect</span></tt>.</p>
<p><strong>Future directions</strong>: <tt class="docutils literal"><span class="pre">func</span></tt> may become a keyword and syntactic sugar for a proc with no side effects:</p>
<pre><span class="Keyword">func</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre>
<h2><a class="toc-backref" id="destructor-pragma" href="#destructor-pragma">destructor pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">destructor</span></tt> pragma is used to mark a proc to act as a type destructor. Its usage is deprecated, use the <tt class="docutils literal"><span class="pre">override</span></tt> pragma instead. See <a class="reference external" href="#type-bound-operations">type bound operations</a>.</p>

<h2><a class="toc-backref" id="override-pragma" href="#override-pragma">override pragma</a></h2><p>See <a class="reference external" href="#type-bound-operations">type bound operations</a> instead.</p>

<h2><a class="toc-backref" id="procvar-pragma" href="#procvar-pragma">procvar pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">procvar</span></tt> pragma is used to mark a proc that it can be passed to a procedural variable.</p>

<h2><a class="toc-backref" id="compiletime-pragma" href="#compiletime-pragma">compileTime pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">compileTime</span></tt> pragma is used to mark a proc to be used at compile time only. No code will be generated for it. Compile time procs are useful as helpers for macros.</p>

<h2><a class="toc-backref" id="noreturn-pragma" href="#noreturn-pragma">noReturn pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">noreturn</span></tt> pragma is used to mark a proc that never returns.</p>

<h2><a class="toc-backref" id="acyclic-pragma" href="#acyclic-pragma">acyclic pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">acyclic</span></tt> pragma can be used for object types to mark them as acyclic even though they seem to be cyclic. This is an <strong>optimization</strong> for the garbage collector to not consider objects of this type as part of a cycle:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">acyclic</span><span class="Punctuation">,</span> <span class="Identifier">final</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">left</span><span class="Punctuation">,</span> <span class="Identifier">right</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre><p>In the example a tree structure is declared with the <tt class="docutils literal"><span class="pre">Node</span></tt> type. Note that the type definition is recursive and the GC has to assume that objects of this type may form a cyclic graph. The <tt class="docutils literal"><span class="pre">acyclic</span></tt> pragma passes the information that this cannot happen to the GC. If the programmer uses the <tt class="docutils literal"><span class="pre">acyclic</span></tt> pragma for data types that are in reality cyclic, the GC may leak memory, but nothing worse happens.</p>
<p><strong>Future directions</strong>: The <tt class="docutils literal"><span class="pre">acyclic</span></tt> pragma may become a property of a <tt class="docutils literal"><span class="pre">ref</span></tt> type:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Identifier">acyclic</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">left</span><span class="Punctuation">,</span> <span class="Identifier">right</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre>
<h2><a class="toc-backref" id="final-pragma" href="#final-pragma">final pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">final</span></tt> pragma can be used for an object type to specify that it cannot be inherited from.</p>

<h2><a class="toc-backref" id="shallow-pragma" href="#shallow-pragma">shallow pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">shallow</span></tt> pragma affects the semantics of a type: The compiler is allowed to make a shallow copy. This can cause serious semantic issues and break memory safety! However, it can speed up assignments considerably, because the semantics of Nim require deep copying of sequences and strings. This can be expensive, especially if sequences are used to build a tree structure:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">NodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span> <span class="Identifier">nkLeaf</span><span class="Punctuation">,</span> <span class="Identifier">nkInner</span>
  <span class="Identifier">Node</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">final</span><span class="Punctuation">,</span> <span class="Identifier">shallow</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">NodeKind</span>
    <span class="Keyword">of</span> <span class="Identifier">nkLeaf</span><span class="Punctuation">:</span>
      <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">nkInner</span><span class="Punctuation">:</span>
      <span class="Identifier">children</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Node</span><span class="Punctuation">]</span></pre>
<h2><a class="toc-backref" id="pure-pragma" href="#pure-pragma">pure pragma</a></h2><p>An object type can be marked with the <tt class="docutils literal"><span class="pre">pure</span></tt> pragma so that its type field which is used for runtime type identification is omitted. This used to be necessary for binary compatibility with other compiled languages.</p>
<p>An enum type can be marked as <tt class="docutils literal"><span class="pre">pure</span></tt>. Then access of its fields always requires full qualification.</p>

<h2><a class="toc-backref" id="asmnostackframe-pragma" href="#asmnostackframe-pragma">asmNoStackFrame pragma</a></h2><p>A proc can be marked with the <tt class="docutils literal"><span class="pre">AsmNoStackFrame</span></tt> pragma to tell the compiler it should not generate a stack frame for the proc. There are also no exit statements like <tt class="docutils literal"><span class="pre">return result;</span></tt> generated and the generated C function is declared as <tt class="docutils literal"><span class="pre">__declspec(naked)</span></tt> or <tt class="docutils literal"><span class="pre">__attribute__((naked))</span></tt> (depending on the used C compiler).</p>
<p><strong>Note</strong>: This pragma should only be used by procs which consist solely of assembler statements.</p>

<h2><a class="toc-backref" id="error-pragma" href="#error-pragma">error pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">error</span></tt> pragma is used to make the compiler output an error message with the given content. Compilation does not necessarily abort after an error though.</p>
<p>The <tt class="docutils literal"><span class="pre">error</span></tt> pragma can also be used to annotate a symbol (like an iterator or proc). The <em>usage</em> of the symbol then triggers a compile-time error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</p>
<pre><span class="Comment">## check that underlying int values are compared and not the pointers:</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">error</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="fatal-pragma" href="#fatal-pragma">fatal pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">fatal</span></tt> pragma is used to make the compiler output an error message with the given content. In contrast to the <tt class="docutils literal"><span class="pre">error</span></tt> pragma, compilation is guaranteed to be aborted by this pragma. Example:</p>
<pre><span class="Keyword">when</span> <span class="Keyword">not</span> <span class="Identifier">defined</span><span class="Punctuation">(</span><span class="Identifier">objc</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">fatal</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Compile this program with the objc command!&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="warning-pragma" href="#warning-pragma">warning pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">warning</span></tt> pragma is used to make the compiler output a warning message with the given content. Compilation continues after the warning.</p>

<h2><a class="toc-backref" id="hint-pragma" href="#hint-pragma">hint pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">hint</span></tt> pragma is used to make the compiler output a hint message with the given content. Compilation continues after the hint.</p>

<h2><a class="toc-backref" id="line-pragma" href="#line-pragma">line pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">line</span></tt> pragma can be used to affect line information of the annotated statement as seen in stack backtraces:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">myassert</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">,</span> <span class="Identifier">msg</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">cond</span><span class="Punctuation">:</span>
    <span class="Comment"># change run-time line information of the 'raise' statement:</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">InstantiationInfo</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
      <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">EAssertionFailed</span><span class="Punctuation">,</span> <span class="Identifier">msg</span><span class="Punctuation">)</span></pre><p>If the <tt class="docutils literal"><span class="pre">line</span></tt> pragma is used with a parameter, the parameter needs be a <tt class="docutils literal"><span class="pre">tuple[filename: string, line: int]</span></tt>. If it is used without a parameter, <tt class="docutils literal"><span class="pre">system.InstantiationInfo()</span></tt> is used.</p>

<h2><a class="toc-backref" id="linearscanend-pragma" href="#linearscanend-pragma">linearScanEnd pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">linearScanEnd</span></tt> pragma can be used to tell the compiler how to compile a Nim <span id="case_1">case</span> statement. Syntactically it has to be used as a statement:</p>
<pre><span class="Keyword">case</span> <span class="Identifier">myInt</span>
<span class="Keyword">of</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;most common case&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">linearScanEnd</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;second most common case&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;unlikely: use branch table&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;unlikely too: use branch table for &quot;</span><span class="Punctuation">,</span> <span class="Identifier">myInt</span></pre><p>In the example, the case branches <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">1</span></tt> are much more common than the other cases. Therefore the generated assembler code should test for these values first, so that the CPU's branch predictor has a good chance to succeed (avoiding an expensive CPU pipeline stall). The other cases might be put into a jump table for O(1) overhead, but at the cost of a (very likely) pipeline stall.</p>
<p>The <tt class="docutils literal"><span class="pre">linearScanEnd</span></tt> pragma should be put into the last branch that should be tested against via linear scanning. If put into the last branch of the whole <tt class="docutils literal"><span class="pre">case</span></tt> statement, the whole <tt class="docutils literal"><span class="pre">case</span></tt> statement uses linear scanning.</p>

<h2><a class="toc-backref" id="computedgoto-pragma" href="#computedgoto-pragma">computedGoto pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">computedGoto</span></tt> pragma can be used to tell the compiler how to compile a Nim <span id="case_2">case</span> in a <tt class="docutils literal"><span class="pre">while true</span></tt> statement. Syntactically it has to be used as a statement inside the loop:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">enumA</span><span class="Punctuation">,</span> <span class="Identifier">enumB</span><span class="Punctuation">,</span> <span class="Identifier">enumC</span><span class="Punctuation">,</span> <span class="Identifier">enumD</span><span class="Punctuation">,</span> <span class="Identifier">enumE</span>

<span class="Keyword">proc</span> <span class="Identifier">vm</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">instructions</span><span class="Punctuation">:</span> <span class="Identifier">array</span> <span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">100</span><span class="Punctuation">,</span> <span class="Identifier">MyEnum</span><span class="Punctuation">]</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumC</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumD</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumA</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumD</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumC</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">7</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumA</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">8</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumB</span>
  
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">12</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumE</span>
  <span class="Keyword">var</span> <span class="Identifier">pc</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">computedGoto</span><span class="Operator">.</span><span class="Punctuation">}</span>
    <span class="Keyword">let</span> <span class="Identifier">instr</span> <span class="Operator">=</span> <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="Identifier">pc</span><span class="Punctuation">]</span>
    <span class="Keyword">case</span> <span class="Identifier">instr</span>
    <span class="Keyword">of</span> <span class="Identifier">enumA</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah A&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumC</span><span class="Punctuation">,</span> <span class="Identifier">enumD</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah CD&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumB</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah B&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumE</span><span class="Punctuation">:</span>
      <span class="Keyword">break</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">pc</span><span class="Punctuation">)</span>

<span class="Identifier">vm</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>As the example shows <tt class="docutils literal"><span class="pre">computedGoto</span></tt> is mostly useful for interpreters. If the underlying backend (C compiler) does not support the computed goto extension the pragma is simply ignored.</p>

<h2><a class="toc-backref" id="unroll-pragma" href="#unroll-pragma">unroll pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">unroll</span></tt> pragma can be used to tell the compiler that it should unroll a <span id="for_2">for</span> or <span id="while_1">while</span> loop for runtime efficiency:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">searchChar</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">unroll</span><span class="Punctuation">:</span> <span class="FloatNumber">4.</span><span class="Punctuation">}</span>
    <span class="Keyword">if</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">i</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Operator">-</span><span class="DecNumber">1</span></pre><p>In the above example, the search loop is unrolled by a factor 4. The unroll factor can be left out too; the compiler then chooses an appropriate unroll factor.</p>
<p><strong>Note</strong>: Currently the compiler recognizes but ignores this pragma.</p>

<h2><a class="toc-backref" id="immediate-pragma" href="#immediate-pragma">immediate pragma</a></h2><p>See <a class="reference external" href="#ordinary-vs-immediate-templates">Ordinary vs immediate templates</a>.</p>

<h2><a class="toc-backref" id="compilation-option-pragmas" href="#compilation-option-pragmas">compilation option pragmas</a></h2><p>The listed pragmas here can be used to override the code generation options for a proc/method/converter.</p>
<p>The implementation currently provides the following possible options (various others may be added later).</p>
<table border="1" class="docutils"><tr><th>pragma</th><th>allowed values</th><th>description</th></tr>
<tr><td>checks</td><td>on|off </td><td>Turns the code generation for all runtime checks on or off.</td></tr>
<tr><td>boundChecks</td><td>on|off </td><td>Turns the code generation for array bound checks on or off.</td></tr>
<tr><td>overflowChecks</td><td>on|off </td><td>Turns the code generation for over- or underflow checks on or off.</td></tr>
<tr><td>nilChecks</td><td>on|off </td><td>Turns the code generation for nil pointer checks on or off.</td></tr>
<tr><td>assertions</td><td>on|off </td><td>Turns the code generation for assertions on or off.</td></tr>
<tr><td>warnings</td><td>on|off </td><td>Turns the warning messages of the compiler on or off.</td></tr>
<tr><td>hints</td><td>on|off </td><td>Turns the hint messages of the compiler on or off.</td></tr>
<tr><td>optimization</td><td>none|speed|size </td><td>Optimize the code for speed or size, or disable optimization.</td></tr>
<tr><td>patterns</td><td>on|off </td><td>Turns the term rewriting templates/macros on or off.</td></tr>
<tr><td>callconv</td><td>cdecl|...</td><td>Specifies the default calling convention for all procedures (and procedure types) that follow.</td></tr>
</table><p>Example:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">checks</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Punctuation">,</span> <span class="Identifier">optimization</span><span class="Punctuation">:</span> <span class="Identifier">speed</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Comment"># compile without runtime checks and optimize for speed</span></pre>
<h2><a class="toc-backref" id="push-and-pop-pragmas" href="#push-and-pop-pragmas">push and pop pragmas</a></h2><p>The <span id="push-pop_1">push/pop</span> pragmas are very similar to the option directive, but are used to override the settings temporarily. Example:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">checks</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Comment"># compile this section without runtime checks as it is</span>
<span class="Comment"># speed critical</span>
<span class="Comment"># ... some code ...</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Comment"># restore old settings</span></pre>
<h2><a class="toc-backref" id="register-pragma" href="#register-pragma">register pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">register</span></tt> pragma is for variables only. It declares the variable as <tt class="docutils literal"><span class="pre">register</span></tt>, giving the compiler a hint that the variable should be placed in a hardware register for faster access. C compilers usually ignore this though and for good reasons: Often they do a better job without it anyway.</p>
<p>In highly specific cases (a dispatch loop of an bytecode interpreter for example) it may provide benefits, though.</p>

<h2><a class="toc-backref" id="global-pragma" href="#global-pragma">global pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">global</span></tt> pragma can be applied to a variable within a proc to instruct the compiler to store it in a global location and initialize it once at program startup.</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">isHexNumber</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">pattern</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">global</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="RawData">re&quot;[0-9a-fA-F]+&quot;</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">match</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span></pre><p>When used within a generic proc, a separate unique global variable will be created for each instantiation of the proc. The order of initialization of the created global variables within a module is not defined, but all of them will be initialized after any top-level variables in their originating module and before any variable in a module that imports it.</p>

<h2><a class="toc-backref" id="deadcodeelim-pragma" href="#deadcodeelim-pragma">deadCodeElim pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">deadCodeElim</span></tt> pragma only applies to whole modules: It tells the compiler to activate (or deactivate) dead code elimination for the module the pragma appears in.</p>
<p>The <tt class="docutils literal"><span class="pre">--deadCodeElim:on</span></tt> command line switch has the same effect as marking every module with <tt class="docutils literal"><span class="pre">{.deadCodeElim:on}</span></tt>. However, for some modules such as the GTK wrapper it makes sense to <em>always</em> turn on dead code elimination - no matter if it is globally active or not.</p>
<p>Example:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deadCodeElim</span><span class="Punctuation">:</span> <span class="Identifier">on</span><span class="Operator">.</span><span class="Punctuation">}</span></pre>
<h2><a class="toc-backref" id="pragma-pragma" href="#pragma-pragma">pragma pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">pragma</span></tt> pragma can be used to declare user defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</p>
<p>Example:</p>
<pre><span class="Keyword">when</span> <span class="Identifier">appType</span> <span class="Operator">==</span> <span class="StringLit">&quot;lib&quot;</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Punctuation">:</span> <span class="Identifier">rtl</span><span class="Punctuation">,</span> <span class="Identifier">exportc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">,</span> <span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Punctuation">:</span> <span class="Identifier">rtl</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;client.dll&quot;</span><span class="Punctuation">,</span> <span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">rtl</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">+</span><span class="Identifier">b</span></pre><p>In the example a new pragma named <tt class="docutils literal"><span class="pre">rtl</span></tt> is introduced that either imports a symbol from a dynamic library or exports the symbol for dynamic library generation.</p>

<h2><a class="toc-backref" id="disabling-certain-messages" href="#disabling-certain-messages">Disabling certain messages</a></h2><p>Nim generates some warnings and hints (&quot;line too long&quot;) that may annoy the user. A mechanism for disabling certain messages is provided: Each hint and warning message contains a symbol in brackets. This is the message's identifier that can be used to enable or disable it:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">hint</span><span class="Punctuation">[</span><span class="Identifier">LineTooLong</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Comment"># turn off the hint about too long lines</span></pre><p>This is often better than disabling all warnings at once.</p>

<h2><a class="toc-backref" id="experimental-pragma" href="#experimental-pragma">experimental pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">experimental</span></tt> pragma enables experimental language features. Depending on the concrete feature this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed any time).</p>
<p>Example:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">useUsing</span><span class="Punctuation">(</span><span class="Identifier">dest</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">using</span> <span class="Identifier">dest</span>
  <span class="Identifier">add</span> <span class="StringLit">&quot;foo&quot;</span>
  <span class="Identifier">add</span> <span class="StringLit">&quot;bar&quot;</span></pre>
<h1><a class="toc-backref" id="foreign-function-interface" href="#foreign-function-interface">Foreign function interface</a></h1><p>Nim's <span id="ffi_1">FFI</span> (foreign function interface) is extensive and only the parts that scale to other future backends (like the LLVM/JavaScript backends) are documented here.</p>

<h2><a class="toc-backref" id="importc-pragma" href="#importc-pragma">Importc pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">importc</span></tt> pragma provides a means to import a proc or a variable from C. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier <em>exactly as spelled</em>:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;stdio.h&gt;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;printf&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>Note that this pragma is somewhat of a misnomer: Other backends will provide the same feature under the same name. Also, if one is interfacing with C++ the <a class="reference external" href="nimc.html#importcpp-pragma">ImportCpp pragma</a> and interfacing with Objective-C the <a class="reference external" href="nimc.html#importobjc-pragma">ImportObjC pragma</a> can be used.</p>

<h2><a class="toc-backref" id="exportc-pragma" href="#exportc-pragma">Exportc pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">exportc</span></tt> pragma provides a means to export a type, a variable, or a procedure to C. Enums and constants can't be exported. The optional argument is a string containing the C identifier.  If the argument is missing, the C name is the Nim identifier <em>exactly as spelled</em>:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">exportc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;callMe&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>Note that this pragma is somewhat of a misnomer: Other backends will provide the same feature under the same name.</p>

<h2><a class="toc-backref" id="extern-pragma" href="#extern-pragma">Extern pragma</a></h2><p>Like <tt class="docutils literal"><span class="pre">exportc</span></tt> or <tt class="docutils literal"><span class="pre">importc</span></tt>, the <tt class="docutils literal"><span class="pre">extern</span></tt> pragma affects name mangling. The string literal passed to <tt class="docutils literal"><span class="pre">extern</span></tt> can be a format string:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">extern</span><span class="Punctuation">:</span> <span class="StringLit">&quot;prefix$1&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">s</span></pre><p>In the example the external name of <tt class="docutils literal"><span class="pre">p</span></tt> is set to <tt class="docutils literal"><span class="pre">prefixp</span></tt>.</p>

<h2><a class="toc-backref" id="bycopy-pragma" href="#bycopy-pragma">Bycopy pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">bycopy</span></tt> pragma can be applied to an object or tuple type and instructs the compiler to pass the type by value to procs:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">Vector</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">bycopy</span><span class="Punctuation">,</span> <span class="Identifier">pure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">float</span></pre>
<h2><a class="toc-backref" id="byref-pragma" href="#byref-pragma">Byref pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">byref</span></tt> pragma can be applied to an object or tuple type and instructs the compiler to pass the type by reference (hidden pointer) to procs.</p>

<h2><a class="toc-backref" id="varargs-pragma" href="#varargs-pragma">Varargs pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">varargs</span></tt> pragma can be applied to procedures only (and procedure types). It tells Nim that the proc can take a variable number of parameters after the last specified parameter. Nim string values will be converted to C strings automatically:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">nodecl</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Identifier">printf</span><span class="Punctuation">(</span><span class="StringLit">&quot;hallo %s&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;world&quot;</span><span class="Punctuation">)</span> <span class="Comment"># &quot;world&quot; will be passed as C string</span></pre>
<h2><a class="toc-backref" id="union-pragma" href="#union-pragma">Union pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">union</span></tt> pragma can be applied to any <tt class="docutils literal"><span class="pre">object</span></tt> type. It means all of the object's fields are overlaid in memory. This produces a <tt class="docutils literal"><span class="pre">union</span></tt> instead of a <tt class="docutils literal"><span class="pre">struct</span></tt> in the generated C/C++ code. The object declaration then must not use inheritance or any GC'ed memory but this is currently not checked.</p>
<p><strong>Future directions</strong>: GC'ed memory should be allowed in unions and the GC should scan unions conservatively.</p>

<h2><a class="toc-backref" id="packed-pragma" href="#packed-pragma">Packed pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">packed</span></tt> pragma can be applied to any <tt class="docutils literal"><span class="pre">object</span></tt> type. It ensures that the fields of an object are packed back-to-back in memory. It is useful to store packets or messages from/to network or hardware drivers, and for interoperability with C. Combining packed pragma with inheritance is not defined, and it should not be used with GC'ed memory (ref's).</p>
<p><strong>Future directions</strong>: Using GC'ed memory in packed pragma will result in compile-time error. Usage with inheritance should be defined and documented.</p>

<h2><a class="toc-backref" id="unchecked-pragma" href="#unchecked-pragma">Unchecked pragma</a></h2><p>The <tt class="docutils literal"><span class="pre">unchecked</span></tt> pragma can be used to mark a named array as <tt class="docutils literal"><span class="pre">unchecked</span></tt> meaning its bounds are not checked. This is often useful when one wishes to implement his own flexibly sized arrays. Additionally an unchecked array is translated into a C array of undetermined size:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">ArrayPart</span><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">unchecked</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">MySeq</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">cap</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">ArrayPart</span></pre><p>Produces roughly this C code:</p>
<pre><span class="Keyword">typedef</span> <span class="Keyword">struct</span> <span class="Punctuation">{</span>
  <span class="Identifier">NI</span> <span class="Identifier">len</span><span class="Punctuation">;</span>
  <span class="Identifier">NI</span> <span class="Identifier">cap</span><span class="Punctuation">;</span>
  <span class="Identifier">NI</span> <span class="Identifier">data</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span> <span class="Identifier">MySeq</span><span class="Punctuation">;</span></pre><p>The bounds checking done at compile time is not disabled for now, so to access <tt class="docutils literal"><span class="pre">s.data[C]</span></tt> (where <tt class="docutils literal"><span class="pre">C</span></tt> is a constant) the array's index needs needs to include <tt class="docutils literal"><span class="pre">C</span></tt>.</p>
<p>The base type of the unchecked array may not contain any GC'ed memory but this is currently not checked.</p>
<p><strong>Future directions</strong>: GC'ed memory should be allowed in unchecked arrays and there should be an explicit annotation of how the GC is to determine the runtime size of the array.</p>

<h2><a class="toc-backref" id="dynlib-pragma-for-import" href="#dynlib-pragma-for-import">Dynlib pragma for import</a></h2><p>With the <tt class="docutils literal"><span class="pre">dynlib</span></tt> pragma a procedure or a variable can be imported from a dynamic library (<tt class="docutils literal"><span class="pre">.dll</span></tt> files for Windows, <tt class="docutils literal"><span class="pre">lib*.so</span></tt> files for UNIX). The non-optional argument has to be the name of the dynamic library:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">gtk_image_new</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PGtkWidget</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;libgtk-x11-2.0.so&quot;</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>In general, importing a dynamic library does not require any special linker options or linking with import libraries. This also implies that no <em>devel</em> packages need to be installed.</p>
<p>The <tt class="docutils literal"><span class="pre">dynlib</span></tt> import mechanism supports a versioning scheme:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">Tcl_Eval</span><span class="Punctuation">(</span><span class="Identifier">interp</span><span class="Punctuation">:</span> <span class="Identifier">pTcl_Interp</span><span class="Punctuation">,</span> <span class="Identifier">script</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span>
  <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;libtcl(|8.5|8.4|8.3).so.(1|0)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>At runtime the dynamic library is searched for (in this order):<pre>
libtcl.so.1
libtcl.so.0
libtcl8.5.so.1
libtcl8.5.so.0
libtcl8.4.so.1
libtcl8.4.so.0
libtcl8.3.so.1
libtcl8.3.so.0</pre>
</p>
<p>The <tt class="docutils literal"><span class="pre">dynlib</span></tt> pragma supports not only constant strings as argument but also string expressions in general:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">os</span>

<span class="Keyword">proc</span> <span class="Identifier">getDllName</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;mylib.dll&quot;</span>
  <span class="Keyword">if</span> <span class="Identifier">existsFile</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;mylib2.dll&quot;</span>
  <span class="Keyword">if</span> <span class="Identifier">existsFile</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span>
  <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;could not load dynamic library&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">myImport</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="Identifier">getDllName</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p><strong>Note</strong>: Patterns like <tt class="docutils literal"><span class="pre">libtcl(|8.5|8.4).so</span></tt> are only supported in constant strings, because they are precompiled.</p>
<p><strong>Note</strong>: Passing variables to the <tt class="docutils literal"><span class="pre">dynlib</span></tt> pragma will fail at runtime because of order of initialization problems.</p>
<p><strong>Note</strong>: A <tt class="docutils literal"><span class="pre">dynlib</span></tt> import can be overriden with the <tt class="docutils literal"><span class="pre">--dynlibOverride:name</span></tt> command line option. The Compiler User Guide contains further information.</p>

<h2><a class="toc-backref" id="dynlib-pragma-for-export" href="#dynlib-pragma-for-export">Dynlib pragma for export</a></h2><p>With the <tt class="docutils literal"><span class="pre">dynlib</span></tt> pragma a procedure can also be exported to a dynamic library. The pragma then has no argument and has to be used in conjunction with the <tt class="docutils literal"><span class="pre">exportc</span></tt> pragma:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">exportme</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">exportc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>This is only useful if the program is compiled as a dynamic library via the <tt class="docutils literal"><span class="pre">--app:lib</span></tt> command line option. </p>

<h1><a class="toc-backref" id="threads" href="#threads">Threads</a></h1><p>To enable thread support the <tt class="docutils literal"><span class="pre">--threads:on</span></tt> command line switch needs to be used. The <tt class="docutils literal"><span class="pre">system</span></tt> module then contains several threading primitives. See the <a class="reference external" href="threads.html">threads</a> and <a class="reference external" href="channels.html">channels</a> modules for the low level thread API. There are also high level parallelism constructs available. See <a class="reference external" href="#spawn">spawn</a> for further details.</p>
<p>Nim's memory model for threads is quite different than that of other common programming languages (C, Pascal, Java): Each thread has its own (garbage collected) heap and sharing of memory is restricted to global variables. This helps to prevent race conditions. GC efficiency is improved quite a lot, because the GC never has to stop other threads and see what they reference. Memory allocation requires no lock at all! This design easily scales to massive multicore processors that are becoming the norm.</p>

<h2><a class="toc-backref" id="thread-pragma" href="#thread-pragma">Thread pragma</a></h2><p>A proc that is executed as a new thread of execution should be marked by the <tt class="docutils literal"><span class="pre">thread</span></tt> pragma for reasons of readability. The compiler checks for violations of the <span id="no-heap-sharing-restriction_1">no heap sharing restriction</span>: This restriction implies that it is invalid to construct a data structure that consists of memory allocated from different (thread local) heaps.</p>
<p>A thread proc is passed to <tt class="docutils literal"><span class="pre">createThread</span></tt> or <tt class="docutils literal"><span class="pre">spawn</span></tt> and invoked indirectly; so the <tt class="docutils literal"><span class="pre">thread</span></tt> pragma implies <tt class="docutils literal"><span class="pre">procvar</span></tt>.</p>

<h2><a class="toc-backref" id="gc-safety" href="#gc-safety">GC safety</a></h2><p>We call a proc <tt class="docutils literal"><span class="pre">p</span></tt> <span id="gc-safe_1">GC safe</span> when it doesn't access any global variable that contains GC'ed memory (<tt class="docutils literal"><span class="pre">string</span></tt>, <tt class="docutils literal"><span class="pre">seq</span></tt>, <tt class="docutils literal"><span class="pre">ref</span></tt> or a closure) either directly or indirectly through a call to a GC unsafe proc.</p>
<p>The <span id="gcsafe_1">gcsafe</span> annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that <tt class="docutils literal"><span class="pre">noSideEfect</span></tt> implies <tt class="docutils literal"><span class="pre">gcsafe</span></tt>. The only way to create a thread is via <tt class="docutils literal"><span class="pre">spawn</span></tt> or <tt class="docutils literal"><span class="pre">createThead</span></tt>. <tt class="docutils literal"><span class="pre">spawn</span></tt> is usually the preferable method. Either way the invoked proc must not use <tt class="docutils literal"><span class="pre">var</span></tt> parameters nor must any of its parameters contain a <tt class="docutils literal"><span class="pre">ref</span></tt> or <tt class="docutils literal"><span class="pre">closure</span></tt> type. This enforces the <em>no heap sharing restriction</em>.</p>
<p>Routines that are imported from C are always assumed to be <tt class="docutils literal"><span class="pre">gcsafe</span></tt>. To enable the GC-safety checking the <tt class="docutils literal"><span class="pre">--threadAnalysis:on</span></tt> command line switch must be used. This is a temporary workaround to ease the porting effort from old code to the new threading model. In the future the thread analysis will always be performed.</p>
<p>Future directions:</p>
<ul class="simple"><li>A shared GC'ed heap might be provided.</li>
</ul>

<h2><a class="toc-backref" id="threadvar-pragma" href="#threadvar-pragma">Threadvar pragma</a></h2><p>A global variable can be marked with the <tt class="docutils literal"><span class="pre">threadvar</span></tt> pragma; it is a <span id="thread-local_1">thread-local</span> variable then:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">checkpoints</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">threadvar</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span></pre><p>Due to implementation restrictions thread local variables cannot be initialized within the <tt class="docutils literal"><span class="pre">var</span></tt> section. (Every thread local variable needs to be replicated at thread creation.)</p>

<h2><a class="toc-backref" id="threads-and-exceptions" href="#threads-and-exceptions">Threads and exceptions</a></h2><p>The interaction between threads and exceptions is simple: A <em>handled</em> exception in one thread cannot affect any other thread. However, an <em>unhandled</em> exception in one thread terminates the whole <em>process</em>!</p>

<h1><a class="toc-backref" id="parallel-spawn" href="#parallel-spawn">Parallel &amp; Spawn</a></h1><p>Nim has two flavors of parallelism:</p>
<ol class="simple"><li><span id="structured_1">Structured</span> parallelism via the <tt class="docutils literal"><span class="pre">parallel</span></tt> statement.</li>
<li><span id="unstructured_1">Unstructured</span> parallelism via the standalone <tt class="docutils literal"><span class="pre">spawn</span></tt> statement.</li>
</ol>
<p>Nim has a builtin thread pool that can be used for CPU intensive tasks. For IO intensive tasks the <tt class="docutils literal"><span class="pre">async</span></tt> and <tt class="docutils literal"><span class="pre">await</span></tt> features should be used instead. Both parallel and spawn need the <a class="reference external" href="threadpool.html">threadpool</a> module to work.</p>
<p>Somewhat confusingly, <tt class="docutils literal"><span class="pre">spawn</span></tt> is also used in the <tt class="docutils literal"><span class="pre">parallel</span></tt> statement with slightly different semantics. <tt class="docutils literal"><span class="pre">spawn</span></tt> always takes a call expression of the form <tt class="docutils literal"><span class="pre">f(a, ...)</span></tt>. Let <tt class="docutils literal"><span class="pre">T</span></tt> be <tt class="docutils literal"><span class="pre">f</span></tt>'s return type. If <tt class="docutils literal"><span class="pre">T</span></tt> is <tt class="docutils literal"><span class="pre">void</span></tt> then <tt class="docutils literal"><span class="pre">spawn</span></tt>'s return type is also <tt class="docutils literal"><span class="pre">void</span></tt> otherwise it is <tt class="docutils literal"><span class="pre">FlowVar[T]</span></tt>.</p>
<p>Within a <tt class="docutils literal"><span class="pre">parallel</span></tt> section sometimes the <tt class="docutils literal"><span class="pre">FlowVar[T]</span></tt> is eliminated to <tt class="docutils literal"><span class="pre">T</span></tt>. This happens when <tt class="docutils literal"><span class="pre">T</span></tt> does not contain any GC'ed memory. The compiler can ensure the location in <tt class="docutils literal"><span class="pre">location = spawn f(...)</span></tt> is not read prematurely within a <tt class="docutils literal"><span class="pre">parallel</span></tt> section and so there is no need for the overhead of an indirection via <tt class="docutils literal"><span class="pre">FlowVar[T]</span></tt> to ensure correctness.</p>
<p><strong>Note</strong>: Currently exceptions are not propagated between <tt class="docutils literal"><span class="pre">spawn</span></tt>'ed tasks!</p>

<h2><a class="toc-backref" id="spawn-statement" href="#spawn-statement">Spawn statement</a></h2><p><span id="spawn_1">spawn</span> can be used to pass a task to the thread pool:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">threadpool</span>

<span class="Keyword">proc</span> <span class="Identifier">processLine</span><span class="Punctuation">(</span><span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">discard</span> <span class="StringLit">&quot;do some heavy lifting here&quot;</span>

<span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Identifier">lines</span><span class="Punctuation">(</span><span class="StringLit">&quot;myinput.txt&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">spawn</span> <span class="Identifier">processLine</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>
<span class="Identifier">sync</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>For reasons of type safety and implementation simplicity the expression that <tt class="docutils literal"><span class="pre">spawn</span></tt> takes is restricted:</p>
<ul class="simple"><li>It must be a call expression <tt class="docutils literal"><span class="pre">f(a, ...)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">f</span></tt> must be <tt class="docutils literal"><span class="pre">gcsafe</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">f</span></tt> must not have the calling convention <tt class="docutils literal"><span class="pre">closure</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">f</span></tt>'s parameters may not be of type <tt class="docutils literal"><span class="pre">var</span></tt>. This means one has to use raw <tt class="docutils literal"><span class="pre">ptr</span></tt>'s for data passing reminding the programmer to be careful.</li>
<li><tt class="docutils literal"><span class="pre">ref</span></tt> parameters are deeply copied which is a subtle semantic change and can cause performance problems but ensures memory safety. This deep copy is performed via <tt class="docutils literal"><span class="pre">system.deepCopy</span></tt> and so can be overriden.</li>
<li>For <em>safe</em> data exchange between <tt class="docutils literal"><span class="pre">f</span></tt> and the caller a global <tt class="docutils literal"><span class="pre">TChannel</span></tt> needs to be used. However, since spawn can return a result, often no further communication is required.</li>
</ul>
<p><tt class="docutils literal"><span class="pre">spawn</span></tt> executes the passed expression on the thread pool and returns a <span id="data-flow-variable_1">data flow variable</span> <tt class="docutils literal"><span class="pre">FlowVar[T]</span></tt> that can be read from. The reading with the <tt class="docutils literal"><span class="pre">^</span></tt> operator is <strong>blocking</strong>. However, one can use <tt class="docutils literal"><span class="pre">awaitAny</span></tt> to wait on multiple flow variables at the same time:</p>
<pre><span class="Keyword">import</span> <span class="Identifier">threadpool</span><span class="Punctuation">,</span> <span class="Operator">...</span>

<span class="Comment"># wait until 2 out of 3 servers received the update:</span>
<span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">responses</span> <span class="Operator">=</span> <span class="Identifier">newSeq</span><span class="Punctuation">[</span><span class="Identifier">RawFlowVar</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">:</span>
    <span class="Identifier">responses</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">spawn</span> <span class="Identifier">tellServer</span><span class="Punctuation">(</span><span class="Identifier">Update</span><span class="Punctuation">,</span> <span class="StringLit">&quot;key&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">index</span> <span class="Operator">=</span> <span class="Identifier">awaitAny</span><span class="Punctuation">(</span><span class="Identifier">responses</span><span class="Punctuation">)</span>
  <span class="Identifier">assert</span> <span class="Identifier">index</span> <span class="Operator">&gt;=</span> <span class="DecNumber">0</span>
  <span class="Identifier">responses</span><span class="Operator">.</span><span class="Identifier">del</span><span class="Punctuation">(</span><span class="Identifier">index</span><span class="Punctuation">)</span>
  <span class="Keyword">discard</span> <span class="Identifier">awaitAny</span><span class="Punctuation">(</span><span class="Identifier">responses</span><span class="Punctuation">)</span></pre><p>Data flow variables ensure that no data races are possible. Due to technical limitations not every type <tt class="docutils literal"><span class="pre">T</span></tt> is possible in a data flow variable: <tt class="docutils literal"><span class="pre">T</span></tt> has to be of the type <tt class="docutils literal"><span class="pre">ref</span></tt>, <tt class="docutils literal"><span class="pre">string</span></tt>, <tt class="docutils literal"><span class="pre">seq</span></tt> or of a type that doesn't contain a type that is garbage collected. This restriction is not hard to work-around in practice.</p>

<h2><a class="toc-backref" id="parallel-statement" href="#parallel-statement">Parallel statement</a></h2><p>Example:</p>
<pre><span class="Comment"># Compute PI in an inefficient way</span>
<span class="Keyword">import</span> <span class="Identifier">strutils</span><span class="Punctuation">,</span> <span class="Identifier">math</span><span class="Punctuation">,</span> <span class="Identifier">threadpool</span>

<span class="Keyword">proc</span> <span class="Identifier">term</span><span class="Punctuation">(</span><span class="Identifier">k</span><span class="Punctuation">:</span> <span class="Identifier">float</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span> <span class="DecNumber">4</span> <span class="Operator">*</span> <span class="Identifier">math</span><span class="Operator">.</span><span class="Identifier">pow</span><span class="Punctuation">(</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">k</span><span class="Punctuation">)</span> <span class="Operator">/</span> <span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Operator">*</span><span class="Identifier">k</span> <span class="Operator">+</span> <span class="DecNumber">1</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">pi</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">ch</span> <span class="Operator">=</span> <span class="Identifier">newSeq</span><span class="Punctuation">[</span><span class="Identifier">float</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">+</span><span class="DecNumber">1</span><span class="Punctuation">)</span>
  <span class="Identifier">parallel</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">k</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">ch</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
      <span class="Identifier">ch</span><span class="Punctuation">[</span><span class="Identifier">k</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">spawn</span> <span class="Identifier">term</span><span class="Punctuation">(</span><span class="Identifier">float</span><span class="Punctuation">(</span><span class="Identifier">k</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">k</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">ch</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">+=</span> <span class="Identifier">ch</span><span class="Punctuation">[</span><span class="Identifier">k</span><span class="Punctuation">]</span>

<span class="Identifier">echo</span> <span class="Identifier">formatFloat</span><span class="Punctuation">(</span><span class="Identifier">pi</span><span class="Punctuation">(</span><span class="DecNumber">5000</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>The parallel statement is the preferred mechanism to introduce parallelism in a Nim program. A subset of the Nim language is valid within a <tt class="docutils literal"><span class="pre">parallel</span></tt> section. This subset is checked to be free of data races at compile time. A sophisticated <span id="disjoint-checker_1">disjoint checker</span> ensures that no data races are possible even though shared memory is extensively supported!</p>
<p>The subset is in fact the full language with the following restrictions / changes:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">spawn</span></tt> within a <tt class="docutils literal"><span class="pre">parallel</span></tt> section has special semantics.</li>
<li>Every location of the form <tt class="docutils literal"><span class="pre">a[i]</span></tt> and <tt class="docutils literal"><span class="pre">a[i..j]</span></tt> and <tt class="docutils literal"><span class="pre">dest</span></tt> where <tt class="docutils literal"><span class="pre">dest</span></tt> is part of the pattern <tt class="docutils literal"><span class="pre">dest = spawn f(...)</span></tt> has to be provably disjoint. This is called the <em>disjoint check</em>.</li>
<li>Every other complex location <tt class="docutils literal"><span class="pre">loc</span></tt> that is used in a spawned proc (<tt class="docutils literal"><span class="pre">spawn f(loc)</span></tt>) has to be immutable for the duration of the <tt class="docutils literal"><span class="pre">parallel</span></tt> section. This is called the <em>immutability check</em>. Currently it is not specified what exactly &quot;complex location&quot; means. We need to make this an optimization!</li>
<li>Every array access has to be provably within bounds. This is called the <em>bounds check</em>.</li>
<li>Slices are optimized so that no copy is performed. This optimization is not yet performed for ordinary slices outside of a <tt class="docutils literal"><span class="pre">parallel</span></tt> section. Slices are also special in that they currently do not support negative indexes!</li>
</ul>

<h1><a class="toc-backref" id="guards-and-locks" href="#guards-and-locks">Guards and locks</a></h1><p>Apart from <tt class="docutils literal"><span class="pre">spawn</span></tt> and <tt class="docutils literal"><span class="pre">parallel</span></tt> Nim also provides all the common low level concurrency mechanisms like locks, atomic intristics or condition variables.</p>
<p>Nim significantly improves on the safety of these features via additional pragmas:</p>
<ol class="simple"><li>A <span id="guard_1">guard</span> annotation is introduced to prevent data races.</li>
<li>Every access of a guarded memory location needs to happen in an appropriate <span id="locks_1">locks</span> statement.</li>
<li>Locks and routines can be annotated with <span id="lock-levels_1">lock levels</span> to prevent deadlocks at compile time.</li>
</ol>

<h2><a class="toc-backref" id="guards-and-the-locks-section" href="#guards-and-the-locks-section">Guards and the locks section</a></h2>
<h3><a class="toc-backref" id="protecting-global-variables" href="#protecting-global-variables">Protecting global variables</a></h3><p>Object fields and global variables can be annotated via a <tt class="docutils literal"><span class="pre">guard</span></tt> pragma:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">glock</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span>
<span class="Keyword">var</span> <span class="Identifier">gdata</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">guard</span><span class="Punctuation">:</span> <span class="Identifier">glock</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>The compiler then ensures that every access of <tt class="docutils literal"><span class="pre">gdata</span></tt> is within a <tt class="docutils literal"><span class="pre">locks</span></tt> section:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">invalid</span> <span class="Operator">=</span>
  <span class="Comment"># invalid: unguarded access:</span>
  <span class="Identifier">echo</span> <span class="Identifier">gdata</span>

<span class="Keyword">proc</span> <span class="Identifier">valid</span> <span class="Operator">=</span>
  <span class="Comment"># valid access:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">glock</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">gdata</span></pre><p>Top level accesses to <tt class="docutils literal"><span class="pre">gdata</span></tt> are always allowed so that it can be initialized conveniently. It is <em>assumed</em> (but not enforced) that every top level statement is executed before any concurrent action happens.</p>
<p>The <tt class="docutils literal"><span class="pre">locks</span></tt> section deliberately looks ugly because it has no runtime semantics and should not be used directly! It should only be used in templates that also implement some form of locking at runtime:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">lock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span><span class="Punctuation">;</span> <span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">body</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">pthread_mutex_unlock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span></pre><p>The guard does not need to be of any particular type. It is flexible enough to model low level lockfree mechanisms:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">dummyLock</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Keyword">var</span> <span class="Identifier">atomicCounter</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">guard</span><span class="Punctuation">:</span> <span class="Identifier">dummyLock</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">template</span> <span class="Identifier">atomicRead</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">expr</span> <span class="Operator">=</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">dummyLock</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">memoryReadBarrier</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Identifier">x</span>

<span class="Identifier">echo</span> <span class="Identifier">atomicRead</span><span class="Punctuation">(</span><span class="Identifier">atomicCounter</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">locks</span></tt> pragma takes a list of lock expressions <tt class="docutils literal"><span class="pre">locks: [a, b, ...]</span></tt> in order to support <em>multi lock</em> statements. Why these are essential is explained in the <a class="reference external" href="#lock-levels">lock levels</a> section.</p>

<h3><a class="toc-backref" id="protecting-general-locations" href="#protecting-general-locations">Protecting general locations</a></h3><p>The <tt class="docutils literal"><span class="pre">guard</span></tt> annotation can also be used to protect fields within an object. The guard then needs to be another field within the same object or a global variable.</p>
<p>Since objects can reside on the heap or on the stack this greatly enhances the expressivity of the language:</p>
<pre><span class="Keyword">type</span>
  <span class="Identifier">ProtectedCounter</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">v</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">guard</span><span class="Punctuation">:</span> <span class="Identifier">L</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">L</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span>

<span class="Keyword">proc</span> <span class="Identifier">incCounters</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">ProtectedCounter</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">counters</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Identifier">lock</span> <span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">:</span>
      <span class="Identifier">inc</span> <span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">v</span></pre><p>The access to field <tt class="docutils literal"><span class="pre">x.v</span></tt> is allowed since its guard <tt class="docutils literal"><span class="pre">x.L</span></tt>  is active. After template expansion, this amounts to:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">incCounters</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">ProtectedCounter</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">counters</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">)</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
      <span class="Keyword">try</span><span class="Punctuation">:</span>
        <span class="Identifier">inc</span> <span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">v</span>
      <span class="Keyword">finally</span><span class="Punctuation">:</span>
        <span class="Identifier">pthread_mutex_unlock</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">)</span></pre><p>There is an analysis that checks that <tt class="docutils literal"><span class="pre">counters[i].L</span></tt> is the lock that corresponds to the protected location <tt class="docutils literal"><span class="pre">counters[i].v</span></tt>. This analysis is called <span id="path-analysis_1">path analysis</span> because it deals with paths to locations like <tt class="docutils literal"><span class="pre">obj.field[i].fieldB[j]</span></tt>.</p>
<p>The path analysis is <strong>currently unsound</strong>, but that doesn't make it useless. Two paths are considered equivalent if they are syntactically the same.</p>
<p>This means the following compiles (for now) even though it really should not:</p>
<pre><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Identifier">inc</span> <span class="Identifier">i</span>
  <span class="Identifier">access</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">v</span></pre>
<h2><a class="toc-backref" id="lock-levels" href="#lock-levels">Lock levels</a></h2><p>Lock levels are used to enforce a global locking order in order to prevent deadlocks at compile-time. A lock level is an constant integer in the range 0..1_000. Lock level 0 means that no lock is acquired at all.</p>
<p>If a section of code holds a lock of level <tt class="docutils literal"><span class="pre">M</span></tt> than it can also acquire any lock of level <tt class="docutils literal"><span class="pre">N &lt; M</span></tt>. Another lock of level <tt class="docutils literal"><span class="pre">M</span></tt> cannot be acquired. Locks of the same level can only be acquired <em>at the same time</em> within a single <tt class="docutils literal"><span class="pre">locks</span></tt> section:</p>
<pre><span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span><span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">]</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span>
<span class="Comment"># invalid locking order: TLock[1] cannot be acquired before TLock[2]:</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">x</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Operator">...</span>
<span class="Comment"># valid locking order: TLock[2] acquired before TLock[1]:</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">x</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Operator">...</span>

<span class="Comment"># invalid locking order: TLock[2] acquired before TLock[2]:</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">b</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Operator">...</span>

<span class="Comment"># valid locking order, locks of the same level acquired at the same time:</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Operator">...</span></pre><p>Here is how a typical multilock statement can be implemented in Nim. Note how the runtime check is required to ensure a global ordering for two locks <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> of the same lock level:</p>
<pre><span class="Keyword">template</span> <span class="Identifier">multilock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">TLock</span><span class="Punctuation">;</span> <span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">stmt</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">ByteAddress</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">&lt;</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">ByteAddress</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">body</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">pthread_mutex_unlock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
      <span class="Identifier">pthread_mutex_unlock</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span></pre><p>Whole routines can also be annotated with a <tt class="docutils literal"><span class="pre">locks</span></tt> pragma that takes a lock level. This then means that the routine may acquire locks of up to this level. This is essential so that procs can be called within a <tt class="docutils literal"><span class="pre">locks</span></tt> section:</p>
<pre><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="FloatNumber">3.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">]</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Comment"># p's locklevel (3) is strictly less than a's (4) so the call is allowed:</span>
  <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>As usual <tt class="docutils literal"><span class="pre">locks</span></tt> is an inferred effect and there is a subtype relation: <tt class="docutils literal"><span class="pre">proc () {.locks: N.}</span></tt> is a subtype of <tt class="docutils literal"><span class="pre">proc () {.locks: M.}</span></tt> iff (M &lt;= N). </p>

<h1><a class="toc-backref" id="taint-mode" href="#taint-mode">Taint mode</a></h1><p>The Nim compiler and most parts of the standard library support a taint mode. Input strings are declared with the <span id="taintedstring_1">TaintedString</span> string type declared in the <tt class="docutils literal"><span class="pre">system</span></tt> module.</p>
<p>If the taint mode is turned on (via the <tt class="docutils literal"><span class="pre">--taintMode:on</span></tt> command line option) it is a distinct string type which helps to detect input validation errors:</p>
<pre><span class="Identifier">echo</span> <span class="StringLit">&quot;your name: &quot;</span>
<span class="Keyword">var</span> <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">TaintedString</span> <span class="Operator">=</span> <span class="Identifier">stdin</span><span class="Operator">.</span><span class="Identifier">readline</span>
<span class="Comment"># it is safe here to output the name without any input validation, so</span>
<span class="Comment"># we simply convert `name` to string to make the compiler happy:</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Operator">.</span><span class="Identifier">string</span></pre><p>If the taint mode is turned off, <tt class="docutils literal"><span class="pre">TaintedString</span></tt> is simply an alias for <tt class="docutils literal"><span class="pre">string</span></tt>. </p>
</p>
  
  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small>Made with Nim. Generated: 2015-03-13 21:15:58 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
